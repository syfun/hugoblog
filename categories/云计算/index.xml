<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>云计算 on Sung Yung</title>
    <link>/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/index.xml</link>
    <description>Recent content in 云计算 on Sung Yung</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Openstack Swift tempurl 和 largeobject 支持</title>
      <link>/post/swift-tempurl/</link>
      <pubDate>Mon, 04 Jan 2016 19:07:44 +0800</pubDate>
      
      <guid>/post/swift-tempurl/</guid>
      <description>&lt;h2 id=&#34;tempurl&#34;&gt;Tempurl&lt;/h2&gt;

&lt;p&gt;在使用网盘时，我们有时会把文件共享给没有账户权限的人，这时候就需要tempurl中间件的支持。tempurl中间件可以生成一个有时限的GET链接，其他人只需要这个链接就可以进行下载。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h4 id=&#34;url格式&#34;&gt;URL格式&lt;/h4&gt;

&lt;p&gt;我们先看下面的例子(偷懒了，这是官方提供的)：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;https://swift-cluster.example.com/v1/my_account/container/object
?temp_url_sig=da39a3ee5e6b4b0d3255bfef95601890afd80709
&amp;amp;temp_url_expires=1323479485
&amp;amp;filename=My+Test+File.pdf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个URL包括了下面几个部分：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;对象路径&lt;/li&gt;
&lt;li&gt;temp_url_sig，用HMAC-SHA1生成的签名，使用HTTP方法、过期时间、对象路径和一个秘钥生成&lt;/li&gt;
&lt;li&gt;temp_url_expires，过期时间&lt;/li&gt;
&lt;li&gt;文件名，这是可选的，覆盖默认的对象名&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;秘钥&#34;&gt;秘钥&lt;/h4&gt;

&lt;p&gt;秘钥主要指的是账户和容器的一个秘钥属性。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;账户：
X-Account-Meta-Temp-URL-Key
X-Account-Meta-Temp-URL-Key-2

容器：
X-Container-Meta-Temp-URL-Key
X-Container-Meta-Temp-URL-Key-2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过如下方式设置：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;账户：
swift post -m &amp;quot;Temp-URL-Key:MYKEY&amp;quot;

容器：
swift post container -m &amp;quot;Temp-URL-Key:MYKEY&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;hmac-sha1签名&#34;&gt;HMAC-SHA1签名&lt;/h4&gt;

&lt;p&gt;同样，先给例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import hmac
from hashlib import sha1
from time import time
method = &#39;GET&#39;
duration_in_seconds = 60*60*24
expires = int(time() + duration_in_seconds)
path = &#39;/v1/my_account/container/object&#39;
key = &#39;MYKEY&#39;
hmac_body = &#39;%s\n%s\n%s&#39; % (method, expires, path)
signature = hmac.new(key, hmac_body, sha1).hexdigest()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;method也可以是PUT方法。&lt;/p&gt;

&lt;h4 id=&#34;swift-tempurl命令&#34;&gt;swift tempurl命令&lt;/h4&gt;

&lt;p&gt;先看例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;swift tempurl GET 3600 /v1/my_account/container/object MYKEY
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;help信息：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;Generates a temporary URL for a Swift object.

Positional arguments:
  &amp;lt;method&amp;gt;              An HTTP method to allow for this temporary URL.
                        Usually &#39;GET&#39; or &#39;PUT&#39;.
  &amp;lt;seconds&amp;gt;             The amount of time in seconds the temporary URL will be
                        valid for; or, if --absolute is passed, the Unix
                        timestamp when the temporary URL will expire.
  &amp;lt;path&amp;gt;                The full path to the Swift object. Example:
                        /v1/AUTH_account/c/o.
  &amp;lt;key&amp;gt;                 The secret temporary URL key set on the Swift cluster.
                        To set a key, run &#39;swift post -m
                        &amp;quot;Temp-URL-Key:b3968d0207b54ece87cccc06515a89d4&amp;quot;&#39;

Optional arguments:
  --absolute            Interpet the &amp;lt;seconds&amp;gt; positional argument as a Unix
                        timestamp rather than a number of seconds in the
                        future.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;static-large-object&#34;&gt;Static Large object&lt;/h2&gt;

&lt;p&gt;manifest文件，分片按顺序存&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[
    {
        &amp;quot;path&amp;quot;: &amp;quot;mycontainer/objseg1&amp;quot;,
        &amp;quot;etag&amp;quot;: &amp;quot;0228c7926b8b642dfb29554cd1f00963&amp;quot;,
        &amp;quot;size_bytes&amp;quot;: 1468006
    },
    {
        &amp;quot;path&amp;quot;: &amp;quot;mycontainer/pseudodir/seg-obj2&amp;quot;,
        &amp;quot;etag&amp;quot;: &amp;quot;5bfc9ea51a00b790717eeb934fb77b9b&amp;quot;,
        &amp;quot;size_bytes&amp;quot;: 1572864
    },
    {
        &amp;quot;path&amp;quot;: &amp;quot;other-container/seg-final&amp;quot;,
        &amp;quot;etag&amp;quot;: &amp;quot;b9c3da507d2557c1ddc51f27c54bae51&amp;quot;,
        &amp;quot;size_bytes&amp;quot;: 256
    }
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将manifest上传，添加?multipart-manifest=put。上传完成后，X-Static-Large-Object为true。&lt;/p&gt;

&lt;p&gt;下载正常。&lt;/p&gt;

&lt;p&gt;删除要删除分片的话需要?multipart-manifest=delete&lt;/p&gt;

&lt;p&gt;COPY时候?multipart-manifest=get只拷贝manifest。&lt;/p&gt;

&lt;p&gt;断点续传：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http://192.168.99.100:8080/v1/AUTH_a5b3c5a9f5354e4da74e9d0af7b849a9/test?prefix=ss&amp;amp;format=json
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>PaaS以及开源PaaS平台</title>
      <link>/post/pass/</link>
      <pubDate>Fri, 26 Jun 2015 22:12:41 +0800</pubDate>
      
      <guid>/post/pass/</guid>
      <description>&lt;h2 id=&#34;一-什么是iaas-paas和saas及其区别&#34;&gt;一、什么是IaaS, PaaS和SaaS及其区别&lt;/h2&gt;

&lt;p&gt;任何一个在互联网上提供其服务的公司都可以叫做云计算公司。其实云计算分几层的，
 分别是Infrastructure（基础设施）-as-a- Service，Platform（平台）-as-a-Service，
 Software（软件）-as-a-Service。基础设施在最下端，平台在 中间，软件在顶端。
 别的一些“软”的层可以在这些层上面添加。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/iaas-paas-saas.jpg&#34; alt=&#34;IaaS-PaaS-SaaS&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;iaas-infrastructure-as-a-service-基础设施即服务&#34;&gt;IaaS: Infrastructure-as-a-Service（基础设施即服务）&lt;/h3&gt;

&lt;p&gt;第一层叫做IaaS，有时候也叫做Hardware-as-a-Service，几年前如果你想在办公室或
 者公司的网站上运行一些企业应用，你需要去买服务器，或者别的高昂的硬件来控制本地应用，
 让你的业务运行起来。&lt;/p&gt;

&lt;p&gt;但是现在有IaaS，你可以将硬件外包到别的地方去。IaaS公司会提供场外服务器，存储和网络硬件，
你可以租用。节省了维护成本和办公场地，公司可以在任何时候利用这些硬件来运行其应用。&lt;/p&gt;

&lt;p&gt;一些大的IaaS公司包括Amazon, Microsoft, VMWare, Rackspace和Red Hat.不过这些公司又都有自
己的专长，比如Amazon和微软给你提供的不只是IaaS，他们还会将其计算能力出租给你来host你的网站。&lt;/p&gt;

&lt;h3 id=&#34;paas-platform-as-a-service-平台即服务&#34;&gt;PaaS: Platform-as-a-Service（平台即服务）&lt;/h3&gt;

&lt;p&gt;第二层就是所谓的PaaS，某些时候也叫做中间件。你公司所有的开发都可以在这一层进行，节省了时间和资源。&lt;/p&gt;

&lt;p&gt;PaaS公司在网上提供各种开发和分发应用的解决方案，比如虚拟服务器和操作系统。这节省了你在硬件上的费用，
也让分散的工作室之间的合作变得更加容易。网页应用管理，应用设计，应用虚拟主机，存储，安全以及应用开发协作工具等。&lt;/p&gt;

&lt;h3 id=&#34;saas-software-as-a-service-软件即服务&#34;&gt;SaaS: Software-as-a-Service（软件即服务）&lt;/h3&gt;

&lt;p&gt;第三层也就是所谓SaaS。这一层是和你的生活每天接触的一层，大多是通过网页浏览器来接入。任何一个远程服务器
上的应用都可以通过网络来运行，就是SaaS了。&lt;/p&gt;

&lt;p&gt;你消费的服务完全是从网页如Netflix, MOG, Google Apps, Box.net, Dropbox或者苹果的iCloud那里进入这些分类。
尽管这些网页服务是用作商务和娱乐或者两者都有，但这也算是云技术的一部分。&lt;/p&gt;

&lt;h2 id=&#34;二-paas&#34;&gt;二、PaaS&lt;/h2&gt;

&lt;p&gt;PaaS是Platform-as-a-Service的缩写，意思是平台即服务。把服务器平台作为一种服务提供的商业模式。
通过网络进行程序提供的服务称之为SaaS，而云计算时代相应的服务器平台或者开发环
境作为服务进行提供就成为了PaaS。&lt;/p&gt;

&lt;p&gt;所谓PaaS实际上是指将软件研发的平台作为一种服务，以SaaS的模式提交给用户。因此，PaaS也是SaaS模式的一种应用。但是，PaaS的出现可以加快SaaS的发展，尤其是加快SaaS应用的开发速度。
在2007年国内外SaaS厂商先后推出自己的PAAS平台。&lt;/p&gt;

&lt;h3 id=&#34;作用&#34;&gt;作用&lt;/h3&gt;

&lt;p&gt;PaaS之所以能够推进SaaS的发展，主要在于它能够提供企业进行定制化研发的中间件平台，同时涵盖数据库和应用服务器等。PaaS可以提高在Web平台上利用的资源数量。例如，可通过远程Web服务使用数据即服务（Data-as-a-Service：数据即服务），还可以使用可视化的API，甚至像800app的PaaS平台还允许你混合并匹配适合你应用的其他平台。用户或者厂商基于PaaS平台可以快速开发自己所需要的应用和产品。同时，PaaS平台开发的应用能更好地搭建基于SOA架构的企业应用。&lt;/p&gt;

&lt;p&gt;此外，PaaS对于SaaS运营商来说，可以帮助他进行产品多元化和产品定制化。例如Salesforce的PaaS平台让更多的ISV成为其平台的客户，从而开发出基于他们平台的多种SaaS应用，使其成为多元化软件服务供货商（Multi Application Vendor），而不再只是一家CRM随选服务提供商。而国内的SaaS厂商800app通过PaaS平台，改变了仅是CRM供应商的市场定位，实现了 BTO(Built to order:按订单生产)，和在线交付流程。使用800app的PAAS开发平台，用户不再需要任何编程即可开发包括CRM、OA、HR、SCM、进销存管理等任何企业管理软件，而且不需要使用其他软件开发工具并立即在线运行。
面向个人的EC站点(electronic commerce site)的巨头公司Amazon，把最初为了自己公司的运营用的构筑起来的系统平台，进行出租，用户可以自由选择操作系统和中间软件，以这样的方式提供硬件以及软件平台作为服务，最初被海外以一些冒险事业的企业所使用。从2006年开始 Amazon EC Amazon S3开始作为服务推向市场。&lt;/p&gt;

&lt;p&gt;还有现代软件业霸主同时又是次时代计算的先驱的Google,大家都知道在世界上构筑以及运行了非常多的数据中心。以搜索引擎以及新的广告模式而闻名。他们使用便宜的计算机和强有力的中间件，以及自己的技术装备出了世界上最强大的数据中心，以及超高性能的并行计算群。2008年4月发表的PaaS服务Google App Engine和Amazon 的 EC2,S3,SimpleDB等服务拥有相似的功能。这些稳定的平台上同样搜索引擎，GMail等服务也在运行。同样以ASP~SaaS成功的Salesforce，2007年开始用于提供SaaS的系统基盘对外公开，用Force这个名称开始进入PaaS业务。他所提供的PaaS服务里采用Java类似的语言Apex以及Eclipse开发平台，整合的开发环境也作为服务进行提供(Development as a Service)。Google/Amazon/Salesforce这三个软件巨头非常的重视PaaS这种新的商业模式，Amazon的PaaS服务为了用户可以自由的组合服务提供了更多的自由度，Google的话提供了更多的服务使用户能够方便的使用，去掉了一些繁琐的作业。Google/Salesforce的PaaS不仅是基础硬件的提供开发环境的同样被提供属于真正的平台作为一种服务(PaaS)&lt;/p&gt;

&lt;h3 id=&#34;特点&#34;&gt;特点&lt;/h3&gt;

&lt;p&gt;PaaS能将现有各种业务能力进行整合，具体可以归类为应用服务器、业务能力接入、业务引擎、业务开放平台，向下根据业务能力需要测算基础服务能力，通过IaaS提供的API调用硬件资源，向上提供业务调度中心服务，实时监控平台的各种资源，并将这些资源通过API开放给SaaS用户。PaaS主要具备以下三个特点:&lt;/p&gt;

&lt;p&gt;(1)平台即服务：PaaS所提供的服务与其他的服务最根本的区别是PaaS提供的是一个基础平台，而不是某种应用。在传统的观念中，平台是向外提供服务的基础。一般来说，平台作为应用系统部署的基础，是由应用服务提供商搭建和维护的，而PaaS颠覆了这种概念，由专门的平台服务提供商搭建和运营该基础平台，并将该平台以服务的方式提供给应用系统运营商；&lt;/p&gt;

&lt;p&gt;(2)平台及服务：PaaS运营商所需提供的服务，不仅仅是单纯的基础平台，而且包括针对该平台的技术支持服务，甚至针对该平台而进行的应用系统开发、优化等服务。PaaS的运营商最了解他们所运营的基础平台，所以由PaaS运营商所提出的对应用系统优化和改进的建议也非常重要。而在新应用系统的开发过程中，PaaS运营商的技术咨询和支持团队的介入，也是保证应用系统在以后的运营中得以长期、稳定运行的重要因素;&lt;/p&gt;

&lt;p&gt;(3)平台及服务：PaaS运营商对外提供的服务不同于其他的服务，这种服务的背后是强大而稳定的基础运营平台，以及专业的技术支持队伍。这种“平台级”服务能够保证支撑SaaS或其他软件服务提供商各种应用系统长时间、稳定的运行。PaaS的实质是将互联网的资源服务化为可编程接口，为第三方开发者提供有商业价值的资源和服务平台。有了PaaS平台的支撑，云计算[2] 的开发者就获得了大量的可编程元素，这些可编程元素有具体的业务逻辑，这就为开发带来了极大的方便，不但提高了开发效率，还节约了开发成本。有了PaaS平台的支持，WEB应用的开发变得更加敏捷，能够快速响应用户需求的开发能力，也为最终用户带来了实实在在的利益。&lt;/p&gt;

&lt;h2 id=&#34;三-开源paas平台&#34;&gt;三、开源PaaS平台&lt;/h2&gt;

&lt;p&gt;开源平台即服务（PaaS）让广大开发人员和用户可以贡献及共享源代码和扩展件。有的PaaS由厂商驱动，有的则基于标准。&lt;/p&gt;

&lt;p&gt;厂商驱动的开源PaaS让广大开发人员和用户被某家厂商牢牢锁定。说到将应用程序从厂商驱动的开源平台传送到另一个平台，开发人员在这方面的控制权很有限。&lt;/p&gt;

&lt;p&gt;基于标准的开放平台则与厂商无关，比较灵活；它旨在对生命周期管理的自动化过程的编排实现标准化。开发人员可以跨云传送应用程序。&lt;/p&gt;

&lt;p&gt;下面不妨看一下五种流行的开源平台。请注意：并非所有这些平台都与OpenStack协同运行。&lt;/p&gt;

&lt;h3 id=&#34;厂商驱动的开源paas&#34;&gt;厂商驱动的开源PaaS&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Cloud Foundry&lt;/strong&gt;（原先由VMware开发）从广大Ruby开发人员和用户处获得源代码。这个开源PaaS允许人们将信息系统部署到OpenStack、亚马逊网络服务（AWS）、vSphere、vCloud Air和vCloud Director。Cloud Foundry提供的主机托管服务包括：MySQL（可用于开发SaaS应用程序）、MongoDB（一种NoSQL数据库）和RabbitMQ（以异步方式连接应用程序的消息代理）。为了简化任务，PaaS开发人员获得诸多工具，比如命令行工具、Eclipse插件、构建整合工具以及应用程序扩展工具。与Cloud Foundry竞争的平台还有AppScale、Heroku、OpenShift和谷歌应用引擎（Google App Engine）。注意：2014年12月9日，Cloud Foundry基金会宣布，它将作为一个Linux基金会协作项目来加以管理。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;OpenShift&lt;/strong&gt;（红帽）在私有云（OpenShift Enterprise）、公有云（OpenShift Online）和上游社区（通过OpenShift Origin项目）中运行。OpenShift托管运行MySQL和MongoDB；OpenShift支持的其他数据库包括PostgreSQL和微软SQL。这个开源PaaS在红帽企业级Linux上运行，为你提供了一套客户（命令）工具集。你可以使用JavaScript、Ruby、Python、PHP、Perl和Java。OpenShift在OpenStack上运行。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Stackato&lt;/strong&gt;（ActiveState）是基于Cloud Foundry的PaaS。你可以从Stackato的应用程序商店选择开源项目，而不是贡献源代码。你可以浏览用各种语言和框架编写而成的众多开源项目。为了快速部署，你只要点击某个项目。&lt;/p&gt;

&lt;p&gt;如果你很好奇，可以查看某个项目的源代码，看看它是如何构建的。你可以决定是定制项目，还是使用自己的应用程序。&lt;/p&gt;

&lt;p&gt;Stackato有三个版本可用：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Stackato Micro Cloud&lt;/strong&gt;：假设你想把应用程序部署到桌面虚拟机上，或者在亚马逊EC2沙盒上试一试Micro Cloud。你仅限于4 GB内存、单一节点和基于社区的支持。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Stackato Cluster&lt;/strong&gt;：假设你是小型团队的负责人，想构建小型集群，把应用程序部署到自己的基础设施上或公有云上。你仅限于20 GB内存和基于社区的支持。你想要多少个节点，就可以有多少个节点。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Stackato Enterprise&lt;/strong&gt;：假设贵企业想把应用程序部署到虚拟机管理程序或基础设施即服务（IaaS）上，同时可充分利用自动扩展的优点。它提供了配置和生产支持，有服务级别协议（SLA）作为保障。&lt;/p&gt;

&lt;p&gt;你可以将Stackato与OpenStack、vSphere、CloudStack、XenServer、KVM、HP Cloud Services和AWS结合使用。&lt;/p&gt;

&lt;p&gt;2013年6月，Apache Stratos（由WSO2捐献）作为一种开源PaaS捐献给了Apache。它可以与许多应用服务器、数据库、语言、甚至遗留系统协同运行。你可以设置分区来控制IaaS资源。WSO2 App Factory可以帮助你加快PaaS上的生命周期迭代。&lt;/p&gt;

&lt;p&gt;这个平台的贡献者包括来自SUSE、思科、思杰、美国宇航局喷气推进实验室（JPL）、Sungard和Engine Yard的开发人员。你可以将Stratos与AWS、OpenStack和vCloud结合使用。、&lt;/p&gt;

&lt;h3 id=&#34;基于标准的开源paas&#34;&gt;基于标准的开源PaaS&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Cloudify&lt;/strong&gt;（GigaSpaces）基于OASIS TOSCA（云应用程序的拓扑结构和编排规范）的草案版本。这项与厂商无关的标准的技术委员会成立于2012年。标准的发起者包括冠群、华为、IBM、NetApp、红帽和SAP。&lt;/p&gt;

&lt;p&gt;这项标准并不依赖任何一家厂商的技术（比如虚拟机管理程序虚拟化）就可以运行开源PaaS；它描述应用程序的拓扑结构是工作流程的基础，工作流程反过来充当策略的基本构建模块。&lt;/p&gt;

&lt;p&gt;该标准可以处理开发人员手动执行下列任务时所犯的严重错误：&lt;/p&gt;

&lt;p&gt;设置监控警报；&lt;/p&gt;

&lt;p&gt;执行部署策略；&lt;/p&gt;

&lt;p&gt;收集并分析日志；以及对照SLA中的服务可用性保障，衡量性能。&lt;/p&gt;

&lt;p&gt;为了消除人员的干预工作，该标准旨在帮助PaaS开发人员将生命周期实现自动化，包括跨云的部署、扩展、补丁、监控和补救。构建并使用开发人员可以使用的云服务模块库，就能实现自动化。&lt;/p&gt;

&lt;p&gt;你可以使用PaaS来测试自动化和编排流程执行起来多顺畅。Cloudify可以在OpenStack、AWS、CloudStack、微软Azure和VMware上实现自动部署。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>深入CloudFoundry一周年（转载）</title>
      <link>/post/cloudfoundry/</link>
      <pubDate>Wed, 24 Jun 2015 22:05:33 +0800</pubDate>
      
      <guid>/post/cloudfoundry/</guid>
      <description>&lt;p&gt;本文转自&lt;a href=&#34;http://ju.outofmemory.cn/entry/22259&#34;&gt;深入CloudFoundry一周年（原版）&lt;/a&gt;，有些地方稍微做些修改，毕竟是几年前的文章了。&lt;/p&gt;

&lt;h2 id=&#34;篇前语&#34;&gt;篇前语&lt;/h2&gt;

&lt;p&gt;本文在《程序员》杂志2013年1月刊刊登过，但由于篇幅排版等原因，部份内容被删除。研究院博客这次发表的版本是原稿版。可能文笔措辞有些许粗糙，但希望能给大家带来更详尽的信息。&lt;/p&gt;

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;2012年4月份，VMware突然发布了业内第一个开源的PaaS，Cloud Foundry；紧接着5月，Redhat发布了另外一个开源的PaaS，OpenShift。从此PaaS不再神秘，开始成为技术圈内的热议话题。我们研究院在CloudFoundry发布时就开始投入研究，在实验室内部署了基于Cloud Foundry私有的PaaS。到了10月份，我们总结部份研究成果，整理成博客发表在研究院的轻微博上。&lt;/p&gt;

&lt;p&gt;Cloud Foundry经过一年多的发展，文章内很多内容都已经不合时宜，这篇一周年特别版的结构重新整理，文章内容部份借鉴我的同事颜开所写的《新版CloudFoundry揭秘》以及一些同行的文章、演讲进行改写；加入部份笔者在OpenStack APAC会议上所作报告《ElasticArchitecture in Cloud Foundry and Deploy with OpenStack》内容，而CloudFoundry的安装配置、扩展运行时、自定义服务等内容，本专栏会有后续专文介绍，这里就不再重复。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;正文&#34;&gt;正文&lt;/h2&gt;

&lt;h3 id=&#34;一-什么是paas&#34;&gt;一、什么是PaaS？&lt;/h3&gt;

&lt;p&gt;PaaS这个话题已经不再新鲜，但是与云计算的其他概念一样，让人感觉云里雾里的。在所有让人摸不着头脑的定义里面，笔者最喜欢下面这张EMC World 2012展示的图，它从使用角度介绍了PaaS的含义。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/iaas-paas.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;从开发者的角度来看，如果我们开发了一个应用程序，需要部署。传统的IT需要为你准备网络、存储、服务器、虚拟化、操作系统、中间件、应用运行环境等一系列设施；而如果你的企业上了IaaS，例如OpenStack，那这些IaaS套件就会帮你把网络到操作系统全包办了，你可以避免走冗长的流程去申请机器，公网IP的这些活；但是这时还没完，因为IaaS只能帮你到给你若干台装好Linux或者Windows，但是你不能按需得到运行环境，也不可以在资源不够的时候把你的应用进行横向扩展，而PaaS就接管剩下的工作，为你提供中间件和运行环境。在企业上了PaaS后，开发者只需要管理自己的应用及应用数据即可，所有设施相关的都可以包办给PaaS平台。这里可以看到三点：&lt;/p&gt;

&lt;p&gt;1、PaaS基于IaaS之上的；&lt;/p&gt;

&lt;p&gt;2、PaaS为应用开发者提供中间件及运行环境；&lt;/p&gt;

&lt;p&gt;3、PaaS管理应用的部署，扩展等生命周期。&lt;/p&gt;

&lt;p&gt;其实上面第三点很重要，如果没有第三点，IaaS也可以通过一些技巧提供中间件和运行环境。譬如我有一个Ruby on Rails的应用，需要用到Mysql，那系统管理员完全可以把Ruby环境和Mysql集成到IaaS的模板里面。但是这样的设计无法满足下面的场景：我目前应用有10个节点，由于访问压力增加，应用资源不够了，现需要动态增加为20个节点，但我提供的服务不可以接受中断。&lt;/p&gt;

&lt;p&gt;当然，一定要较真的话，结合一些DevOp的知识也可以做到，但开发这些DevOp的脚本可以认为是一个最小化的PaaS了。&lt;/p&gt;

&lt;h3 id=&#34;二-paas的基本架构&#34;&gt;二、PaaS的基本架构&lt;/h3&gt;

&lt;p&gt;为了抽象出，PaaS的架构，我们先来看看下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/cloudfoundry.png&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;/img/heroku.jpg&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;/img/openshift.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这是三个非常著名的PaaS平台的高层架构图，从上到下分别是：CloudFoundry，Heroku和OpenShift。每个个架构图，笔者都加了两条分隔线，我们可以看到它们拥有相似的三层架构：&lt;/p&gt;

&lt;p&gt;a)  Router，主要负责找到相对硬的App访问点。在Heroku中叫做Routing Mesh，在OpenShift中叫做HA Proxy；&lt;/p&gt;

&lt;p&gt;b)  App的运行容器，它必须是同构可互相替代的。在CloudFounry中叫作App Exec Engine，也就是下文所说的DEA，在Heroku中叫Dyna Grid，在OpenShift中就是上图画有”PHP”的gear；&lt;/p&gt;

&lt;p&gt;c)  系统服务节点。&lt;/p&gt;

&lt;p&gt;PaaS主要为了大规模访问而设计，所以要求每一层都支持Failover，也就是说任何一个部份都有多节点运行，任何一个节点都可以挂掉，但要求其他的同组件节点可以替代已挂节点的工作；每一个层都可以扩展，以满足大并发需求；资源非独占性，如果某一组件资源有富裕，可以回收资源供给其他组件使用。后面两点就是我们常说的弹性。后文我们将可以看到CloudFoundry是如何做到以上几点的。&lt;/p&gt;

&lt;h3 id=&#34;三-cloudfoundry的架构及模块&#34;&gt;三、CloudFoundry的架构及模块&lt;/h3&gt;

&lt;p&gt;从总体地看，CloudFoundry的架构如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/cloudfoundry2.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如果看过《深入CloudFoundry》原文，我们可以发现CloudFoundry的组件增加了很多。但是它的核心组件并没有变化，增加的组件可以认为是原架构基础上的细化和专门化。譬如Stager组件是为了解决打包（Stage）过程需要操作大量文件，操作时间长的问题。所以Stager模块作为独立进程，接受这些工作逐个运行，而不阻塞作为核心组件的CloudController。&lt;/p&gt;

&lt;p&gt;CloudFoundry的核心组件有：&lt;/p&gt;

&lt;p&gt;1、Router：顾名思义，Router组件在CloudFoundry中是对所有进来的Request进行路由。进入Router的request主要有两类：首先是来自VMC Client或者STS的，由CloudFoundry使用者发出的，管理型指令。例如：列出你所有apps的vmc apps，提交一个apps等等。这类request会被路由到App Life Management组件，又叫Cloud Controller组件去；第二类是外界对你所部署的apps访问的request。这部份requests会被路由到App execution，又或者叫做DEAs的组件去。所有进入CloudFoundry系统的requests都会经过Router组件，看到这里可能会有朋友会担心Router成为单点，从而成为整个云的瓶颈。但是CloudFoundry作为云系统，其设计的核心就是去单点依赖，组件平行扩充，且可替代的以保证扩展性，这是CloudFoundry，甚至所有云计算系统的设计原则，后文会讨论CloudFoundry如何做到这点，目前只要知道，系统可以部署多个Routers共同处理进来的requests，但是Router上层的Load Balance不在CloudFoundry的实现范围，CloudFoundry只保证所有的request是无状态的，这样就使上层均衡附载选择面非常非常大了，例如可以通过DNS做，也可以部署硬件的Load Balancer，或者简单点，弄台ngnix作负载均衡器，都是可行的。&lt;/p&gt;

&lt;p&gt;在第一个版本中，Router作为一个nginx脚本存在。所以的请求都必须经过Ruby代码，然后加以转发。这个设计干净利落，不过Ruby也因此转发了大量的数据，容易引起性能问题，所以在新版本中做了如下的改进（左边为第一版本，右边为新版）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/cloudfoundry3.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;a)  使用Nginx的Lua扩展，在Lua中加入URL查询逻辑和统计逻辑；&lt;/p&gt;

&lt;p&gt;b)  如果Lua不知道当前的URL应该对应到底下哪一个DEA，则会发一个Request到router_uls_server.rb（也就是上图的”Upstream LocatorSVC”）；&lt;/p&gt;

&lt;p&gt;c)  router_uls_server.rb是一个简单的Sinatra应用，它存储了所有URL与DEA IP:Port对应数据。另外它也管理了访问Session数据（这个后面会说）。&lt;/p&gt;

&lt;p&gt;这样一来，大量的业务请求在Lua查询过一次位置后，变成了nginx直连下属业务，而不再经过router。逻辑和数据完美分离。性能和稳定性都大幅提高了。&lt;/p&gt;

&lt;p&gt;另外一个大改进在于在前版设计中，当Router接收到请求后，会随机分配一个Droplet来处理这个请求，这种方式使得用户没有办法使用Session，因为连续的HTTP请求会被分发到不同的应用实例上处理。新版本设计中增加了对SESSION的支持，当Router发现用户的请求中带了cookie信息，它会在Cookie里暗藏一个Droplet的host, port地址。当有新的请求进来，Router通过解析Cookie得到上次的应用实例，然后尽量转发到同一台Droplet上。而这部份信息与上面的查询类似，会先存在于router_uls_server.rb，当Lua知道后会保存在Nginx内部提高效率。&lt;/p&gt;

&lt;p&gt;还有一点可以利用的是，router_uls_server.rb作为一个基于Sinatra的服务，并且知道PaaS内所有映射、会话关系，是我们二次开发一个很有用的切入点。&lt;/p&gt;

&lt;p&gt;2、DEA (Droplet ExecutionAgent): 首先要解析下什么叫做Droplet。Droplet在CloudFoundry的概念里面是指一个把你提交的源代码，以及CloudFoundry配套好的运行环境，再加上一些管理脚本，例如Start/Stop这些小脚本全部压缩好在一起的tar包。还有一个概念，叫做Staging app，就是指制作上面描述这个包，然后把它存储好的过程。CloudFoundry会自动保存这个Droplet，直到你start一个app的时候，一台部署了DEA模块的服务器会来拿一个Droplet的copy去运行。所以如果你扩展你的app到10个instances，那这个Droplet就被会复制十份，让10个DEA服务器拿去运行。&lt;/p&gt;

&lt;p&gt;下图是DEA模块的新架构图（左编为原版，右边为新版）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/cloudfoundry4.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;当CloudFoundry刚刚推出的时候， Droplet包含了应用运行时启动，停止等简单命令。用户应用可以随意访问文件系统，也可以在内网畅通无阻，跑满CPU，占尽内存，写满磁盘。你一切可以想到的破坏性操作都可以做到，太可怕了。CloudFoundry显然不会放任这样的情况太久，现在他们开发出了Warden，一个程序运行容器。这个容器提供了一个孤立的环境，Droplet只可以获得受限的CPU,内存，磁盘访问权限，网络权限，再没有办法搞破坏了。&lt;/p&gt;

&lt;p&gt;Warden在Linux上的实现是将Linux 内核的资源分成若干个namespace加以区分，底层的机制是CGROUP。这样的设计比虚拟机性能好，启动快，也能够获得足够的安全性。在网络方面，每一个Warden实例有一个虚拟网络接口，每个接口有一个IP，而DEA内有一个子网，这些网络接口就连在这个子网上。安全可以通过iptables来保证。在磁盘方面，每个warden实例有一个自己的filesystem。这些filesystem使用aufs实现的。Aufs可以共享warden之间的只读内容，区分只写的内容，提高了磁盘空间的利用率。因为aufs只能在固定大小的文件上读写，所以磁盘也没有出现写满的可能性。&lt;/p&gt;

&lt;p&gt;LXC是另一个LinuxContainer。那为什么不使用它，而开发了Warden呢。因为LXC的实现是和Linux绑死的，CloudFoundry希望warden能运转在各个不同的平台，而不只是Linux。另外Warden提供了一个Daemon和若干Api来操作，LXC提供的是系统工具。还有最重要的一点是LXC过于庞大，Warden只需要其中的一点点功能就可以了，更少的代码便于调试。&lt;/p&gt;

&lt;p&gt;除了增加隔绝性外，DEA的基本运行原理并没有发生根本改变：Cloud Controller模块（下面会介绍）会发送start/stop等基本的apps管理请求给DEA，dea.rb接收这些请求，然后从NFS里面找到合适的Droplet。前面说到Droplet其实是一个带有运行脚本的，带运行环境的tar包，DEA只需要把它拿过来解压，并即行里面的start脚本，就可以让这个app跑起来。到此，app算是可以访问，并start起来了，换句话说就是有这台服务器的某一个端口已经在待命，只要有request从这个端口进来，这个app就可以接收并返回正确的信息。接着dea.rb要做些善后的工作：1、把这个信息告诉Router模块。我们前面说到，所有进入CloudFoundry的requests都是由Router模块处理并转发的，包括用户对app的访问request，一个app起来后，需要告诉router，让它根据load balance等原则，把合适的request转进来，使这个app的instance能够干起活；2、一些统计性的工作，例如要把这个用户又新部署了一个app告诉Cloud Controller，以作quota控制等；3、把运行信息告诉Health Manager模块，实时报告该app的instance运行情况。另外DEA还要负责部份对Droplet的查询工作，譬如，如果用户通过Cloud Controller想查询一个app的log信息，那DEA需要从该Droplet里面取到log返回等等。&lt;/p&gt;

&lt;p&gt;3、CloudController:  Cloud Controller是CloudFoundry的管理模块。主要工作包括：&lt;/p&gt;

&lt;p&gt;a)  对apps的增删改读；&lt;/p&gt;

&lt;p&gt;b)  启动、停止应用程序（通过DEA）；&lt;/p&gt;

&lt;p&gt;c)  Stagingapps（把apps打包成一个droplet，通过Stager）；&lt;/p&gt;

&lt;p&gt;d)  修改应用程序运行环境，包括instance、mem等等；&lt;/p&gt;

&lt;p&gt;e)  管理service，包括service与app的绑定等；&lt;/p&gt;

&lt;p&gt;f)  Cloud环境的管理；&lt;/p&gt;

&lt;p&gt;g)  修改Cloud的用户信息（通过UAA，ACM）；&lt;/p&gt;

&lt;p&gt;h)  查看CloudFoundry，以及每一个app的log信息。&lt;/p&gt;

&lt;p&gt;这似乎有点复杂，但简单的说，可以很简单：就是与VMC和STS交互的服务器端。VMC和STS与CloudFoundry通信采用的是restful接口，另一方面Cloud Controller是一个典型的Ruby on Rails项目，从VMC或者STS接到JSON格式的协议，然后写入Cloud ControllerDatabase，并发消息到各模快去控制管理整个云。&lt;/p&gt;

&lt;p&gt;我们以部署一个App到CloudFoundry为例，在我们在敲完那条简单的push命令后，VMC开始工作，在做完一轮的用户鉴权、查看所部署的apps数量是否超过预定数额，问了一堆相关app的问题后，需要发4个指令：&lt;/p&gt;

&lt;p&gt;a)  发一个POST到“apps”，创建一个app;&lt;/p&gt;

&lt;p&gt;b)  发一个PUT到“apps/:name/application”，上传app;&lt;/p&gt;

&lt;p&gt;c)  发一个GET到“apps/:name/”，取得app状态，看看是否已经启动；&lt;/p&gt;

&lt;p&gt;d)  如果没有启动，发一个PUT到“apps/:name/”，使其启动。&lt;/p&gt;

&lt;p&gt;第一版的CloudController是基于Ruby On Rails的，在新版中，为了与CloudFoundry其他模块一致，并且让架构更加简单，CloudController用Sinatra进行了重写，并且加入了更多的模块去细化CloudController的工作。&lt;/p&gt;

&lt;p&gt;另外一个重要的改进是，第一个版本的Droplet是通过NFS共享的，但这样会带来安全、性能等问题，而新版中进行了两大改进：&lt;/p&gt;

&lt;p&gt;a)  移除NFS，采用自己开发的，简单的blobstore来存放Droplet;&lt;/p&gt;

&lt;p&gt;b)  为Ruby项目进行了优化，把常用的Gem保存在package cache里面。所以在打包Ruby项目的时候不需要到公网上下载Gem文件，而是从CloudFoundry内部的Cache获得，大大加速了Stage过程。&lt;/p&gt;

&lt;p&gt;随着CloudFoundry的逐渐成熟，权限管理功能在新的版本进行了很大的加强，在原有的用户模型基础上，加入了组织、用户空间的概念。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/cloudfoundry5.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;用户模型的认证是由UAA模块实现的，它可以与企业已有的认证系统进行整合，例如LDAP，CAS等；鉴权是由ACM模块实现的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/cloudfoundry6.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;上图示例了一个用户访问CloudController的API的过程。我们可以分别看到UAA与ACM模块在一套鉴权流程各自扮演的角色。&lt;/p&gt;

&lt;p&gt;UAA与ACM需要展开的内容很多，碍于篇幅原因，这里就不展开介绍了，有兴趣的朋友可以参考：&lt;a href=&#34;/img/https://github.com/cloudfoundry/uaa/tree/master/docs&#34;&gt;UAA&lt;/a&gt;可能研究院后续会有专门的博客介绍相关技术。&lt;/p&gt;

&lt;p&gt;4、Health Manager: 做的事情不复杂，简单的说是从各个DEA里面拿到运行信息，然后进行统计分析，报告等。统计数据会与CloudController的设定指标进行比对，并提供Alert等。Health Manager模块目前还不是十分完善，但是Cloud Manage栈里面，自动化health管理、分析是一个很重要的领域，而这方面可以扩展的地方也很多，结合Orchestration Engine可以使云自管理、自预警；而与BI方面技术结合，可以统计运营情况，合理分配资源等。这方面CloudFoundry还在发展之中。&lt;/p&gt;

&lt;p&gt;5、Services: 服务从上文的PaaS三层模型来看属于第三层，Cloud Foundry把Service模块设计成一个独立的、插件式的模块，第三方可以方便把自己的服务整合成Cloud Foundry服务。在Github上与服务相关，主要关注两个子项目：&lt;/p&gt;

&lt;p&gt;a) vcap-services-base：顾名思义，包括Cloud Foundry服务的框架及核心类库。如果开发自定义的服务，我们需要引用到里面的类；&lt;/p&gt;

&lt;p&gt;b) vcap-services：目前Cloud Foundry支持的，包括官方及大部份第三方贡献的服务。这个项目的根文件目录是以服务名称分的，我们可以选择感兴趣的去分别研究。&lt;/p&gt;

&lt;p&gt;由此可见，Service模块的设计十分方便第三方提供自定义服务。从架构来说， Cloud Foundry服务部份使用了模板方法设计模式，我们通过重写钩子方法来实现自己的服务，如果不需要特别逻辑可以使用默认方法。从客户输入VMC命令开始，一个完整的服务访问流程如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/cloudfoundry7.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;a)  开发人员通过VMC创建一个Service;&lt;/p&gt;

&lt;p&gt;b)  VMC把其转为Restful接口到CloudController；&lt;/p&gt;

&lt;p&gt;c)  CloudController通过Restful接口发送创建命令到Service Gateway；&lt;/p&gt;

&lt;p&gt;d)  ServiceGateway通过NAT（下文会提到）发送provision命令道Service Node；&lt;/p&gt;

&lt;p&gt;e)  ServiceNode创建Service；&lt;/p&gt;

&lt;p&gt;f)  Service Node把返回创建的Service访问方法回Service Gateway；&lt;/p&gt;

&lt;p&gt;g)  ServiceGateway返回访问方法到CloudController；&lt;/p&gt;

&lt;p&gt;h)  CloudController把创建的Service访问放法注入到应用运行环境；&lt;/p&gt;

&lt;p&gt;i)  最终用户可以直接访问其服务。&lt;/p&gt;

&lt;p&gt;现实情况中，种种原因使有些系统服务难以，或者不愿意迁移到云端，为此Cloud Foundry 引入了Service Broker模块。&lt;/p&gt;

&lt;p&gt;Service Broker可以使部署在Cloud Foundry上的应用可以访问本地的服务。ServiceBroker的使用方法如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/cloudfoundry8.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;a)  我们必须准备好系统,例如postgress。我们配置好程序和防火墙，让CloudFoundry能通过类似postgres://xyzhr:secret@db.xyzcorp.com:5432/xyz_hr_db 的URL来访问到服务。&lt;/p&gt;

&lt;p&gt;b)  调用create service，系统会在ServiceBroker中记录你的配置信息。这样就算大功告成了。Bind和其他的过程都有ServiceBroker完成，其实仅仅就是记录信息，没有实际操作。使用这个新的Service的时候和使用CloudFoundry的内部Service没有两样，配置参数都会通过环境变量传入。所以当App访问Service的时候，就与ServiceBroker无关了。&lt;/p&gt;

&lt;p&gt;对应上面的Service流程，Service Broker的访问流程如下，这里就不重复叙述了：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/cloudfoundry9.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;6、NATS (Message bus)：&lt;/p&gt;

&lt;p&gt;CloudFoundry的架构是基于消息发布与订阅的，联系各模块的是一个叫nats的组件。NATS是由CloudFoundry的架构师Derek开发的一个基于事件驱动的轻量级支持发布、订阅机制的消息系统。它基于EventMachine开发，以事件驱动。第一版本CloudFoundry被人诟病的一个问题就是NATS服务器是单节点，性能方面从实际应用情况看，是让人满意的；但HA方面的问题难以避免，成为整套系统HA的软肋。但新版NATS终于支持多服务器节点，NATS服务器间通过THIN来做通信。NATS的Github开源地址是：&lt;a href=&#34;https://github.com/derekcollison/nats&#34;&gt;NATS&lt;/a&gt;。代码量不多但设计很精妙，推荐下载来慢慢研究。&lt;/p&gt;

&lt;p&gt;CloudFoundry作为一个弹性设计的，多模块的分布式系统，且支持模块自发现，错误自检，保证模块间低耦合。其根本原理就是基于消息发布订阅机制构建。每台服务器上的每个模块会根据自己的消息类别，向Message Bus发布多个消息主题；而同时也向自己需要交互的模块，按照需要的信息内容的消息主题订阅消息。&lt;/p&gt;

&lt;p&gt;如前所说，CloudFoundry的核心是一套消息系统，如果想了解CloudFoundry的来龙去脉，去跟踪它里面复杂的消息机制是非常好的方法。譬如：一个DEA被加入CloudFoundry集群中，它需要向大家吼一下，以表明它已经准备好服务了，它会发布一个主题是”dea.start”的消息：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;NATS.publish(&#39;dea.start&#39;,@hello_message_json)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;@ hello_message_json中包括DEA的UUID, ip, port, 版本信息等内容。&lt;/p&gt;

&lt;p&gt;再例如，Cloud Controller需要启动一个Droplet的instance：&lt;/p&gt;

&lt;p&gt;a)  首先一个DEA在启动的时候，会首先会对自己UUID的消息主题进行订阅。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;NATS.subscribe(&amp;quot;dea.#{uuid}.start&amp;quot;){ |msg| process_dea_start(msg) }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其他模块需要通过&amp;rdquo;dea.#{uuid}.start&amp;rdquo;这个主题发送消息来使它启动，一旦这个DEA接收到消息，就会触发process_dea_start(msg)这个方法来处理启动所需要的工作；&lt;/p&gt;

&lt;p&gt;b)  Cloud Controller或者其他模块发送消息，让UUID为xxx的DEA启动。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;NATS.publish(&amp;quot;dea.#{dea_id}.start&amp;quot;,json)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;c)  DEA模块接收到消息后，就会触发process_dea_start(msg)方法。msg是由其他模块发送过来的消息内容，包括：droplet_id, instance_index, service, runtime等内容，process_dea_start会取得这些启动DEA必须的信息，然后进行一系列操作，例如从NFS中取得Droplet，解压，修改必要环境配置，运行启动脚本等等。等一切都准备好后，然后需要给Router发个消息，告诉它这个Droplet已经随时准备好报效国家，以后有相应的request记得让它来处理。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;NATS.publish(&#39;router.register&#39;,{

:dea =&amp;gt; VCAP::Component.uuid,

:host =&amp;gt; @local_ip,

:port =&amp;gt; instance[:port],

:uris =&amp;gt; options[:uris] ||instance[:uris],

:tags =&amp;gt; {:framework =&amp;gt;instance[:framework], :runtime =&amp;gt; instance[:runtime]}

                        }.to_json)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;d)  Router模块在启动时就已经订阅”router.register”消息主题，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;NATS.subscribe(&#39;router.register&#39;){ |msg|

msg_hash = Yajl::Parser.parse(msg,:symbolize_keys =&amp;gt; true)

return unless uris = msg_hash[:uris]

uris.each{|uri|register_droplet(uri,msg_hash[:host],msg_hash[:port],msg_hash[:tag 

s]) }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;收到前面DEA发出的信息后，会触发register_droplet方法，去绑定Droplet。到此启动一个Droplet的instance工作完成。&lt;/p&gt;

&lt;p&gt;CloudFoundry的架构简单介绍至此，其实作为第一款开源的PaaS，CloudFoundry架构有很多可以学习借鉴的地方，很多细节上的处理是很精妙的，本文题虽为深入CloudFoundry，其实也只是浅尝即止，如果真要做到深入恐怕上面提到的每个模块都需要立篇详谈。一年后的今天重新审视CloudFoundry的学习资料，已经很丰富，网上有很多牛人已经写了很多东西探讨CloudFoundry的架构，文章最后笔者会给大家推荐个人觉得比较好的一些中文资料。总结一下，笔者从CloudFoundry的结构中学到的东西：&lt;/p&gt;

&lt;p&gt;1、基于消息的多组件架构是实现集群的简单、且有效方法。消息可以使集群节点间解耦，使自注册，自发现这些在大规模数据中心中很重要的功能得到实现；&lt;/p&gt;

&lt;p&gt;2、适当的抽象层，模板模式的使用，方便第三方可以方便在CloudFoundry开发扩展功能。CloudFoundry在DEA及Service层都做了抽象层处理，相对应地使开发者可以容易地为CloudFoundry开发Runtime和Service。例如，在CloudFoundry刚推出的时候，只支持Node.js, Java, Ruby，但第三方提供商、开源社区快速跟进，为CloudFoundry添加了PHP, Python的支持。这得益于CloudFoundry精巧的DEA架构设计。&lt;/p&gt;

&lt;h3 id=&#34;四-安装配置cloudfoundry&#34;&gt;四、安装配置CloudFoundry&lt;/h3&gt;

&lt;p&gt;写《深入CloudFoundry》的时间比较早，那时候连dev_setup都没有，更不用说更为先进的、适合大规模部署CloudFoundry使用的BOSH。原文介绍的是如何通过理解CloudFoundry各模块的关系，通过手工配置安装CloudFoundry的，笔者认为那依然是让我们理解CloudFoundry工作原理的最好方法，而且过程很有乐趣，就如我们在习惯了使用自动相机“咔嚓”一下的时候，如果有机会把玩一些老相机，躲进暗房尝试自己冲洗银盐底片，那种感受是难以言表的。&lt;/p&gt;

&lt;p&gt;CloudFoundry是一个PaaS，前面讨论到PaaS是基于IaaS之上的，上面CloudFoundry的部署指南是以vSphere作为IaaS。但是无论是CloudFoundry本身，还是部署工具BOSH的设计都是以IaaS不相关的。正如一年前那篇《深入CloudFoundry》所说，我们可以用OpenStack作为CloudFoundry的PaaS层。而CloudFoundry后来出现的部署系统BOSH也和我们想得不谋而合，它对IaaS层做了一层抽象，叫做CPI（Cloud Provider Interface）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/cloudfoundry10.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;而CPI里面就有专门为OpenStack准备的，叫做Piston，开源地址在：&lt;a href=&#34;https://github.com/piston/openstack-bosh-cpi&#34;&gt;Piston&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;如果从整体角度去理解BOSH ，其实可以发现这里面很简单。我们需要部署CloudFoundry，BOSH要做几件事情？&lt;/p&gt;

&lt;p&gt;a)  向IaaS要一台虚拟机，导入image文件；&lt;/p&gt;

&lt;p&gt;b)  向IaaS要存储空间，并attach到虚拟机上；&lt;/p&gt;

&lt;p&gt;c)  配置这台虚拟机的网络，使它可以和其他CloudFoundry服务器相通；&lt;/p&gt;

&lt;p&gt;d)  在这台虚拟机里面下载安装CloudFoundry的代码；&lt;/p&gt;

&lt;p&gt;e)  配置CloudFoundry组件间的消息机制。&lt;/p&gt;

&lt;p&gt;这里与IaaS相关的，就是a), b), c)三点，如果我们回到第一章什么是PaaS那张图来看，提供网络、存储、服务器，以及image中带有的OS就是IaaS所给我们提供的内容。而如果看过《深入CloudFoundry》原文说过，由于由于CloudFoundry是完全模块化设计的，基于消息机制的分布式系统，所以安装配置CloudFoundry就是把每个模块单独跑起来，然后配置其消息机制，也就是上面的d),e)两点。&lt;/p&gt;

&lt;p&gt;我们回到BOSH，显而易见，CPI作为IaaS的facade，需要提供相对应的接口。任何一个IaaS，只需要实现以下接口即可以支持BOSH，并用来部署CloudFoundry：&lt;/p&gt;

&lt;p&gt;a)  create_stemcell&lt;/p&gt;

&lt;p&gt;b)  delete_stemcell&lt;/p&gt;

&lt;p&gt;c)  create_vm&lt;/p&gt;

&lt;p&gt;d)  delete_vm&lt;/p&gt;

&lt;p&gt;e)  reboot_vm&lt;/p&gt;

&lt;p&gt;f)  configure_network&lt;/p&gt;

&lt;p&gt;g)  create_disk&lt;/p&gt;

&lt;p&gt;h)  delete_disk&lt;/p&gt;

&lt;p&gt;i)  attach_disk&lt;/p&gt;

&lt;p&gt;j)  detach_disk&lt;/p&gt;

&lt;p&gt;stemcell可以认为是我们常说的image，或者说是模板，。根据函数名，我们基本能知道每个接口的作用了吧？我们可以看到是和我们上面说的a), b), c)相对应的。&lt;/p&gt;

&lt;p&gt;不少公司，都已经搭了自己的虚拟化平台，如这次笔者参加QCon，国内某著名电子商务公司内部就用LXC构建了一套虚拟化平台。如果他们再写个接口，暴露出上面10个接口，同样可以用来部署CloudFoundry。&lt;/p&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;开篇的时候，笔者原本只想对原文进行适当的修改，没想到一年过去了，CloudFoundry发生了太多改变，全文基本都已经重写，可见这一年来CloudFoundry社区的活跃。这篇文章属于新旧参半，如篇前所述，更多的是希望能把CloudFoundry的原理讲明白，讲得简单，请不要把本文作为参考手册使用。&lt;/p&gt;

&lt;p&gt;其实一年多来，CloudFoundry在国内已经很火，下面推荐一些自己觉得好，在写本文时参考过的资料：&lt;/p&gt;

&lt;p&gt;1、&lt;a href=&#34;http://cndocs.cloudfoundry.com/getting-started.html&#34;&gt;CloudFoundry中文技术文档&lt;/a&gt; （该网站好像已经打不开了）。现在CloudFoundry的文档化做得相当不错，尤其是部署云平台部份，本文多次引用提及；&lt;/p&gt;

&lt;p&gt;2、@柳烟堆雪 的&lt;a href=&#34;http://blog.csdn.net/resouer/article/details/8065795&#34;&gt;《以NATS为主线的CloudFoundry原理》&lt;/a&gt;。很好的一篇文章，可惜他发表时，本文已经写完，否则本文一定会有汲取不少养分；&lt;/p&gt;

&lt;p&gt;3、&lt;a href=&#34;http://www.54chen.com/?s=cloud+foundry&#34;&gt;著名博客五四科学院的CloudFoundry代码解读系列&lt;/a&gt;；&lt;/p&gt;

&lt;p&gt;4、EMC中国研究院研究员颜开的&lt;a href=&#34;http://www.chinacloud.cn/show.aspx?id=9966&amp;amp;cid=11&#34;&gt;《新版CloudFoundry揭秘》&lt;/a&gt;。因为是同事，本文大段大段地拷他的这篇文章；&lt;/p&gt;

&lt;p&gt;5、Cloudfoundry.org博客。另外要推荐的是Cloudfoundry.org的博客，我们知道Cloudfoundry的博客分.COM上的与.ORG上的，.COM上的大多是偏商业及应用，而.ORG的博客才是个牛人的园地；&lt;/p&gt;

&lt;p&gt;代码还是代码。不用多说，作为一个开源项目，有什么比代码更直观？！&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Paste deployment(转)</title>
      <link>/post/paste-deploy/</link>
      <pubDate>Sat, 09 Aug 2014 19:16:16 +0800</pubDate>
      
      <guid>/post/paste-deploy/</guid>
      <description>&lt;p&gt;转载自&lt;a href=&#34;http://blog.csdn.net/ztejiagn/article/details/8722765&#34;&gt;Python.Paste指南之Deploy&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Paste.Deploy主要是用来载入WSGI中的Web App应用，其核心函数是loadapp(),下文中PD就指代Paste.Deploy。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;简介及安装&#34;&gt;简介及安装&lt;/h2&gt;

&lt;p&gt;Paste Deployment是一种机制，通过loadapp函数和一个配置文件或者egg包来载入WSGI应用。可以通过Pip或者easy_install安装。&lt;/p&gt;

&lt;h2 id=&#34;配置文件config-flie&#34;&gt;配置文件Config Flie&lt;/h2&gt;

&lt;p&gt;一个配置文件后缀为ini，内容被分为很多段（section），PD只关心带有前缀的段，比如[app:main]或者[filter:errors]，总的来说，一个section的标识就是[type:name],不是这种类型的section将会被忽略。&lt;br/&gt;
一个section的内容是以键=值来标示的。#是一个注释。在段的定义中，有以下几类：&lt;br/&gt;
[app:main]:定义WSGI应用，main表示只有一个应用，有多个应用的话main改为应用名字&lt;br/&gt;
[server:main]:定义WSGI的一个server。&lt;br/&gt;
[composite:xxx]：表示需要将一个请求调度定向（dispatched）到多个,或者多种应用上。以下是一个简单的例子，例子中，使用了composite，通过urlmap来实现载入多应用。&lt;br/&gt;
[fliter:]：定义“过滤器”，将应用进行进一步的封装。&lt;br/&gt;
[DEFAULT]：定义一些默认变量的值。&lt;/p&gt;

&lt;p&gt;以下是一个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[composite:main]
use = egg:Paste#urlmap
/ = home
/blog = blog
/wiki = wiki
/cms = config:cms.ini

[app:home]
use = egg:Paste#static
document_root = %(here)s/htdocs

[filter-app:blog]
use = egg:Authentication#auth
next = blogapp
roles = admin
htpasswd = /home/me/users.htpasswd

[app:blogapp]
use = egg:BlogApp
database = sqlite:/home/me/blog.db

[app:wiki]
use = call:mywiki.main:application
database = sqlite:/home/me/wiki.db
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面会进行分段的讲解&lt;/p&gt;

&lt;h3 id=&#34;composite&#34;&gt;composite&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[composite:main]
use = egg:Paste#urlmap
/ = home
/blog = blog
/wiki = wiki
/cms = config:cms.ini
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是一个composite段，表示这将会根据一些条件将web请求调度到不同的应用。use = egg:Paste#urlmap表示我们奖使用Pasteegg包中urlmap来实现composite，这一个段(urlmap)可以算是一个通用的composite程序了。根据web请求的path的前缀进行一个到应用的映射(map)。这些被映射的程序就包括blog,home,wiki,config:cms.ini（映射到了另外一个配置文件，PD再根据这个文件进行载入）&lt;/p&gt;

&lt;h3 id=&#34;app-type1&#34;&gt;App type1&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[app:home]
use = egg:Paste#static
document_root = %(here)s/htdocs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;app是一个callable object，接受的参数(environ,start_response)，这是paste系统交给application的，符合WSGI规范的参数. app需要完成的任务是响应envrion中的请求，准备好响应头和消息体，然后交给start_response处理，并返回响应消息体。egg:Paste#static也是Paste包中的一个简单程序，它只处理静态文件。它需要一个配置文件document_root,后面的值可以是一个变量,形式为%（var）s相应的值应该在[DEFAULT]字段指明以便Paste读取。比如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[app:test]
use = egg:Paste#static
document_root = %(path)s/htdocs
[DEFAULT]
path = /etc/test
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;fliter&#34;&gt;fliter&lt;/h3&gt;

&lt;p&gt;filter是一个callable object，其唯一参数是(app)，这是WSGI的application对象，filter需要完成的工作是将application包装成另一个application（“过滤”），并返回这个包装后的application。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[filter-app:blog]
use = egg:Authentication#auth
next = blogapp
roles = admin
htpasswd = /home/me/users.htpasswd

[app:blogapp]
use = egg:BlogApp
database = sqlite:/home/me/blog.db
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;[filter-app:blog]fliter-app字段表明你希望对某个应用进行包装，需要包装的应用通过next指明（表明在下一个段中），这个字段的意思就是，在正式调用blogapp之前，我会调用egg:Authentication#auth进行一个用户的验证，随后才会调用blogapp进行处理。后面的[app:blogapp]则是定义了blogapp，并指明了需要的database参数。&lt;/p&gt;

&lt;h3 id=&#34;app-type2&#34;&gt;App type2&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[app:wiki]
use = call:mywiki.main:application
database = sqlite:/home/me/wiki.db
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个段和之前的app段定义类似，不同的是对于wiki这个应用，我们没有使用egg包，而是直接对mywiki.main这个模块中的application对象使用了call方法。python，中一切皆对象，作为WSGI app的可以是一个函数，一个类，或者一个实例，使用call的话，相应的函数，类，实例中必须实现call()方法。此类app的格式用冒号分割: call(表示使用call方法):模块的完成路径名字:应用变量的完整名字&lt;/p&gt;

&lt;h2 id=&#34;基本使用&#34;&gt;基本使用&lt;/h2&gt;

&lt;p&gt;PD的主要使用就是通过读取配置文件载入WSGI应用。如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from paste.deploy import loadapp
wsgi_app = loadapp(&#39;config:/path/to/config.ini&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意，这里需要指明绝对路径。&lt;/p&gt;

&lt;h2 id=&#34;更多关于配置文件&#34;&gt;更多关于配置文件&lt;/h2&gt;

&lt;h3 id=&#34;app&#34;&gt;App&lt;/h3&gt;

&lt;p&gt;单个配置文件中可以定义多个应用个，每个应用有自己独立的段。应用的定义以[app:name]的格式，[app:main]表示只有一个应用。应用的定义支持以下五种格式：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[app:myapp]
use = config:another_config_file.ini#app_name
#使用另外一个配置文件

[app:myotherapp]
use = egg:MyApp
#使用egg包中的内容

[app:mythirdapp]
use = call:my.project:myapplication
#使用模块中的callable对象

[app:mylastapp]
use = myotherapp
#使用另外一个section

[app:myfacapp]
paste.app_factory = myapp.modulename:app_factory
#使用工厂函数
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中，最后一种方式，将一个app指向了某些python代码。此模式下，必须执行app协议，以app_factory表示，后面的值需要import的东西，在这个例子中myapp.modulename被载入，并从其中取得了app_factory的实例。&lt;br/&gt;
app_factory是一个callable object，其接受的参数是一些关于application的配置信息：(global_conf,**kwargs)，global_conf是在ini文件中default section中定义的一系列key-value对，而**kwargs，即一些本地配置，是在ini文件中，app:xxx section中定义的一系列key-value对。app_factory返回值是一个application对象&lt;br/&gt;
在app的配置中，use参数以后配置就算结束了。其余的键值参数将会作为参数，传递到factory中，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[app:blog]
use = egg:MyBlog
database = mysql://localhost/blogdb #这是参数
blogname = This Is My Blog! #这是参数
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;全局配置&#34;&gt;全局配置&lt;/h3&gt;

&lt;p&gt;全局配置主要是用于多个应用共用一些变量，这些变量我们规定放在段[DEFAULT]中，如果需要覆盖，可以在自己的app中重新定义，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[DEFAULT]
admin_email = webmaster@example.com
[app:main]
use = ...
set admin_email = bob@example.com
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;composite-app&#34;&gt;composite app&lt;/h3&gt;

&lt;p&gt;composite是一个运行着像是app，但是实际上是由多个应用组成的。urlmap就是composite app的一个例子，url不同的path对应了不同的应用。如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[composite:main]
use = egg:Paste#urlmap
/ = mainapp
/files = staticapp

[app:mainapp]
use = egg:MyApp

[app:staticapp]
use = egg:Paste#static
document_root = /path/to/docroot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在loadapp函数的执行中，composite app被实例化，它同时还会访问配置文件中定义的其他应用。&lt;/p&gt;

&lt;h3 id=&#34;app定义高级用法&#34;&gt;app定义高级用法&lt;/h3&gt;

&lt;p&gt;在app段中，你可以定义fliters和servers，通过fliter:和server: PD通过loadserver和loadfilter函数进行调用，工作机制都一样，返回不同的对象。&lt;/p&gt;

&lt;h3 id=&#34;filter-composition&#34;&gt;filter composition&lt;/h3&gt;

&lt;p&gt;应用filter的方式很多，重要的是看你filter的数量和组织形式。下面会一一介绍应用fliter的几种方式：&lt;/p&gt;

&lt;h4 id=&#34;使用filter-with&#34;&gt;使用filter-with&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[app:main]
use = egg:MyEgg
filter-with = printdebug

[filter:printdebug]
use = egg:Paste#printdebug
# and you could have another filter-with here, and so on...
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;使用fliter-app&#34;&gt;使用fliter-app&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[fliter-app:printdebug]
use = egg:Paste
next = main

[app:main]
use = egg:MyEgg
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;使用pipeline&#34;&gt;使用pipeline&lt;/h4&gt;

&lt;p&gt;当使用多个filter的时候需要使用pipeline的方式，它需要提供一个key参数pipeline,后面的值是一个列表，最后以应用结尾。如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[pipeline:main]
pipeline = filter1 egg:FilterEgg#filter2 filter3 app

[filter:filter1]
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;假设在ini文件中, 某条pipeline的顺序是filter1, filter2, filter3，app, 那么，最终运行的app_real是这样组织的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;app_real = filter1(filter2(filter3(app)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在app真正被调用的过程中，filter1.__call__(environ,start_response)被首先调用，若某种检查未通过，filter1做出反应；否则交给filter2.__call__(environ,start_response)进一步处理，若某种检查未通过，filter2做出反应，中断链条，否则交给filter3.__call__(environ,start_response)处理，若filter3的某种检查都通过了，最后交给app.__call__(environ,start_response)进行处理。&lt;/p&gt;

&lt;h4 id=&#34;读取配置文件&#34;&gt;读取配置文件&lt;/h4&gt;

&lt;p&gt;如果希望在不创建应用的情况下得到配置文件，可以使用appconfig(uri)函数，将会以字典形式返回使用的配置。这个字典包括了全局很本地的配置信息，所以可以通过属性方法获得相应的attributes （.local_conf and .global_conf）&lt;/p&gt;

&lt;h2 id=&#34;其他&#34;&gt;其他&lt;/h2&gt;

&lt;h3 id=&#34;如何引用egg包&#34;&gt;如何引用Egg包&lt;/h3&gt;

&lt;p&gt;egg是python的一个包，pip easy_install等都是安装egg包的方式。关注egg包要注意： +某一egg包是有标准说明的&lt;br/&gt;
python setup.py name +有entry point，不用太在意，这个只是说明调用程序的参数。&lt;/p&gt;

&lt;h3 id=&#34;定义factory函数&#34;&gt;定义factory函数&lt;/h3&gt;

&lt;p&gt;工厂函数的定义还是遵循之前提到的应用的协议。目前，用于工厂函数的协议有以下：&lt;br/&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;paste.app_factory&lt;/li&gt;
&lt;li&gt;paste.composite_factory&lt;/li&gt;
&lt;li&gt;paste.filter_factory&lt;/li&gt;
&lt;li&gt;paste.server_factory&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所有的这些都希望有一个含有__call__方法的（函数，方法，类）。&lt;/p&gt;

&lt;h4 id=&#34;paste-app-factory&#34;&gt;paste.app_factory&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def app_factory(global_config, **local_conf):
    return wsgi_app
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;global_config是一个字典，而local_conf则是关键字参数。返回一个wsgi_app（含有call方法。）&lt;/p&gt;

&lt;h4 id=&#34;paste-composite-factory&#34;&gt;paste.composite_factory&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def composite_factory(loader, global_config, **local_conf):
   return wsgi_app
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;loader是一个对象，有几个有趣的方法,get_app(name_or_uri, global_conf=None)根据name返回一个wsgi应用，get_filter（）和get_server（）也是一样。看一个更加复杂的例子，举例一个pipeline应用：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def pipeline_factory(loader, global_config, pipeline):
    # space-separated list of filter and app names:
    pipeline = pipeline.split()
    filters = [loader.get_filter(n) for n in pipeline[:-1]]
    app = loader.get_app(pipeline[-1])
    filters.reverse() # apply in reverse order!
    for filter in filters:
      app = filter(app)
    return app
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;相应的配置文件如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[composite:main]
use = &amp;lt;pipeline_factory_uri&amp;gt;
pipeline = egg:Paste#printdebug session myapp

[filter:session]
use = egg:Paste#session
store = memory

[app:myapp]
use = egg:MyApp
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;paste-filter-factory&#34;&gt;paste.filter_factory&lt;/h4&gt;

&lt;p&gt;fliter的工厂函数和app的共产函数类似，除了它返回的是一个filter,fliter是一个仅仅把一个wsgi应用作为唯一参数的callable对象，返回一个被filter了的应用。 以下是一个例子，这个filter会检查CGI中REMOTE_USER变量是否存在，并创建一个简单的认证过滤器。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def auth_filter_factory(global_conf, req_usernames):
    # space-separated list of usernames:
    req_usernames = req_usernames.split()
    def filter(app):
        return AuthFilter(app, req_usernames)
    return filter

class AuthFilter(object):
    def __init__(self, app, req_usernames):
        self.app = app
        self.req_usernames = req_usernames

def __call__(self, environ, start_response):
    if environ.get(&#39;REMOTE_USER&#39;) in self.req_usernames:
            return self.app(environ, start_response)
    start_response(
            &#39;403 Forbidden&#39;, [(&#39;Content-type&#39;, &#39;text/html&#39;)])
    return [&#39;You are forbidden to view this resource&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;paste-filter-app-factory&#34;&gt;paste.filter_app_factory&lt;/h4&gt;

&lt;p&gt;和paste.filter_factory类似，接受一个wsgi应用参数，返回一个WSGI应用，所以如果改变以上代码的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class AuthFilter(object):
    def __init__(self, app, global_conf, req_usernames):
        ....
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么，类 AuthFilter就会作为一个filter_app_factory函数使用。&lt;/p&gt;

&lt;h4 id=&#34;paste-server-factory&#34;&gt;paste.server_factory&lt;/h4&gt;

&lt;p&gt;与以上不同的是，函数返回的是一个server,一个server也是一个callable对象，以一个WSGI应用作为参数，而后为这个应用服务。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def server_factory(global_conf, host, port):
    port = int(port)
    def serve(app):
        s = Server(app, host=host, port=port)
        s.serve_forever()
    return serve
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Server的实现用户可以自定义，可以参考python包wsgiref&lt;/p&gt;

&lt;h4 id=&#34;paste-server-runner&#34;&gt;paste.server_runner&lt;/h4&gt;

&lt;p&gt;与 paste.server_factory类似，不同的是参数格式。&lt;/p&gt;

&lt;h2 id=&#34;代码实践&#34;&gt;代码实践&lt;/h2&gt;

&lt;h3 id=&#34;配置文件&#34;&gt;配置文件&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[DEFAULT]
company = UESTC
school = Commuication and Information

[composite:common]
use = egg:Paste#urlmap
/ = showversion
/detail = showdetail

[pipeline:showdetail]
pipeline = filter1 filter2 showstudetail

[filter:filter1]
#filter1 deal with auth,read args below
paste.filter_factory = python_paste:AuthFilter.factory
user = admin
passwd = admin

[filter:filter2]
#filter2 deal with time,read args below
paste.filter_factory = python_paste:LogFilter.factory
#all value is string
date = 20121120

[app:showstudetail]
name = wangchang
age = 23
paste.app_factory = python_paste:ShowStuDetail.factory

[app:showversion]
version = 1.0.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从配置文件可以看出，这个程序会有如下操作：&lt;/p&gt;

&lt;p&gt;对于&lt;a href=&#34;http://localhost/的访问，会调用showversion这个应用，应用读取ini文件中的version值并返回。注意，在ini中的所有值都是字符串。&#34;&gt;http://localhost/的访问，会调用showversion这个应用，应用读取ini文件中的version值并返回。注意，在ini中的所有值都是字符串。&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;对于&lt;a href=&#34;http://localhost/detail的访问，会先经过filter1以及filter2，这两个filter分别处理认证和LOG信息，他们会读取ini配置中的用户信息以及时间。最后才是交给showstudetail处理，showstudetail会读取ini中的用户信息并返回。注意，使用多个filter的时候需要使用pipeline方式。&#34;&gt;http://localhost/detail的访问，会先经过filter1以及filter2，这两个filter分别处理认证和LOG信息，他们会读取ini配置中的用户信息以及时间。最后才是交给showstudetail处理，showstudetail会读取ini中的用户信息并返回。注意，使用多个filter的时候需要使用pipeline方式。&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# -*- coding:utf-8 -*-
__author__ = &#39;sunyu&#39;

import os
from webob import Request
from webob import Response
from paste.deploy import loadapp
from wsgiref.simple_server import make_server


class AuthFilter(object):
    &amp;quot;&amp;quot;&amp;quot;filter1,auth
       1.factory read args and print,return self instance
       2.call method return app
       3.AuthFilter(app)
    &amp;quot;&amp;quot;&amp;quot;

    def __init__(self, app):
        self.app = app

    def __call__(self, environ, start_response):
        print &#39;this is Auth call filter1&#39;
        #pass environ and start_response to app
        return self.app(environ, start_response)

    @classmethod
    def factory(cls, global_conf, **kwargs):
        &amp;quot;&amp;quot;&amp;quot;global_conf and kwargs are dict&amp;quot;&amp;quot;&amp;quot;
        print &#39;######filter1##########&#39;
        print &#39;global_conf type:&#39;, type(global_conf)
        print &#39;[DEFAULT]&#39;, global_conf
        print &#39;kwargs type:&#39;, type(kwargs)
        print &#39;Auth Info&#39;, kwargs

        return AuthFilter


class LogFilter(object):
    &amp;quot;&amp;quot;&amp;quot;filter2,Log&amp;quot;&amp;quot;&amp;quot;

    def __init__(self, app):
        self.app = app

    def __call__(self, environ, start_response):
        print &#39;This is call LogFilter filter2&#39;
        return self.app(environ,start_response)

    @classmethod
    def factory(cls, global_conf, **kwargs):
        #print type(global_conf)
        #print type(kwargs)
        print &#39;######filter2###########&#39;
        print &#39;[DEFAULT]&#39;, global_conf
        print &#39;Log Info&#39;, kwargs

        return LogFilter


class ShowStuDetail(object):
    &amp;quot;&amp;quot;&amp;quot;app&amp;quot;&amp;quot;&amp;quot;
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __call__(self, environ, start_response):
        print &#39;this is call ShowStuDetail&#39;
        start_response(&amp;quot;200 OK&amp;quot;, [(&amp;quot;Content-type&amp;quot;, &amp;quot;text/plain&amp;quot;)])
        content = []
        content.append(&amp;quot;name: %s age:%s\n&amp;quot; % (self.name, self.age))
        content.append(&amp;quot;**********WSGI INFO***********\n&amp;quot;)

        for k, v in environ.iteritems():
            content.append(&#39;%s:%s \n&#39; % (k, v))

        return [&#39;\n&#39;.join(content)]

    @classmethod
    def factory(cls, global_conf, **kwargs):
        #self.name = kwargs[&#39;name&#39;]
        #self.age = kwargs[&#39;age&#39;]
        return ShowStuDetail(kwargs[&#39;name&#39;],kwargs[&#39;age&#39;])


class ShowVersion(object):
    &amp;quot;&amp;quot;&amp;quot;app&amp;quot;&amp;quot;&amp;quot;
    def __init__(self, version):
        self.version = version

    def __call__(self, environ, start_response):
        print &#39;this is call ShowVersion&#39;
        req = Request(environ)
        res = Response()
        res.status = &#39;200 OK&#39;
        res.content_type = &amp;quot;text/plain&amp;quot;
        content = []

        content.append(&amp;quot;%s\n&amp;quot; % self.version)
        content.append(&amp;quot;*********WSGI INFO*********&amp;quot;)
        for k, v in environ.iteritems():
            content.append(&#39;%s:%s\n&#39; % (k, v))
        res.body = &#39;\n&#39;.join(content)
        return res(environ,start_response)

    @classmethod
    def factory(cls, global_conf, **kwargs):
        #self.version = kwargs[&#39;version&#39;]
        return ShowVersion(kwargs[&#39;version&#39;])

if __name__ == &#39;__main__&#39;:
    config = &amp;quot;python_paste.ini&amp;quot;
    app_name = &amp;quot;common&amp;quot;
    app = loadapp(&amp;quot;config:%s&amp;quot; % os.path.abspath(config), app_name)
    server = make_server(&#39;localhost&#39;, 7070, app)
    server.serve_forever()
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Openstack oslo.config介绍(转)</title>
      <link>/post/oslo-config/</link>
      <pubDate>Fri, 11 Jul 2014 19:15:05 +0800</pubDate>
      
      <guid>/post/oslo-config/</guid>
      <description>&lt;p&gt;&lt;strong&gt;本文转自&lt;a href=&#34;http://blog.csdn.net/networm3/article/details/8946556&#34;&gt;OpenStack源码探秘（二）——Oslo.config&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;oslo.config, OpenStack中负责CLI和CONF配置项解析的组件。E版本前，这个功能是放在cfg模块中的，
后来社区中考虑将OpenStack中共性的组件都剥离出来，统一放在oslo模块中。今后开发新的OpenStack组件，估计都要用到Oslo模块。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;下面说明一下用法：
在oslo的cfg模块载入的时候(from oslo.config import cfg)，会自动运行模块中的载入代码CONF = ConfigOpts()，
创建一个全局的配置项管理类。和许多Conf配置模块一样，oslo.conf在使用时，需要先声明配置项的名称、定义类型、帮助文字、缺省值等，
然后再按照事先声明的配置项，对CLI或conf中的内容进行解析。&lt;br /&gt;
配置项声明结构示例如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;common_opts = [
    cfg.StrOpt(&#39;bind_host&#39;,
           default=&#39;0.0.0.0&#39;,
               help=&#39;IP address to listen on&#39;),
    cfg.IntOpt(&#39;bind_port&#39;,
               default=9292,
               help=&#39;Port number to listen on&#39;)
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;类型的定义对应Opt的各个子类。&lt;br /&gt;
oslo使用register_opt方法，将配置项定义向配置项管理类configOpts的注册是在程序的运行时刻，但是必须在配置项的引用前完成。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;CONF = cfg.CONF
CONF.register_opts(common_opts)

port = CONF.bind_port
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用conf.register_cli_opts()方法，配置项还可以在管理类ConfigOpts中可选注册为CLI配置项，
通过程序运行的CLI参数中获得配置项取值，并在错误打印时，自动输出给CLI配置项参数的帮助文档。&lt;br /&gt;
conf配置文件采用的是ini风格的格式&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;  glance-api.conf:
    [DEFAULT]
    bind_port = 9292
      ...

    [rabbit]
    host = localhost
    port = 5672
    use_ssl = False
    userid = guest
    password = guest
    virtual_host = /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后通过ConfigOpts类的&lt;strong&gt;call()&lt;/strong&gt;方法，执行配置项的解析以及从CLI或配置文件读取配置项的值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def __call__(self,
             args=None,
             project=None,
             prog=None,
             version=None,
             usage=None,
             default_config_files=None):
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是一个完整的示例&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from oslo.config import cfg

opts = [
    cfg.StrOpt(&#39;bind_host&#39;, default=&#39;0.0.0.0&#39;),
    cfg.IntOpt(&#39;bind_port&#39;, default=9292),
]

CONF = cfg.CONF
CONF.register_opts(opts)
CONF(default_config_files=&#39;glance.conf&#39;)
def start(server, app):
    server.start(app, CONF.bind_port, CONF.bind_host)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OpenStack项目的配置项声明和许多其他开源Python项目一样，配置项声明是放在各个调用的模块里面的。
也就是说哪里用到才到哪里声明。我觉得这种方式是完全体现了Pthonic的一种声明方式，有别于其他方式，
程序员在阅读程序的时候可以非常方便的在文件开头就能找到配置项的声明定义，而不用到某个指定的文件去查找，实现了KISS的原则。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Opensatck swift-ring-builder源码分析</title>
      <link>/post/swift-ring-builder/</link>
      <pubDate>Sun, 11 May 2014 19:23:24 +0800</pubDate>
      
      <guid>/post/swift-ring-builder/</guid>
      <description>&lt;p&gt;swift中关键的部分便是ring，那ring是如何创建的呢？&lt;/p&gt;

&lt;p&gt;我们来看bin目录下的swift-ring-builder:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import sys

from swift.cli.ringbuilder import main


if __name__ == &amp;quot;__main__&amp;quot;:
    sys.exit(main())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;调用swift.cli.ringbuilder中的main函数:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def main(arguments=None):
    global argv, backup_dir, builder, builder_file, ring_file
    if arguments:
        argv = arguments
    else:
        # from sys import argv as sys_argv
        argv = sys_argv

    # 参数只有一个时，也就是只是swift-ring-builder时，打印帮助信息
    if len(argv) &amp;lt; 2:
        print &amp;quot;swift-ring-builder %(MAJOR_VERSION)s.%(MINOR_VERSION)s\n&amp;quot; % \
              globals()
        print Commands.default.__doc__.strip()
        print
        # 去掉内置方法和default方法
        cmds = [c for c, f in Commands.__dict__.iteritems()
                if f.__doc__ and c[0] != &#39;_&#39; and c != &#39;default&#39;]
        cmds.sort()
        for cmd in cmds:
            # 打印方法的doc
            print Commands.__dict__[cmd].__doc__.strip()
            print
        print parse_search_value.__doc__.strip()
        print
        # wrap用来包装一段文本，返回值是文本每一行的列表
        for line in wrap(&#39; &#39;.join(cmds), 79, initial_indent=&#39;Quick list: &#39;,
                         subsequent_indent=&#39;            &#39;):
            print line
        print(&#39;Exit codes: 0 = operation successful\n&#39;
              &#39;            1 = operation completed with warnings\n&#39;
              &#39;            2 = error&#39;)
        exit(EXIT_SUCCESS)

    # parse_builder_ring_filename_args函数从第二个参数中解析出builder_file和ring_file
    builder_file, ring_file = parse_builder_ring_filename_args(argv)

    # 如果builder_file已存在，加载这个file
    if exists(builder_file):
        builder = RingBuilder.load(builder_file)
    elif len(argv) &amp;lt; 3 or argv[2] not in(&#39;create&#39;, &#39;write_builder&#39;):
        print &#39;Ring Builder file does not exist: %s&#39; % argv[1]
        exit(EXIT_ERROR)

    # 创建备份目录
    backup_dir = pathjoin(dirname(argv[1]), &#39;backups&#39;)
    try:
        mkdir(backup_dir)
    except OSError as err:
        if err.errno != EEXIST:
            raise

    if len(argv) == 2:
        command = &amp;quot;default&amp;quot;
    else:
        command = argv[2]
    if argv[0].endswith(&#39;-safe&#39;):
        try:
            with lock_parent_directory(abspath(argv[1]), 15):
                Commands.__dict__.get(command, Commands.unknown.im_func)()
        except exceptions.LockTimeout:
            print &amp;quot;Ring/builder dir currently locked.&amp;quot;
            exit(2)
    else:
        # 执行commands对应的方法
        Commands.__dict__.get(command, Commands.unknown.im_func)()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们来看下Commands里有多少主要的方法：
create， default， search， list_parts， add， set_weight， set_info， remove， rebalance， validate， write_ring， write_builder， set_min_part_hours， set_replicas&lt;/p&gt;

&lt;p&gt;通过建环的过程来分析几个重要的函数。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;swift-ring-builder account.builder create 3 2 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;1.create 方法，生成buidler file:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def create():
    &amp;quot;&amp;quot;&amp;quot;
	swift-ring-builder &amp;lt;builder_file&amp;gt; create &amp;lt;part_power&amp;gt; &amp;lt;replicas&amp;gt;
                                             &amp;lt;min_part_hours&amp;gt;
    Creates &amp;lt;builder_file&amp;gt; with 2^&amp;lt;part_power&amp;gt; partitions and &amp;lt;replicas&amp;gt;.
    &amp;lt;min_part_hours&amp;gt; is number of hours to restrict moving a partition more
    than once.
    &amp;quot;&amp;quot;&amp;quot;
    if len(argv) &amp;lt; 6:
        print Commands.create.__doc__.strip()
        exit(EXIT_ERROR)
	# 初始化RingBuilder，RingBuilder是用来建立Ring的类，__init__接收三个参数，
	# part_power, number of partitions = 2**part_power
    # replicas, 备份数
	# min_part_hours， minimum number of hours between partition changes
    builder = RingBuilder(int(argv[3]), float(argv[4]), int(argv[5]))
    backup_dir = pathjoin(dirname(argv[1]), &#39;backups&#39;)
    try:
		# 创建备份目录
        mkdir(backup_dir)
    except OSError as err:
        if err.errno != EEXIST:
            raise
    # 将builder存储在文件中
    builder.save(pathjoin(backup_dir, &#39;%d.&#39; % time() + basename(argv[1])))
    builder.save(argv[1])
    exit(EXIT_SUCCESS)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;命令的第4,5,6参数分别是part_power, repicas, min_part_hours&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;swift-ring-builder account.builder add r1z1-192.168.0.2:6002/sdd 3
swift-ring-builder account.builder add r1z2-192.168.0.3:6002/sdd 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.add 方法，添加设备到builder file中：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def add():
	&amp;quot;&amp;quot;&amp;quot;
	swift-ring-builder &amp;lt;builder_file&amp;gt; add
    [r&amp;lt;region&amp;gt;]z&amp;lt;zone&amp;gt;-&amp;lt;ip&amp;gt;:&amp;lt;port&amp;gt;[R&amp;lt;r_ip&amp;gt;:&amp;lt;r_port&amp;gt;]/&amp;lt;device_name&amp;gt;_&amp;lt;meta&amp;gt;
     &amp;lt;weight&amp;gt;
    [[r&amp;lt;region&amp;gt;]z&amp;lt;zone&amp;gt;-&amp;lt;ip&amp;gt;:&amp;lt;port&amp;gt;[R&amp;lt;r_ip&amp;gt;:&amp;lt;r_port&amp;gt;]/&amp;lt;device_name&amp;gt;_&amp;lt;meta&amp;gt;
     &amp;lt;weight&amp;gt;] ...

    Where &amp;lt;r_ip&amp;gt; and &amp;lt;r_port&amp;gt; are replication ip and port.

	or

	swift-ring-builder &amp;lt;builder_file&amp;gt; add
    [--region &amp;lt;region&amp;gt;] --zone &amp;lt;zone&amp;gt; --ip &amp;lt;ip&amp;gt; --port &amp;lt;port&amp;gt;
    --replication-ip &amp;lt;r_ip&amp;gt; --replication-port &amp;lt;r_port&amp;gt;
    --device &amp;lt;device_name&amp;gt; --meta &amp;lt;meta&amp;gt; --weight &amp;lt;weight&amp;gt;

    Adds devices to the ring with the given information. No partitions will be
    assigned to the new device until after running &#39;rebalance&#39;. This is so you
    can make multiple device changes and rebalance them all just once.
    &amp;quot;&amp;quot;&amp;quot;
    if len(argv) &amp;lt; 5 or len(argv) % 2 != 1:
        print Commands.add.__doc__.strip()
        exit(EXIT_ERROR)

	# _parse_add_values，从参数中解析出设备信息
    for new_dev in _parse_add_values(argv[3:]):
        for dev in builder.devs:
            if dev is None:
                continue
            if dev[&#39;ip&#39;] == new_dev[&#39;ip&#39;] and \
                    dev[&#39;port&#39;] == new_dev[&#39;port&#39;] and \
                    dev[&#39;device&#39;] == new_dev[&#39;device&#39;]:
                print &#39;Device %d already uses %s:%d/%s.&#39; % \
                      (dev[&#39;id&#39;], dev[&#39;ip&#39;], dev[&#39;port&#39;], dev[&#39;device&#39;])
                print &amp;quot;The on-disk ring builder is unchanged.\n&amp;quot;
                exit(EXIT_ERROR)
		# 添加新设备
        dev_id = builder.add_dev(new_dev)
        print(&#39;Device %s with %s weight got id %s&#39; %
              (format_device(new_dev), new_dev[&#39;weight&#39;], dev_id))
	# 存储builder
    builder.save(argv[1])
    exit(EXIT_SUCCESS)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;两个设备的属性如下：
&lt;table&gt;
  &lt;tr&gt;
    &lt;td&gt;&lt;/td&gt;
    &lt;td&gt;dev0&lt;/td&gt;
    &lt;td&gt;dev1&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;id&lt;/td&gt;
    &lt;td&gt;0&lt;/td&gt;
    &lt;td&gt;1&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;weight&lt;/td&gt;
    &lt;td&gt;3&lt;/td&gt;
    &lt;td&gt;1&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;region&lt;/td&gt;
    &lt;td&gt;1&lt;/td&gt;
    &lt;td&gt;1&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;zone&lt;/td&gt;
    &lt;td&gt;1&lt;/td&gt;
    &lt;td&gt;2&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;ip&lt;/td&gt;
    &lt;td&gt;192.168.0.2&lt;/td&gt;
    &lt;td&gt;192.168.0.3&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;port&lt;/td&gt;
    &lt;td&gt;6002&lt;/td&gt;
    &lt;td&gt;6002&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;device&lt;/td&gt;
    &lt;td&gt;sdd&lt;/td&gt;
    &lt;td&gt;sdd&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;parts_wanted&lt;/td&gt;
    &lt;td&gt;12&lt;/td&gt;
    &lt;td&gt;4&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;swift-ring-builder account.builder rebalance
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.rebalance 方法，重新平衡虚拟节点，分配虚拟节点到设备&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def rebalance():
    &amp;quot;&amp;quot;&amp;quot;
	swift-ring-builder &amp;lt;builder_file&amp;gt; rebalance &amp;lt;seed&amp;gt;
    Attempts to rebalance the ring by reassigning partitions that haven&#39;t been
    recently reassigned.
    &amp;quot;&amp;quot;&amp;quot;
    def get_seed(index):
        try:
            return argv[index]
        except IndexError:
            pass
	# 设备是否有所改变
    devs_changed = builder.devs_changed
    try:
		# 获取旧的平衡
        last_balance = builder.get_balance()
		# 重新平衡
        parts, balance = builder.rebalance(seed=get_seed(3))
    except exceptions.RingBuilderError as e:
        print &#39;-&#39; * 79
        print(&amp;quot;An error has occurred during ring validation. Common\n&amp;quot;
              &amp;quot;causes of failure are rings that are empty or do not\n&amp;quot;
              &amp;quot;have enough devices to accommodate the replica count.\n&amp;quot;
              &amp;quot;Original exception message:\n %s&amp;quot; % e.message
              )
        print &#39;-&#39; * 79
        exit(EXIT_ERROR)
    if not parts:
        print &#39;No partitions could be reassigned.&#39;
        print &#39;Either none need to be or none can be due to &#39; \
              &#39;min_part_hours [%s].&#39; % builder.min_part_hours
        exit(EXIT_WARNING)
    # If we set device&#39;s weight to zero, currently balance will be set
    # special value(MAX_BALANCE) until zero weighted device return all
    # its partitions. So we cannot check balance has changed.
    # Thus we need to check balance or last_balance is special value.
    if not devs_changed and abs(last_balance - balance) &amp;lt; 1 and \
            not (last_balance == MAX_BALANCE and balance == MAX_BALANCE):
        print &#39;Cowardly refusing to save rebalance as it did not change &#39; \
              &#39;at least 1%.&#39;
    	exit(EXIT_WARNING)
    try:
        builder.validate()
    except exceptions.RingValidationError as e:
        print &#39;-&#39; * 79
        print(&amp;quot;An error has occurred during ring validation. Common\n&amp;quot;
              &amp;quot;causes of failure are rings that are empty or do not\n&amp;quot;
              &amp;quot;have enough devices to accommodate the replica count.\n&amp;quot;
              &amp;quot;Original exception message:\n %s&amp;quot; % e.message
              )
        print &#39;-&#39; * 79
        exit(EXIT_ERROR)
    print &#39;Reassigned %d (%.02f%%) partitions. Balance is now %.02f.&#39; % \
          (parts, 100.0 * parts / builder.parts, balance)
    status = EXIT_SUCCESS
    if balance &amp;gt; 5:
        print &#39;-&#39; * 79
        print &#39;NOTE: Balance of %.02f indicates you should push this &#39; % \
              balance
        print &#39;      ring, wait at least %d hours, and rebalance/repush.&#39; \
              % builder.min_part_hours
        print &#39;-&#39; * 79
        status = EXIT_WARNING
    ts = time()
    # 获取Ring，并保存备份
    builder.get_ring().save(
        pathjoin(backup_dir, &#39;%d.&#39; % ts + basename(ring_file)))
    builder.save(pathjoin(backup_dir, &#39;%d.&#39; % ts + basename(argv[1])))
	# 将Ring保存到ring file中
    builder.get_ring().save(ring_file)
    builder.save(argv[1])
    exit(status)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;来看RingBuilder的rebalance方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt; def rebalance(self, seed=None):
    &amp;quot;&amp;quot;&amp;quot;
    Rebalance the ring.

    This is the main work function of the builder, as it will assign and
    reassign partitions to devices in the ring based on weights, distinct
    zones, recent reassignments, etc.

    The process doesn&#39;t always perfectly assign partitions (that&#39;d take a
    lot more analysis and therefore a lot more time -- I had code that did
    that before). Because of this, it keeps rebalancing until the device
    skew (number of partitions a device wants compared to what it has) gets
    below 1% or doesn&#39;t change by more than 1% (only happens with ring that
    can&#39;t be balanced no matter what -- like with 3 zones of differing
    weights with replicas set to 3).

    :returns: (number_of_partitions_altered, resulting_balance)
    &amp;quot;&amp;quot;&amp;quot;

    if seed is not None:
        random.seed(seed)

    self._ring = None
	# _last_part_moves_epoch表示上一次移动part的时间， 为None表示首次平衡
    if self._last_part_moves_epoch is None:
        self._initial_balance()
        self.devs_changed = False
        return self.parts, self.get_balance()
    retval = 0
	# 更新上次移动的信息，包括移动的part和移动的时间
    self._update_last_part_moves()
    last_balance = 0
	# 调整part的数目，返回调整后的part和被移除的part数目
    new_parts, removed_part_count = self._adjust_replica2part2dev_size()
    retval += removed_part_count
	# 重新分配part
    self._reassign_parts(new_parts)
    retval += len(new_parts)
    while True:
		# 分配被移除设备上的part
        reassign_parts = self._gather_reassign_parts()
        self._reassign_parts(reassign_parts)
        retval += len(reassign_parts)
        while self._remove_devs:
            self.devs[self._remove_devs.pop()[&#39;id&#39;]] = None
        balance = self.get_balance()
		# 如果balance小于1或者所有的part都都分配了。退出循环
        if balance &amp;lt; 1 or abs(last_balance - balance) &amp;lt; 1 or \
                retval == self.parts:
            break
        last_balance = balance
    self.devs_changed = False
    self.version += 1
    return retval, balance
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;建环主要就是create，add，rebalance三步。其他的如search，list_parts，remove等都比较简单，这里不做分析。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>