<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>其他 on Sung Yung</title>
    <link>/categories/%E5%85%B6%E4%BB%96/index.xml</link>
    <description>Recent content in 其他 on Sung Yung</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="/categories/%E5%85%B6%E4%BB%96/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>C语言可变参数</title>
      <link>/post/c-args/</link>
      <pubDate>Wed, 17 Jun 2015 22:01:25 +0800</pubDate>
      
      <guid>/post/c-args/</guid>
      <description>&lt;p&gt;在python中写一个有可变参数的函数或者方法是很容易的，比如下面这个例子:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def print_args(*args, **kwargs):
	print type(args), args
	print type(kwargs), kwargs
	for arg in args:
		print arg
	for arg, value in kwargs.items():
		print &#39;%s = %s&#39; % (arg, value)

&amp;gt;&amp;gt;&amp;gt; print_args(1, 2, 3, x=4, y=5)
&amp;lt;type &#39;tuple&#39;&amp;gt; (1, 2, 3)
&amp;lt;type &#39;dict&#39;&amp;gt; {&#39;y&#39;: 5, &#39;x&#39;: 4}
1
2
3
y = 5
x = 4

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;从打印的信息中可以看出，args是一个元组，而kwargs是一个字典。&lt;/p&gt;

&lt;p&gt;可以说在python中操作可变参数是非常简单的，那么C语言中是否同样有类似的功能？&lt;/p&gt;

&lt;p&gt;答案是肯定的。我们都该知道printf函数的参数的个数是可变的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
int printf(const char *format, ...);


printf(&amp;quot;Hello,world!&amp;quot;);  //其参数个数为1个。
printf(&amp;quot;a=%d,b=%s,c=%c&amp;quot;, a, b, c);  //其参数个数为4个。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;printf原型中&amp;hellip;表示参数个数是不定的。那么我们该怎么实现这个可变参数函数呢？&lt;/p&gt;

&lt;p&gt;为了编写可变参数函数，我们通常需要用到&lt;stdarg.h&gt;头文件中定义的以下函数:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void va_start(va_list ap, last);
type va_arg(va_list ap, type);
void va_end(va_list ap);
void va_copy(va_list dest, va_list src);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中：
va_list是用于存放参数列表的数据结构。&lt;/p&gt;

&lt;p&gt;va_start函数根据初始化last来初始化参数列表。&lt;/p&gt;

&lt;p&gt;va_arg函数用于从参数列表中取出一个参数，参数类型由type指定。&lt;/p&gt;

&lt;p&gt;va_copy函数用于复制参数列表。&lt;/p&gt;

&lt;p&gt;va_end函数执行清理参数列表的工作。&lt;/p&gt;

&lt;p&gt;上述函数通常用宏来实现，例如标准ANSI形式下，这些宏的定义是：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;typedef char * va_list; //字符串指针
//字节对齐
#define _INTSIZEOF(n) ( (sizeof(n) + sizeof(int) - 1) &amp;amp; ~(sizeof(int) - 1) )
#define va_start(ap,v) ( ap = (va_list)&amp;amp;v + _INTSIZEOF(v) )
#define va_arg(ap,t) ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )
#define va_end(ap) ( ap = (va_list)0 )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以参考一下:
&lt;a href=&#34;http://www.cnblogs.com/wangyonghui/archive/2010/07/12/1776068.html&#34;&gt;http://www.cnblogs.com/wangyonghui/archive/2010/07/12/1776068.html&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>使用pgpool&#43;流复制搭建Postgresql高可用环境</title>
      <link>/post/pgpool/</link>
      <pubDate>Sun, 10 May 2015 19:18:40 +0800</pubDate>
      
      <guid>/post/pgpool/</guid>
      <description>&lt;p&gt;研究了2周的pgpool搭建终于有点了成果，在这里总结下整个过程。&lt;/p&gt;

&lt;h2 id=&#34;一-环境&#34;&gt;一.环境&lt;/h2&gt;

&lt;p&gt;db1 10.0.0.2  ubuntu 14.04 server&lt;/p&gt;

&lt;p&gt;db2 10.0.0.3  ubuntu 14.04 server&lt;/p&gt;

&lt;p&gt;watchdog VIP： 10.0.0.4&lt;/p&gt;

&lt;p&gt;pg版本：    9.4.0&lt;/p&gt;

&lt;p&gt;pgpool版本：3.4.1&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 创建postgres用户，并创建用于安装pg的目录
root@ubuntu:~# groupadd postgres
root@ubuntu:~# useradd -g postgres -d /home/postgres -m -s /bin/bash postgres
root@ubuntu:~# passwd postgres
root@ubuntu:~# su - postgres
postgres@ubuntu:~ mkdir -p /home/postgres/db/data
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改两个节点的hosts文件，设置postgres用户之间无密码连接，使用ssh-keygen和ssh-copy-id两个命令。&lt;/p&gt;

&lt;p&gt;依赖包，源码在两个节点上都需要安装。&lt;/p&gt;

&lt;h2 id=&#34;二-依赖包的安装&#34;&gt;二.依赖包的安装&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 编译postgresql源码需要zlib1g-dev libreadline-dev flex bison make
root@ubuntu:~# apt-get install --yes --force-yes zlib1g-dev libreadline-dev flex bison make

# pgpool watchdog需要arping
root@ubuntu:~# apt-get install --yes --force-yes arping
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;三-源码安装&#34;&gt;三.源码安装&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 编译pg源码并安装
root@ubuntu:~# tar xvf postgresql-9.4.0.tar.bz2 -C /tmp
root@ubuntu:~# cd /tmp/postgresql-9.4.0
root@ubuntu:/tmp/postgresql-9.4.0~# ./configure --prefix &amp;amp;&amp;amp; make &amp;amp;&amp;amp; make install

# 将pg加入环境变量
root@ubuntu:~# sed -i &#39;1i\PATH=\$PATH:/home/postgres/db/bin \nexport PGDATA=/home/postgres/db/data&#39; /home/postgres/.bashrc
root@ubuntu:~# sed -i &#39;1i\PATH=\$PATH:/home/postgres/db/bin \nexport PGDATA=/home/postgres/db/data&#39; /root/.bashrc
root@ubuntu:~# source ~/.bashrc

# 编译pgpool源码并安装
root@ubuntu:~# tar xvf pgpool-II-3.4.1.tar.gz -C /tmp
root@ubuntu:~# cd /tmp/pgpool-II-3.4.1
root@ubuntu:/tmp/pgpool-II-3.4.1~# ./configure --prefix &amp;amp;&amp;amp; make &amp;amp;&amp;amp; make install
# 安装pgpool-recovery，用于在线恢复
# pg9.4版本中已经含有pgpool-regclass，所以这里不用安装
root@ubuntu:/tmp/pgpool-II-3.4.1~# cd src/sql/pgpool-recovery &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;拷贝pcp.conf，pgpool.conf和pool_hba.conf，默认在/usr/local/etc下&lt;/p&gt;

&lt;p&gt;创建/var/run/pgpool，/var/log/pgpool，修改目录权限&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@ubuntu:~# mkdir /var/run/pgpool /var/log/pgpool
root@ubuntu:~# chown -R postgres:postgres /var/run/pgpool /var/log/pgpool /usr/local/etc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在/home/postgres/db/bin下添加failover_stream.sh脚本（注意执行权限），该脚本用于
故障切换。&lt;/p&gt;

&lt;p&gt;failover_stream.sh&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#!/usr/bin/env bash
# Execute command by failover.
# special values:
# 特殊字符	描述
# %d	断开连接的节点的后台 ID。
# %h	断开连接的节点的主机名。
# %p	断开连接的节点的端口号。
# %D	断开连接的节点的数据库实例所在目录。
# %M	旧的主节点 ID。
# %m	新的主节点 ID。
# %H	新的主节点主机名。
# %P	旧的第一节点 ID。
# %r    新的主节点端口
# %R    新的主节点数据库实例目录
# %%	&#39;%&#39; 字符

# ---------------------------------------------------------------------
# prepare
# ---------------------------------------------------------------------

SCRIPT_LOG=&amp;quot;/var/log/pgpool/failover.log&amp;quot;

FAILED_NODE_ID=${1}
FAILED_NODE_HOST=${2}
FAILED_NODE_PORT=${3}
FAILED_NODE_PGDATA=${4}
NEW_MASTER_NODE_ID=${5}
OLD_MASTER_NODE_ID=${6}
NEW_MASTER_NODE_HOST=${7}
OLD_PRIMARY_NODE_ID=${8}
NEW_MASTER_NODE_PORT=${9}
NEW_MASTER_NODE_PGDATA=${10}

echo &amp;quot;----------------------------------------------------------------------&amp;quot; &amp;gt;&amp;gt; ${SCRIPT_LOG}
date &amp;gt;&amp;gt; ${SCRIPT_LOG}
echo &amp;quot;----------------------------------------------------------------------&amp;quot; &amp;gt;&amp;gt; ${SCRIPT_LOG}
echo &amp;quot;&amp;quot; &amp;gt;&amp;gt; ${SCRIPT_LOG}

echo &amp;quot;
[ node which failed ]
FAILED_NODE_ID           ${FAILED_NODE_ID}
FAILED_NODE_HOST         ${FAILED_NODE_HOST}
FAILED_NODE_PORT         ${FAILED_NODE_PORT}
FAILED_NODE_PGDATA       ${FAILED_NODE_PGDATA}

[ before failover ]
OLD_PRIMARY_NODE_ID      ${OLD_PRIMARY_NODE_ID}
OLD_MASTER_NODE_ID       ${OLD_MASTER_NODE_ID}

[ after faiover ]
NEW_MASTER_NODE_ID       ${NEW_MASTER_NODE_ID}
NEW_MASTER_NODE_HOST     ${NEW_MASTER_NODE_HOST}
NEW_MASTER_NODE_PORT     ${NEW_MASTER_NODE_PORT}
NEW_MASTER_NODE_PGDATA   ${NEW_MASTER_NODE_PGDATA}
&amp;quot; &amp;gt;&amp;gt; ${SCRIPT_LOG}

# ---------------------------------------------------------------------
# Do promote only when the primary node failes
# ---------------------------------------------------------------------

if [ &amp;quot;${FAILED_NODE_ID}&amp;quot; == &amp;quot;${OLD_PRIMARY_NODE_ID}&amp;quot; ]; then
    PROMOTE_COMMAND=&amp;quot;pg_ctl -D ${NEW_MASTER_NODE_PGDATA} promote&amp;quot;

    echo &amp;quot;The primary node (node ${OLD_PRIMARY_NODE_ID}) dies.&amp;quot; &amp;gt;&amp;gt; ${SCRIPT_LOG}
    echo &amp;quot;Node ${NEW_MASTER_NODE_ID} takes over the primary.&amp;quot; &amp;gt;&amp;gt; ${SCRIPT_LOG}

    echo &amp;quot;Execute: ${PROMOTE_COMMAND}&amp;quot; &amp;gt;&amp;gt; ${SCRIPT_LOG}
    ssh postgres@${NEW_MASTER_NODE_HOST} -T &amp;quot;${PROMOTE_COMMAND}&amp;quot; &amp;gt;&amp;gt; ${SCRIPT_LOG}

else
    echo &amp;quot;Node ${FAILED_NODE_ID} dies, but it&#39;s not the primary node. This script doesn&#39;t anything.&amp;quot; &amp;gt;&amp;gt; ${SCRIPT_LOG}
fi

echo &amp;quot;&amp;quot; &amp;gt;&amp;gt; ${SCRIPT_LOG}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在/home/postgres/db/data下添加basebackup.sh和pgpool_remote_start，用于在线恢复。&lt;/p&gt;

&lt;p&gt;basebackup.sh，db1上$host修改成db1，db2上同理。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#!/usr/bin/env bash
# Recovery script for streaming replication.
# This script assumes that DB node 0 is primary, and 1 is standby.
#
datadir=$1
desthost=$2
destdir=$3

psql -c &amp;quot;SELECT pg_start_backup(&#39;Streaming Replication&#39;, true)&amp;quot; postgres

ssh -T postgres@$desthost mv $destdir/basebackup.sh $destdir/../
ssh -T postgres@$desthost rm -rf $destdir/*
ssh -T postgres@$desthost pg_basebackup -D $destdir -Fp -Xs -v -P -h $host -U repl
ssh -T postgres@$desthost mv $destdir/../basebackup.sh $destdir/

ssh -T postgres@$desthost mv $destdir/recovery.done $destdir/recovery.conf
ssh -T postgres@$desthost &amp;quot;sed -i \&amp;quot;s/[# ]*primary_conninfo[ ]*=.*/primary_conninfo = &#39;host=$host port=5432 user=$PG_REPL_USER&#39;/g\&amp;quot; $destdir/recovery.conf&amp;quot;

psql -c &amp;quot;SELECT pg_stop_backup()&amp;quot; postgres
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;pgpool_remote_start&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#!/usr/bin/env bash
# start postmaster on the recoveried node

if [ $# -ne 2 ]
then
    echo &amp;quot;pgpool_remote_start remote_host remote_datadir&amp;quot;
    exit 1
fi

SCRIPT_LOG=&amp;quot;/var/log/pgpool/remote_start.log&amp;quot;

DEST_HOST=$1

echo &amp;quot;----------------------------------------------------------------------&amp;quot; &amp;gt;&amp;gt; ${SCRIPT_LOG}
date &amp;gt;&amp;gt; ${SCRIPT_LOG}
echo &amp;quot;----------------------------------------------------------------------&amp;quot; &amp;gt;&amp;gt; ${SCRIPT_LOG}
echo &amp;quot;&amp;quot; &amp;gt;&amp;gt; ${SCRIPT_LOG}

COMMAND=&amp;quot;pg_ctl -w  start &amp;gt; /dev/null 2&amp;gt;&amp;amp;1&amp;quot;

echo &amp;quot;
DEST_HOST         ${DEST_HOST}
COMMAND           ${COMMAND}
&amp;quot; &amp;gt;&amp;gt; ${SCRIPT_LOG}

echo &amp;quot;remote start&amp;quot; &amp;gt;&amp;gt; ${SCRIPT_LOG}
ssh postgres@${DEST_HOST} -T &amp;quot;${COMMAND}&amp;quot;

ps auwx | grep postgres &amp;gt;&amp;gt; ${SCRIPT_LOG}
echo &amp;quot;&amp;quot; &amp;gt;&amp;gt; ${SCRIPT_LOG}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;四-配置db1&#34;&gt;四.配置db1&lt;/h2&gt;

&lt;p&gt;初始化并启动&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;root@ubuntu~# su - postgres
postgres@ubuntu:~$ initdb -U postgres
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改postgresql.conf配置文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;log_destination = &#39;csvlog&#39; # 使用csv格式的log,因为一般会按大小和时间自动切割
logging_collector = on # 如果使用csvlog，那么要开启日志收集
listen_addresses = &#39;*&#39;
wal_level = hot_standby # 日志级别使用hot_standby
archive_mode = on
archive_command = &#39;cp %p /home/postgres/db/archive/%f&#39;
max_wal_senders = 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动pg，添加pgpool_recovery扩展&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;postgres@ubuntu:~$ pg_ctl start &amp;gt; /dev/null 2&amp;gt;&amp;amp;1
postgres@ubuntu:~$ psql template1 -c &#39;create extension pgpool_recovery;&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建用于备份的用户&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;postgres@ubuntu:~$ createuser rep -l --replication -E -P
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改pg_hba.conf，加入&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;host  all      rep      10.0.0.0/24    trust
host  all      postgres 10.0.0.0/24    trust
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;五-配置db2&#34;&gt;五.配置db2&lt;/h2&gt;

&lt;p&gt;通过pg_basebackup和db1同步&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;postgres@ubuntu:~$ pg_basebackup -D /home/postgres/db/data -Fp -Xs -v -P -h db1 -U rep
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从/home/postgres/db/share下拷贝recovery.conf文件到data目录下，并修改&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;standby_mode = on
primary_conninfo = &#39;host=db1 port=5432 user=rep&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改postgresql.conf配置：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;hot_standby = on # 开启热备模式
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动pg&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;postgres@ubuntu:~$ pg_ctl start &amp;gt; /dev/null 2&amp;gt;&amp;amp;1
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;六-配置pgpool&#34;&gt;六.配置pgpool&lt;/h2&gt;

&lt;p&gt;修改db1上pgpool.conf：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;listen_addresses = &#39;*&#39;
pcp_listen_addresses = &#39;*&#39;
enable_pool_hba = on
pool_passwd = &#39;pool_passwd&#39;
replication_mode = off # 关闭复制模式
load_balance_mode = on # 打开负载均衡
master_slave_mode = on # 打开主备
log_destination = &#39;syslog&#39; # 日志使用syslog
master_slave_sub_mode=&#39;stream&#39; # 使用流复制
sr_check_user = &#39;rep&#39;
sr_check_password = &#39;rep&#39; # 创建rep用户的时候指定
health_check_user = &#39;rep&#39;
health_check_password = &#39;rep&#39;
failover_command = &#39;/home/postgres/db/failover_stream.sh %d %h %p %D %m %M %H %P %r %R&#39;
backend_hostname0 = &#39;db1&#39;
backend_port0 = 5432
backend_weight0 = 1
backend_data_directory0 = &#39;/home/postgres/db/data&#39;
backend_flag0 = &#39;ALLOW_TO_FAILOVER&#39;
backend_hostname1 = &#39;db2&#39;
backend_port1 = 5432
backend_weight1 = 1
backend_data_directory1 = &#39;/home/postgres/db/data&#39;
backend_flag1 = &#39;ALLOW_TO_FAILOVER&#39;
use_watchdog = on # 开启watchdog
wd_hostname = &#39;db1&#39;
delegate_IP = &#39;10.0.0.4&#39;
heartbeat_destination0 = &#39;db2&#39;
other_pgpool_hostname0 = &#39;db2&#39;
other_pgpool_port0 = 9999
other_wd_port0 = 9000
recovery_user = &#39;postgres&#39;
recovery_password = &#39;&#39;
recovery_1st_stage_command = &#39;basebackup.sh&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改db2上pgpool.conf（和db1中有区别的）:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;wd_hostname = &#39;db2&#39;
heartbeat_destination0 = &#39;db1&#39;
other_pgpool_hostname0 = &#39;db1&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;db1和db2上的pool_hba.conf中添加&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;host all postgres 10.0.0.0/24 trust
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;db1和db2上的/etc/rsyslog.conf添加，并重启rsyslog&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;local0.*    /var/log/pgpool.log
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用pg_md5生成密钥，db1和db2上的密钥可能不同:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;postgres@ubuntu:~$ pg_md5 postgres
21232f297a57a5a743894a0e4a801fc3

# 在pcp.conf中添加postgres:21232f297a57a5a743894a0e4a801fc3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在db1和db2上启动pgpool&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;postgres@ubuntu:~$ pgpool
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;至此，安装完成，下面进行简单的测试。&lt;/p&gt;

&lt;h2 id=&#34;七-测试&#34;&gt;七.测试&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 使用VIP登录pg，发现db1主，db2备
postgres@ubuntu:~$ psql -h 10.0.0.4 -p 9999
psql (9.4.0)
Type &amp;quot;help&amp;quot; for help.

postgres=# show pool_nodes;
 node_id | hostname | port | status | lb_weight |  role
---------+----------+------+--------+-----------+---------
 0       | db1      | 5432 | 2      | 0.500000  | primary
 1       | db2      | 5432 | 2      | 0.500000  | standby
(2 rows)

# 关闭db1上的pg服务，再次查看nodes，故障切换完成，db1变成备，db2变成主

postgres=# show pool_nodes;
 node_id | hostname | port | status | lb_weight |  role
---------+----------+------+--------+-----------+---------
 0       | db1      | 5432 | 3      | 0.500000  | standby
 1       | db2      | 5432 | 2      | 0.500000  | primary
(2 rows)

# 恢复db1，注意要进行恢复操作，必须使用主节点上的pgpool服务
# 这里db2目前是主节点，所以pgpool的hostname使用db2
postgres@ubuntu:~$ pcp_recovery_node -d 5 db2 9898 postgres postgres 0

postgres=# show pool_nodes;
 node_id | hostname | port | status | lb_weight |  role
---------+----------+------+--------+-----------+---------
 0       | db1      | 5432 | 2      | 0.500000  | standby
 1       | db2      | 5432 | 2      | 0.500000  | primary
(2 rows)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中status的值如下：&lt;/p&gt;

&lt;p&gt;0：从未使用，直接忽略&lt;/p&gt;

&lt;p&gt;1：server已经启动，但是连接池中没有连接&lt;/p&gt;

&lt;p&gt;2：server已经启动，并且在连接池中存在连接&lt;/p&gt;

&lt;p&gt;3：server没有启动或者联系不上&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Postgresql子进程启动</title>
      <link>/post/pg-subprocess/</link>
      <pubDate>Sun, 05 Apr 2015 19:19:35 +0800</pubDate>
      
      <guid>/post/pg-subprocess/</guid>
      <description>&lt;p&gt;PG是多进程的运行模式，除了Postmaster主进程外，还有以下子进程：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;SysLogger process&lt;/li&gt;
&lt;li&gt;Startup process&lt;/li&gt;
&lt;li&gt;Bgwriter process&lt;/li&gt;
&lt;li&gt;Checkpointer process&lt;/li&gt;
&lt;li&gt;Walwriter process&lt;/li&gt;
&lt;li&gt;Walreceiver process&lt;/li&gt;
&lt;li&gt;Pgstat process&lt;/li&gt;
&lt;li&gt;Pgarchive process&lt;/li&gt;
&lt;li&gt;Auto Vacuum process&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;那么子进程到底是在何时启动的？&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;通过代码，我们很容易就能发现子进程启动的位置是在PostmasterMain中。&lt;/p&gt;

&lt;p&gt;第一个启动的进程是SysLogger：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// postmaster.c:1146
SysLoggerPID = SysLogger_Start();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SysLogger_Start中前面的一些处理不做分析了，直接到&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// syslogger.c:601
switch ((sysloggerPid = fork_process()))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;fork_process对linux的fork()函数做了一层简单的封装，返回值是一样的。
如果返回-1表示创建子进程出错；返回0表示创建成功，并且当前是在子进程中；
返回其他值就表明创建成功，并且当前在父进程中，返回值是子进程的PID。&lt;/p&gt;

&lt;p&gt;fork_process返回值是0时，进入子进程，接着走到SysLoggerMain。在这个函数中，
做了一些初始化后，进入for(;;)循环。&lt;/p&gt;

&lt;p&gt;第二个启动的进程是Startup process:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// postmaster.c:1217
StartupPID = StartupDataBase();

// postmaster.c:503
#define StartupDataBase()  StartChildProcess(StartupProcess)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在StartChildProcess中同样是调用fork_process创建子进程，返回0进入子进程，调用
AuxiliaryProcessMain。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// postmaster.c:5103
AuxiliaryProcessMain(ac, av);

// bootstrap.c:414
case StartupProcess:
    /* don&#39;t set signals, startup process has its own agenda */
    StartupProcessMain();
    proc_exit(1);

// startup.c:224
StartupXLOG();

/*
* Exit normally. Exit code 0 tells postmaster that we completed recovery
* successfully.
*/
proc_exit(0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;starup process实际的入口是StartupProcessMain。但是我们看到，在这个函数中，做完
预写日志恢复后，就正常退出了，在官方给的注释中说明，正常退出告诉postmaster，我们已经
成功恢复。那么这边退出到底是为了什么？&lt;/p&gt;

&lt;p&gt;我们先不考虑这个，如果接着跟踪代码，进入到PostmasterMain的ServerLoop中。在for(;;)循环中，
判断其他进程的PID是否为0，如果为0就创建该子进程。&lt;/p&gt;

&lt;p&gt;那么其他进程是在这个时候创建的么？&lt;/p&gt;

&lt;p&gt;答案是否。如果调试代码到这个地方，会发现，这些进程PID不为0，说明在这之前就已经创建完成了。我们不禁会问，
到底是什么时候创建的，在流程里根本没发现啊。嘿嘿，这里就要说到start process的退出了。&lt;/p&gt;

&lt;p&gt;子进程退出会像父进程也就是postmaster进程发送一个SIGCHLD信号。而在PostmasterMain的开始处，就给SIGCHLD注册
了一个信号处理函数reaper。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// postmaster.c:587
pqsignal(SIGCHLD, reaper);	/* handle child termination */

// postmaster.c:2608
if (CheckpointerPID == 0)
	CheckpointerPID = StartCheckpointer();
if (BgWriterPID == 0)
	BgWriterPID = StartBackgroundWriter();
if (WalWriterPID == 0)
	WalWriterPID = StartWalWriter();

/*
* Likewise, start other special children as needed.  In a restart
* situation, some of them may be alive already.
*/
if (!IsBinaryUpgrade &amp;amp;&amp;amp; AutoVacuumingActive() &amp;amp;&amp;amp; AutoVacPID == 0)
    AutoVacPID = StartAutoVacLauncher();
if (XLogArchivingActive() &amp;amp;&amp;amp; PgArchPID == 0)
	PgArchPID = pgarch_start();
if (PgStatPID == 0)
	PgStatPID = pgstat_start();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在reaper函数里，我们也发现了这里也有启动进程的方法，一调试代码发现其他子进程就是在这里启动的。&lt;/p&gt;

&lt;p&gt;总结一下就是，先启动SysLogger，然后是Startup，Startup退出后触发主进程启动其他进程。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>使用VS2013编译安装postgresql</title>
      <link>/post/vs-build-pg/</link>
      <pubDate>Tue, 10 Mar 2015 19:24:26 +0800</pubDate>
      
      <guid>/post/vs-build-pg/</guid>
      <description>&lt;p&gt;整理一下在windows平台下使用vs2013编译安装postgresql的步骤，postgresql版本是9.4.0。&lt;/p&gt;

&lt;p&gt;我的pg源码目录是E:\Workspace\postgresql-9.4.0。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;首先修改src\tools\msvc下面的Mkvcbuild.pm文件：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#my $vsVersion = DetermineVisualStudioVersion();
my $vsVersion = &#39;12.00&#39;;

$solution = CreateSolution($vsVersion, $config);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装perl、tcl、git, &lt;a href=&#34;http://pan.baidu.com/s/1dDhGMJ3&#34;&gt;windows版本的下载链接&lt;/a&gt;。
安装完成之后删除掉C:\Program Files (x86)\Git\bin下的perl和tcl(删除这一步一定要做，同时，
如果你的机器安装了MinGW或者Cygwin，请先将其从环境变量PATH中去除)。&lt;/p&gt;

&lt;p&gt;打开vs2013命令工具提示，进入源码目录，运行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;build DEBUG
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译过程会花很长时间，请耐心等待。完成后，就可以进行安装了。然后同目录下运行install命令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;install E:\Workspace\postgresql-9.4.0\dbtest
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;进入到dbtest目录，进行数据库的初始化:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bin\initdb.exe -D data -U postgres -W
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打开根目录下的psql.sln工程, 修改src\port\pg_config_paths.h&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#define PGBINDIR &amp;quot;/bin&amp;quot;
#define PGSHAREDIR &amp;quot;E:\\Workspace\\postgresql-9.4.0\\dbtest\\share&amp;quot;
#define SYSCONFDIR &amp;quot;/etc&amp;quot;
#define INCLUDEDIR &amp;quot;/include&amp;quot;
#define PKGINCLUDEDIR &amp;quot;/include&amp;quot;
#define INCLUDEDIRSERVER &amp;quot;/include/server&amp;quot;
#define LIBDIR &amp;quot;E:\\Workspace\\postgresql-9.4.0\\dbtest\\lib&amp;quot;
#define PKGLIBDIR &amp;quot;E:\\Workspace\\postgresql-9.4.0\\dbtest\\lib&amp;quot;
#define LOCALEDIR &amp;quot;/share/locale&amp;quot;
#define DOCDIR &amp;quot;/doc&amp;quot;
#define HTMLDIR &amp;quot;/doc&amp;quot;
#define MANDIR &amp;quot;/man&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改postgres项目的属性，添加命令参数：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;postgres.png&#34; alt=&#34;postgres属性&#34; /&gt;&lt;/p&gt;

&lt;p&gt;然后就可以使用postgres项目进行调试跟踪代码了。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>