<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Python on Sung Yung</title>
    <link>/tags/python/index.xml</link>
    <description>Recent content in Python on Sung Yung</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="/tags/python/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Python Week 0001 --- property</title>
      <link>/post/python-property/</link>
      <pubDate>Fri, 03 Mar 2017 19:10:15 +0800</pubDate>
      
      <guid>/post/python-property/</guid>
      <description>&lt;p&gt;博客搭了有好久了，都是断断续续的写，甚至大半年没有新的内容。已经掌握的或者是新学习的，没有记录一旦长时间不用就会忘掉，毕竟还没有形成本能。所以还是想记录一些东西吧。哈哈，其实还有个原因就是写了没人看哈，然后就没动力了。&lt;/p&gt;

&lt;p&gt;这个系列打算一周更新一篇。定位就是内容不一定多，尽量把东西讲清楚吧，按照为什么-是什么-怎么用的进行描述。&lt;/p&gt;

&lt;p&gt;那我们就开始吧，这篇主要是关于property。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;问题引出&#34;&gt;问题引出&lt;/h3&gt;

&lt;p&gt;我们一般对属性的的操作主要有2个，访问和修改。看个例子。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Person(object):
    def __init__(self, name):
        self.name = name

p = Person(&#39;Jack&#39;)
print p.name
p.name = &#39;Rose&#39;
print p.name

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们叫这种使用属性的方式叫点模式（我自己取得。。。），那么问题来了，如果我们想要修改属性的时候加入一个简单的类型检查，应该怎么做？&lt;/p&gt;

&lt;p&gt;很容易想到新增一个辅助方法来达成目标。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Person(object):
    def __init__(self, name):
        self.name = name
    
    def set_name(self, value):
        if not isinstance(value, str):
            raise TypeError(&#39;Expected a string&#39;)
        self.name = value
        
p = Person(&#39;Jack&#39;)
p.set_name(&#39;Rose&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们也看到了，这种方法虽然可以实现功能，但是使用起来不是很方便。所以我们会想有没有一种方法可以做到使用点模式的时候也能够做类型检查。&lt;/p&gt;

&lt;h3 id=&#34;解决方法&#34;&gt;解决方法&lt;/h3&gt;

&lt;p&gt;我们可以使用内置的property装饰器来实现。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Person(object):

    def __init__(self, name):
        self._name = name

    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, value):
        if not isinstance(value, basestring):
            raise TypeError(&#39;Expected a string&#39;)
        self._name = value

    @name.deleter
    def name(self):
        del self._name
        
p = Person(&#39;Jack&#39;)
p.name = &#39;Rose&#39;
p.name = 222
del p.name
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
&amp;lt;ipython-input-4-40579c6671bf&amp;gt; in &amp;lt;module&amp;gt;()
      1 p = Person(&#39;Jack&#39;)
      2 p.name = &#39;Rose&#39;
----&amp;gt; 3 p.name = 222

&amp;lt;ipython-input-3-335cb8c0ab8b&amp;gt; in name(self, value)
     14     def name(self, value):
     15         if not isinstance(value, str):
---&amp;gt; 16             raise TypeError(&#39;Expected a string&#39;)
     17         self._name = value
     18 

TypeError: Expected a string
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用起来真是so easy啊。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;虽然对外访问是name属性，但是内部有个实际存放值的属性_name。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;另外还有一种用法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Person(object):

    def __init__(self, name):
        self._name = name

    def get_name(self):
        return self._name

    def set_name(self, value):
        if not isinstance(value, str):
            raise TypeError(&#39;Expected a string&#39;)
        self._name = value

    def del_name(self):
        del self._name

    name = property(get_name, set_name, del_name)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们看看官方的代码注释，一目了然。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;quot;&amp;quot;&amp;quot;
property(fget=None, fset=None, fdel=None, doc=None) -&amp;gt; property attribute
        
fget is a function to be used for getting an attribute value, and likewise
fset is a function for setting, and fdel a function for del&#39;ing, an
attribute.  Typical use is to define a managed attribute x:
        
class C(object):
    def getx(self): return self._x
    def setx(self, value): self._x = value
    def delx(self): del self._x
    x = property(getx, setx, delx, &amp;quot;I&#39;m the &#39;x&#39; property.&amp;quot;)
        
Decorators make defining new properties or modifying existing ones easy:
        
class C(object):
    @property
    def x(self):
        &amp;quot;I am the &#39;x&#39; property.&amp;quot;
        return self._x
    @x.setter
    def x(self, value):
        self._x = value
    @x.deleter
    def x(self):
        del self._x
&amp;quot;&amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以后当我们遇到设置属性的时候需要额外逻辑的时候，就可以考虑使用property了。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Pythons HOWTO之属性描述符</title>
      <link>/post/python-howto-descriptor/</link>
      <pubDate>Sat, 08 Aug 2015 22:27:41 +0800</pubDate>
      
      <guid>/post/python-howto-descriptor/</guid>
      <description>&lt;p&gt;今天开个新坑，Pythons HOWTOS系列，主要是对官方文档的翻译。由于英语水平有限，基本上都是意译。这里附上&lt;a href=&#34;https://docs.python.org/2.7/howto/index.html&#34;&gt;链接&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;本篇是第一篇，主要说的是&lt;a href=&#34;https://docs.python.org/2.7/howto/descriptor.html#id2&#34;&gt;属性描述符&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;摘要&#34;&gt;摘要&lt;/h2&gt;

&lt;p&gt;本篇的内容主要是定义属性描述符(descriptor)，概述一下描述符协议的内容。通过自定义的的一个描述符和Python内建的描述符(functions, properties, static methods, class methods)来演示属性描述符是如何调用的。同时会给出相同功能的Python实现代码和一个简单的程序。&lt;/p&gt;

&lt;p&gt;属性描述符不仅给一个大的工具集(暂时没发现是什么)提供了接口，它还能加深理解Python的工作原理和优雅的设计思想。&lt;/p&gt;

&lt;h2 id=&#34;定义和介绍&#34;&gt;定义和介绍&lt;/h2&gt;

&lt;p&gt;一般来说，一个描述符是一个有“绑定行为”的对象属性，这个属性访问被描述符协议中的方法所覆盖。这些方法是__get__()，__set__()和__delete__()。如果某个对象定义了其中一个，那么这个对象就可以被叫做描述符。&lt;/p&gt;

&lt;p&gt;访问属性默认通过get，set或者是delete来操作对象属性字典来实现。例如，a.x有一个查找队列，从a.__dict__[&amp;lsquo;x&amp;rsquo;]开始，然后是type(a).__dict__[&amp;lsquo;x&amp;rsquo;]，接着是type(a)的基类(metaclass除外)，以此类推。如果查找的是一个定义了描述符方法的对象，那么Python会覆盖默认行为而去调用描述符方法。发生在优先级队列的哪个位置取决于定义的描述符方法。注意，属性描述符只适用于新式类(从object或者typ继承的类)。&lt;/p&gt;

&lt;p&gt;属性描述符是一个强大的通用协议。它是properties, methods, static methods, class methods 和super()的调用原理。它贯穿整个Python，并且用来实现2.2版本中引进的新式类。属性描述符简化了底层的C代码，还为日常Python编程提供了新的工具集。&lt;/p&gt;

&lt;h2 id=&#34;描述符协议&#34;&gt;描述符协议&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;descr.__get__(self, obj, type=None) --&amp;gt; value

descr.__set__(self, obj, value) --&amp;gt; None

descr.__delete__(self, obj) --&amp;gt; None
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的三个方法就是协议的全部内容了。定义其中任意一个方法的对象就被称为属性描述符，能够覆盖默认的属性查找规则。&lt;/p&gt;

&lt;p&gt;如果一个对象同时定义了__get__和__set__方法，它被称做数据描述符(data descriptor)。只定义__get__方法的对象则被称为非数据描述符(non-data descriptor，一般用在函数方法上，其他用法也是可能的)。&lt;/p&gt;

&lt;p&gt;数据和非数据描述符的区别在于如果某个实例属性字典中有项和描述符同名，那么属性访问的优先级是不同的。数据描述符的优先级比实例字典中项的高，非数据描述符则相反。&lt;/p&gt;

&lt;p&gt;举个例子说明一下优先级问题:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class DataDesc(object):

    def __init__(self, name=None):
        self.name = name
        self.value = None

    def __get__(self, obj, type=None):
        return self.value

    def __set__(self, obj, value):
        self.value = value


class NonDataDesc(object):

    def __init__(self, name=None):
        self.name = name
        self.value = None

    def __get__(self, obj, type=None):
        return self.value


class DataTest(object):
    x = DataDesc()


class NonDataTest(object):
    x = NonDataDesc()

&amp;gt;&amp;gt;&amp;gt; d = DataTest()
&amp;gt;&amp;gt;&amp;gt; nd = NonDataTest()
&amp;gt;&amp;gt;&amp;gt; d.__dict__[&#39;x&#39;] = 2
&amp;gt;&amp;gt;&amp;gt; nd.__dict__[&#39;x&#39;] = 2
&amp;gt;&amp;gt;&amp;gt; print d.__dict__, nd.__dict__
{&#39;x&#39;: 2} {&#39;x&#39;: 2}
&amp;gt;&amp;gt;&amp;gt; print d.x, nd.x
None 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果想要构造一个只读的数据描述符，同时定义__get__和__set__方法，并且__set__调用时引发一个AtrributeError异常。&lt;/p&gt;

&lt;h2 id=&#34;属性描述符调用&#34;&gt;属性描述符调用&lt;/h2&gt;

&lt;p&gt;一个属性描述符可以通过它的方法名直接调用。比如，d.__get__(obj)。更常见的方式是通过属性访问自动调用。比如，obj.d在obj的字典中查找d。如果d定义了__get__()，那么根据下文将要提到的优先级规则，d.__get__(obj)将会被调用。&lt;/p&gt;

&lt;p&gt;调用的细节由obj是对象还是类来决定。&lt;/p&gt;

&lt;p&gt;对于对象，访问是调用object.__getattribute__()，其中将b.x转换成type(b).__dict__[&amp;lsquo;x&amp;rsquo;].__get__(b, type(b))。在实现中，数据描述符优先级最高，依次是实例变量，非数据描述符，最后是__getattr__()(如果定义了)。C实现能够在&lt;a href=&#34;https://hg.python.org/cpython/file/2.7/Objects/object.c&#34;&gt;Objects/object.c&lt;/a&gt;中的&lt;a href=&#34;https://docs.python.org/2.7/c-api/object.html#c.PyObject_GenericGetAttr&#34;&gt;PyObject_GenericGetAttr()&lt;/a&gt;找到。&lt;/p&gt;

&lt;p&gt;对于类，访问是调用type.__getattribute__()，其中将B.x转换成B.__[&amp;lsquo;x&amp;rsquo;].__get__(None, B)。如果用Python实现，它是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def __getattribute__(self, key):
    &amp;quot;Emulate type_getattro() in Objects/typeobject.c&amp;quot;
    v = object.__getattribute__(self, key)
    if hasattr(v, &#39;__get__&#39;):
       return v.__get__(None, self)
    return v
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要记住下面几个重要的点:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;描述符通过__getattribute__()被调用&lt;/li&gt;
&lt;li&gt;重写__getattribute__()能够改变自动的调用&lt;/li&gt;
&lt;li&gt;__getattribute__()只适用于新式类&lt;/li&gt;
&lt;li&gt;object.__getattribute__()和type.__getattribute__()调用__get__()的方式不同&lt;/li&gt;
&lt;li&gt;数据描述符总是覆盖实例字典&lt;/li&gt;
&lt;li&gt;非数据描述符可能被实例字典覆盖&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;super()返回的对象有一个自定义的__getattribute__()。调用super(B, obj).m()在obj.__class__.__mro__查找到紧跟在B后面的基类A，然后返回A.__dict__[&amp;rsquo;m&amp;rsquo;].__get__(obj, B)。如果不是一个描述符，m被原封不动的返回。如果不在字典中，m转而去调用object.__getattribute__()查找。&lt;/p&gt;

&lt;p&gt;注意，在Python2.2中，运行super(B, obj).m()时，如果m是一个数据描述符，将会只调用__get__()。在Python2.3中，除了是旧式类，非数据描述符也会得到调用。具体实现在&lt;a href=&#34;https://hg.python.org/cpython/file/2.7/Objects/typeobject.c&#34;&gt;Objects/typeobject.c&lt;/a&gt;的super_getattro()中。&lt;/p&gt;

&lt;p&gt;综上所述，描述符机制嵌入到了object、type和super()的__getattribute__()方法中。如果类需要这个机制，必须继承自object或者是有metaclass提供类似的功能。同样的，也可以通过重写__getattribute__()来改变属性描述符。&lt;/p&gt;

&lt;h2 id=&#34;属性描述符示例&#34;&gt;属性描述符示例&lt;/h2&gt;

&lt;p&gt;下面的代码创建了一个类，它的实例对象是数据描述符，get和set方法中都打印了一条信息。重写__getattribute__()方法也可以做到这个。但是，使用描述符对监控一些属性很有用：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class RevealAccess(object):
    &amp;quot;&amp;quot;&amp;quot;A data descriptor that sets and returns values
       normally and prints a message logging their access.
    &amp;quot;&amp;quot;&amp;quot;

    def __init__(self, initval=None, name=&#39;var&#39;):
        self.val = initval
        self.name = name

    def __get__(self, obj, objtype):
        print &#39;Retrieving&#39;, self.name
        return self.val

    def __set__(self, obj, val):
        print &#39;Updating&#39;, self.name
        self.val = val

&amp;gt;&amp;gt;&amp;gt; class MyClass(object):
    x = RevealAccess(10, &#39;var &amp;quot;x&amp;quot;&#39;)
    y = 5

&amp;gt;&amp;gt;&amp;gt; m = MyClass()
&amp;gt;&amp;gt;&amp;gt; m.x
Retrieving var &amp;quot;x&amp;quot;
10
&amp;gt;&amp;gt;&amp;gt; m.x = 20
Updating var &amp;quot;x&amp;quot;
&amp;gt;&amp;gt;&amp;gt; m.x
Retrieving var &amp;quot;x&amp;quot;
20
&amp;gt;&amp;gt;&amp;gt; m.y
5
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;properties&#34;&gt;Properties&lt;/h2&gt;

&lt;p&gt;使用property()能够把数据描述符变成属性调用。形式如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;property(fget=None, fset=None, fdel=None, doc=None) -&amp;gt; property attribute
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一个典型的用法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class C(object):
    def getx(self): return self.__x
    def setx(self, value): self.__x = value
    def delx(self): del self.__x
    x = property(getx, setx, delx, &amp;quot;I&#39;m the &#39;x&#39; property.&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以使用装饰器:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class C(object):
  @property
  def x(self):
    return self.__x

  @x.setter
  def setx(self, value):
    self.__x = value

  @x.deleter
  del delx(self):
    self.__x

&amp;gt;&amp;gt;&amp;gt; c = C()
&amp;gt;&amp;gt;&amp;gt; c.x = 2
&amp;gt;&amp;gt;&amp;gt; c.x
2
&amp;gt;&amp;gt;&amp;gt; del c.x
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;proptery()是C实现的，我们这里给出Python版本的等价实现：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Property(object):
    &amp;quot;Emulate PyProperty_Type() in Objects/descrobject.c&amp;quot;

    def __init__(self, fget=None, fset=None, fdel=None, doc=None):
        self.fget = fget
        self.fset = fset
        self.fdel = fdel
        if doc is None and fget is not None:
            doc = fget.__doc__
        self.__doc__ = doc

    def __get__(self, obj, objtype=None):
        if obj is None:
            return self
        if self.fget is None:
            raise AttributeError(&amp;quot;unreadable attribute&amp;quot;)
        return self.fget(obj)

    def __set__(self, obj, value):
        if self.fset is None:
            raise AttributeError(&amp;quot;can&#39;t set attribute&amp;quot;)
        self.fset(obj, value)

    def __delete__(self, obj):
        if self.fdel is None:
            raise AttributeError(&amp;quot;can&#39;t delete attribute&amp;quot;)
        self.fdel(obj)

    def getter(self, fget):
        return type(self)(fget, self.fset, self.fdel, self.__doc__)

    def setter(self, fset):
        return type(self)(self.fget, fset, self.fdel, self.__doc__)

    def deleter(self, fdel):
        return type(self)(self.fget, self.fset, fdel, self.__doc__)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一个电子表格类可能通过Cell(&amp;lsquo;b10&amp;rsquo;).value访问某个单元，后面希望改进成每次访问都重新计算。但是开发者不想直接改变现有的属性访问代码。那么便可以用proptery数据描述符封装属性访问。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Cell(object):
    . . .
    def getvalue(self, obj):
        &amp;quot;Recalculate cell before returning value&amp;quot;
        self.recalc()
        return obj._value
    value = property(getvalue)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;functions-and-methods&#34;&gt;Functions and methods&lt;/h2&gt;

&lt;p&gt;Python的面向对象特征是建立在基于函数的环境上。使用非数据描述符，两者能够无缝融合。&lt;/p&gt;

&lt;p&gt;类字典中用函数(function)形式存储方法(method)。在类的定义中，用def和lambda定义方法，这也是定义函数的方式。方法和普通函数唯一的区别是方法的第一个参数预留给了对象实例。按照Python的惯例，实例引用一般用self表示，当然也有可能用this或者其他变量表示。&lt;/p&gt;

&lt;p&gt;为了支持方法调用，函数中包含了__get__()属性。这意味着，所有的函数都是非数据描述符。对象和类的方法，__get__()返回值是不同的，分别绑定(bound)和非绑定(unbound)方法。如果用纯Python表示，可能是这样的:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Function(object):
    . . .
    def __get__(self, obj, objtype=None):
        &amp;quot;Simulate func_descr_get() in Objects/funcobject.c&amp;quot;
        return types.MethodType(self, obj, objtype)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; class D(object):
     def f(self, x):
          return x

&amp;gt;&amp;gt;&amp;gt; d = D()
&amp;gt;&amp;gt;&amp;gt; D.__dict__[&#39;f&#39;] # Stored internally as a function
&amp;lt;function f at 0x00C45070&amp;gt;
&amp;gt;&amp;gt;&amp;gt; D.f             # Get from a class becomes an unbound method
&amp;lt;unbound method D.f&amp;gt;
&amp;gt;&amp;gt;&amp;gt; d.f             # Get from an instance becomes a bound method
&amp;lt;bound method D.f of &amp;lt;__main__.D object at 0x00B18C90&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;bound和unbound方法是两个不同的类型。C实现中只是一个相同的对象的两种不同表现，区别就在于im_self被设置了或者是NULL值，具体实现位于&lt;a href=&#34;https://hg.python.org/cpython/file/2.7/Objects/classobject.c&#34;&gt;Objects/classobject.c&lt;/a&gt;中&lt;a href=&#34;https://docs.python.org/2.7/c-api/method.html#c.PyMethod_Type&#34;&gt;PyMethod_Type&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;同样地，调用方法时有没有im_self效果是不同的。如果被设置了，表明是bound方法，原始函数(存在im_func中)被调用，当然第一个参数被设置成对象实例。如果是unbound方法，所有参数原封不动地传给原始函数。C实现instancemethod_call()会更加复杂，因为有很多类型检测。&lt;/p&gt;

&lt;h2 id=&#34;static-methods-and-class-methods&#34;&gt;Static methods and class methods&lt;/h2&gt;

&lt;p&gt;函数有__get__()属性，所以当它们被当成属性访问时会被转变成方法。非数据描述符将obj.f(*args)转换成了f(obj, *args)。调用klass.f(*args)变成了f(*args)。&lt;/p&gt;

&lt;p&gt;下面这个表格总结了这转变方式，以及两个变种staticmethod和classmethod。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Transformation&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Called from an Object&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Called from a Class&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;function&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;f(obj, *args)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;f(*args)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;staticmethod&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;f(*args)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;f(*args)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;classmethod&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;f(type(obj), *args)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;f(klass, *args)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;静态方法没有对函数做任何改变。调用c.f等价于object.__getattribute__(c, &amp;ldquo;f&amp;rdquo;)，调C.f等于object.__getattribute__(C, &amp;ldquo;f&amp;rdquo;)。所以，对象和类对静态方法的调用方式是统一的。静态方法不需要self。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; class E(object):
     def f(x):
          print x
     f = staticmethod(f)

&amp;gt;&amp;gt;&amp;gt; print E.f(3)
3
&amp;gt;&amp;gt;&amp;gt; print E().f(3)
3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;纯Pythond的staticmethod()实现可能是这样的:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class StaticMethod(object):
 &amp;quot;Emulate PyStaticMethod_Type() in Objects/funcobject.c&amp;quot;

 def __init__(self, f):
      self.f = f

 def __get__(self, obj, objtype=None):
      return self.f
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而类方法的第一个参数是类的引用。也是分为对象调用和类调用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; class E(object):
     def f(klass, x):
          return klass.__name__, x
     f = classmethod(f)

&amp;gt;&amp;gt;&amp;gt; print E.f(3)
(&#39;E&#39;, 3)
&amp;gt;&amp;gt;&amp;gt; print E().f(3)
(&#39;E&#39;, 3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果函数只需要类引用而不关心底层的数据，那么类方法就会很有用。一个使用classmethod的例子是创建类构造器。在Python2.3中dict.fromkeys()从关键字列表中创建一个新的字典。纯Python可能是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Dict(object):
    . . .
    def fromkeys(klass, iterable, value=None):
        &amp;quot;Emulate dict_fromkeys() in Objects/dictobject.c&amp;quot;
        d = klass()
        for key in iterable:
            d[key] = value
        return d
    fromkeys = classmethod(fromkeys)

&amp;gt;&amp;gt;&amp;gt; Dict.fromkeys(&#39;abracadabra&#39;)
{&#39;a&#39;: None, &#39;r&#39;: None, &#39;b&#39;: None, &#39;c&#39;: None, &#39;d&#39;: None}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;classmethod的纯Python实现可能是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class ClassMethod(object):
     &amp;quot;Emulate PyClassMethod_Type() in Objects/funcobject.c&amp;quot;

     def __init__(self, f):
          self.f = f

     def __get__(self, obj, klass=None):
          if klass is None:
               klass = type(obj)
          def newfunc(*args):
               return self.f(klass, *args)
          return newfunc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;终于结束了，这篇断断续续的翻译了好几天，几次都想放弃了，但还是忍着翻译了下来，算是收获了许多。学习是没有捷径的。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Python装饰器的几种类型</title>
      <link>/post/python-decorate/</link>
      <pubDate>Mon, 27 Jul 2015 22:25:34 +0800</pubDate>
      
      <guid>/post/python-decorate/</guid>
      <description>&lt;p&gt;装饰器的原理就是闭包，这在&lt;a href=&#34;/post/python-bibao/&#34;&gt;前面&lt;/a&gt;已经提到过了。本篇主要记录一下装饰器的几种类型。&lt;/p&gt;

&lt;h2 id=&#34;无参数装饰器&#34;&gt;无参数装饰器&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def deco(func):
    def _deco(*args, **kwargs):
        print &#39;call deco&#39;
        func(*args, **kwargs)
    return _deco

@deco
def test():
    print &#39;call test&#39;

# 等同于
def test():
    print &#39;call test&#39;
test = deco(func)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;有参数装饰器&#34;&gt;有参数装饰器&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def deco(*args, **kwargs):
    def _deco(func):
        print args, kwargs
        def __deco(*args, **kwargs):
            print &#39;call deco&#39;
            func(*args, **kwargs)
        return __deco
    return _deco

@deco(&#39;hello&#39;, x=&#39;nihao&#39;)
def test():
    print &#39;call test&#39;

# 等同于
def test():
    print &#39;call test&#39;
test = deco(&#39;hello&#39;, x=&#39;nihao&#39;)(test)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;类装饰器&#34;&gt;类装饰器&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def deco(*args, **kwargs):
    def _deco(cls):
        cls.x = 12
        return cls
    return _deco

@deco(&#39;hello&#39;)
class A(object):
    pass

&amp;gt;&amp;gt;&amp;gt; A.x
12

# 等同于
class A(object):
    pass
A = deco(&#39;hello&#39;)(A)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;装饰器类&#34;&gt;装饰器类&lt;/h2&gt;

&lt;p&gt;类作为装饰器，分为有参数和无参数。同时，需要装饰的是类方法时，需要用到&lt;strong&gt;get&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&#34;无参数&#34;&gt;无参数&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Deco(object):
    def __init__(self, func):
        self.func = func

    def __call__(self, *args, **kwargs):
        print &#39;call Deco&#39;
        self.func(*args, **kwargs)

@Deco
def test():
    print &#39;call test&#39;

# 等同于
test = Deco(test)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;有参数&#34;&gt;有参数&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Deco(object):
    def __init__(self, *args, **kwargs):
        print args, kwargs

    def __call__(self, func):
        def _deco(*args, **kwargs):
            print &#39;call Deco&#39;
            func(*args, **kwargs)
        return _deco

@Deco(&#39;hello&#39;)
def test():
    print &#39;call test&#39;

# 等同于
test = Deco(&#39;hello&#39;)(func)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;装饰类方法&#34;&gt;装饰类方法&lt;/h3&gt;

&lt;h4 id=&#34;无参数-1&#34;&gt;无参数&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Deco(object):
    def __init__(self, func):
        self.func = func

    def __get__(self, instance, owner):
        def _deco(*args, **kwargs):
            print &#39;call Deco&#39;
            self.func(instance, *args, **kwargs)
        return _deco

class A(object):
    @Deco
    def test(self):
        print &#39;call test&#39;

# 等同于
class A(object):

    def test(self):
        print &#39;call test&#39;
    test = Deco(test)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;有参数-1&#34;&gt;有参数&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Deco(object):
    def __init__(self, *args, **kwargs):
        print args, kwargs

    def __get__(self, instance, owner):
        def _deco(*args, **kwargs):
            print &#39;call Deco&#39;
            self.func(instance, *args, **kwargs)
        return _deco

    def __call__(self, func):
        self.func = func
        return self

class A(object):

    @Deco(&#39;hello&#39;)
    def test(self):
        print &#39;call test&#39;

# 等同于
class A(object):

    def test(self):
        print &#39;call test&#39;
    test = Deco(&#39;hello&#39;)(test)
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Python闭包的作用域理解</title>
      <link>/post/python-bibao/</link>
      <pubDate>Wed, 22 Jul 2015 22:23:31 +0800</pubDate>
      
      <guid>/post/python-bibao/</guid>
      <description>&lt;h2 id=&#34;什么是闭包&#34;&gt;什么是闭包&lt;/h2&gt;

&lt;p&gt;在维基中，闭包的解释是这样的：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;在计算机科学中，闭包（Closure）是词法闭包（Lexical Closure）的简称，是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。所以，有另一种说法认为闭包是由函数和与其相关的引用环境组合而成的实体。闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;我们来看一个简单的实例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def outer(arg):
    def inner():
        print arg * arg
    return inner

&amp;gt;&amp;gt;&amp;gt; f = outer(2)
&amp;gt;&amp;gt;&amp;gt; f()
4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;内部函数inner调用外部函数outer的局部变量arg，它保存了outer的arg值。这就是闭包。&lt;/p&gt;

&lt;h2 id=&#34;从作用域的角度理解&#34;&gt;从作用域的角度理解&lt;/h2&gt;

&lt;p&gt;把上面的例子改一下，在函数内部输出局部命名空间:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def outer(arg):
    print locals()
    def inner():
        x = arg * arg
        print locals()
        print x
    return inner

&amp;gt;&amp;gt;&amp;gt; f = outer(2)
{&#39;arg&#39;: 2}
&amp;gt;&amp;gt;&amp;gt; f()
{&#39;x&#39;: 4, &#39;arg&#39;: 2}
4
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在outer中，局部命名空间只有一个键arg，而在inner内部也有arg。上面说的inner保存了outer的arg值，我们就可以理解为inner的局部命名空间保存了arg。&lt;/p&gt;

&lt;p&gt;这么一理解，就会发现闭包其实就这么简单。&lt;/p&gt;

&lt;p&gt;另外再瞎扯一句，python中的装饰器其实就是闭包。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Twisted源码分析系列01-reactor</title>
      <link>/post/python-twisted01/</link>
      <pubDate>Tue, 14 Jul 2015 22:22:03 +0800</pubDate>
      
      <guid>/post/python-twisted01/</guid>
      <description>&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;

&lt;p&gt;Twisted是用Python实现的事件驱动的网络框架。&lt;/p&gt;

&lt;p&gt;如果想看教程的话，我觉得写得最好的就是&lt;a href=&#34;http://krondo.com/?page_id=1327&#34;&gt;Twisted Introduction&lt;/a&gt;了，这是&lt;a href=&#34;https://github.com/syfun/twisted-intro-cn&#34;&gt;翻译&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;下面就直接进入主题了。&lt;/p&gt;

&lt;p&gt;我们通过一个示例开始分析源码，那么先看下面这个示例。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python
# coding=utf8

from twisted.internet.protocol import Protocol, ServerFactory


HOST = &#39;127.0.0.1&#39;
PORT = 8080


class EchoProtocol(Protocol):

    def dataReceived(self, data):
        self.transport.write(data)


if __name__ == &#39;__main__&#39;:
    factory = ServerFactory()
    factory.protocol = EchoProtocol

    from twisted.internet import reactor
    reactor.listenTCP(PORT, factory, interface=HOST)
    reactor.run()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是一个非常简单的Echo server，每当有数据发来，都会将数据往回发。&lt;/p&gt;

&lt;h2 id=&#34;reactor&#34;&gt;reactor&lt;/h2&gt;

&lt;p&gt;reactor是事件管理器，用于注册、注销事件，运行事件循环，当事件发生时调用回调函数处理。关于reactor有下面几个结论:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Twisted的reactor只有通过调用reactor.run()来启动。&lt;/li&gt;
&lt;li&gt;reactor循环是在其开始的进程中运行，也就是运行在主进程中。&lt;/li&gt;
&lt;li&gt;一旦启动，就会一直运行下去。reactor就会在程序的控制下（或者具体在一个启动它的线程的控制下）。&lt;/li&gt;
&lt;li&gt;reactor循环并不会消耗任何CPU的资源。&lt;/li&gt;
&lt;li&gt;并不需要显式的创建reactor，只需要引入就OK了。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最后一条需要解释清楚。在Twisted中，reactor是Singleton（也就是单例模式），即在一个程序中只能有一个reactor，并且只要你引入它就相应地创建一个。上面引入的方式这是twisted默认使用的方法，当然了，twisted还有其它可以引入reactor的方法。例如，可以使用twisted.internet.pollreactor中的系统调用来poll来代替select方法。
若使用其它的reactor，需要在引入twisted.internet.reactor前安装它。下面是安装pollreactor的方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from twisted.internet import pollreactor
pollreactor.install()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你没有安装其它特殊的reactor而引入了twisted.internet.reactor，那么Twisted会根据操作系统安装默认的reactor。正因为如此，习惯性做法不要在最顶层的模块内引入reactor以避免安装默认reactor，而是在你要使用reactor的区域内安装。
下面是使用 pollreactor重写上上面的程序:tho&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from twited.internet import pollreactor
pollreactor.install()
from twisted.internet import reactor
reactor.run()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么reactor是如何实现单例的？来看一下from twisted.internet import reactor做了哪些事情就并明白了。&lt;/p&gt;

&lt;p&gt;下面是twisted/internet/reactor.py的部分代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# twisted/internet/reactor.py
import sys
del sys.modules[&#39;twisted.internet.reactor&#39;]
from twisted.internet import default
default.install()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注：Python中所有加载到内存的模块都放在sys.modules，它是一个全局字典。当import一个模块时首先会在这个列表中查找是否已经加载了此模块，如果加载了则只是将模块的名字加入到正在调用import的模块的命名空间中。如果没有加载则从sys.path目录中按照模块名称查找模块文件，找到后将模块载入内存，并加入到sys.modules中，并将名称导入到当前的命名空间中。&lt;/p&gt;

&lt;p&gt;假如我们是第一次运行from twisted.internet import reactor，因为sys.modules中还没有twisted.internet.reactor，所以会运行reactory.py中的代码，安装默认的reactor。之后，如果导入的话，因为sys.modules中已存在该模块，所以会直接将sys.modules中的twisted.internet.reactor导入到当前命名空间。&lt;/p&gt;

&lt;p&gt;default中的install：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# twisted/internet/default.py
def _getInstallFunction(platform):
    &amp;quot;&amp;quot;&amp;quot;
    Return a function to install the reactor most suited for the given platform.

    @param platform: The platform for which to select a reactor.
    @type platform: L{twisted.python.runtime.Platform}

    @return: A zero-argument callable which will install the selected
        reactor.
    &amp;quot;&amp;quot;&amp;quot;
    try:
        if platform.isLinux():
            try:
                from twisted.internet.epollreactor import install
            except ImportError:
                from twisted.internet.pollreactor import install
        elif platform.getType() == &#39;posix&#39; and not platform.isMacOSX():
            from twisted.internet.pollreactor import install
        else:
            from twisted.internet.selectreactor import install
    except ImportError:
        from twisted.internet.selectreactor import install
    return install


install = _getInstallFunction(platform)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;很明显，default中会根据平台获取相应的install。Linux下会首先使用epollreactor，如果内核还不支持，就只能使用pollreactor。Mac平台使用pollreactor，windows使用selectreactor。每种install的实现差不多，这里我们抽取selectreactor中的install来看看。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# twisted/internet/selectreactor.py：
def install():
    &amp;quot;&amp;quot;&amp;quot;Configure the twisted mainloop to be run using the select() reactor.
    &amp;quot;&amp;quot;&amp;quot;
    # 单例
    reactor = SelectReactor()
    from twisted.internet.main import installReactor
    installReactor(reactor)

# twisted/internet/main.py：
def installReactor(reactor):
    &amp;quot;&amp;quot;&amp;quot;
    Install reactor C{reactor}.

    @param reactor: An object that provides one or more IReactor* interfaces.
    &amp;quot;&amp;quot;&amp;quot;
    # this stuff should be common to all reactors.
    import twisted.internet
    import sys
    if &#39;twisted.internet.reactor&#39; in sys.modules:
        raise error.ReactorAlreadyInstalledError(&amp;quot;reactor already installed&amp;quot;)
    twisted.internet.reactor = reactor
    sys.modules[&#39;twisted.internet.reactor&#39;] = reactor
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在installReactor中，向sys.modules添加twisted.internet.reactor键，值就是再install中创建的单例reactor。以后要使用reactor，就会导入这个单例了。&lt;/p&gt;

&lt;h2 id=&#34;selectreactor&#34;&gt;SelectReactor&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# twisted/internet/selectreactor.py
@implementer(IReactorFDSet)
class SelectReactor(posixbase.PosixReactorBase, _extraBase)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;implementer表示SelectReactor实现了IReactorFDSet接口的方法，这里用到了&lt;a href=&#34;http://docs.zope.org/zope.interface/&#34;&gt;zope.interface&lt;/a&gt;，它是python中的接口实现，有兴趣的同学可以去看下。&lt;/p&gt;

&lt;p&gt;IReactorFDSet接口主要对描述符的获取、添加、删除等操作的方法。这些方法看名字就能知道意思，所以我就没有加注释。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# twisted/internet/interfaces.py
class IReactorFDSet(Interface):

    def addReader(reader):

    def addWriter(writer):

    def removeReader(reader):

    def removeWriter(writer):

    def removeAll():

    def getReaders():

    def getWriters():

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;reactor-listentcp&#34;&gt;reactor.listenTCP()&lt;/h3&gt;

&lt;p&gt;示例中的reactor.listenTCP()注册了一个监听事件，它是父类PosixReactorBase中方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# twisted/internet/posixbase.py
@implementer(IReactorTCP, IReactorUDP, IReactorMulticast)
class PosixReactorBase(_SignalReactorMixin, _DisconnectSelectableMixin,
                       ReactorBase):

    def listenTCP(self, port, factory, backlog=50, interface=&#39;&#39;):
        p = tcp.Port(port, factory, backlog, interface, self)
        p.startListening()
        return p

# twisted/internet/tcp.py
@implementer(interfaces.IListeningPort)
class Port(base.BasePort, _SocketCloser):
    def __init__(self, port, factory, backlog=50, interface=&#39;&#39;, reactor=None):
       &amp;quot;&amp;quot;&amp;quot;Initialize with a numeric port to listen on.
       &amp;quot;&amp;quot;&amp;quot;
       base.BasePort.__init__(self, reactor=reactor)
       self.port = port
       self.factory = factory
       self.backlog = backlog
       if abstract.isIPv6Address(interface):
           self.addressFamily = socket.AF_INET6
           self._addressType = address.IPv6Address
       self.interface = interface
    ...

    def startListening(self):
       &amp;quot;&amp;quot;&amp;quot;Create and bind my socket, and begin listening on it.
          创建并绑定套接字，开始监听。

       This is called on unserialization, and must be called after creating a
       server to begin listening on the specified port.
       &amp;quot;&amp;quot;&amp;quot;
       if self._preexistingSocket is None:
           # Create a new socket and make it listen
           try:
               # 创建套接字
               skt = self.createInternetSocket()
               if self.addressFamily == socket.AF_INET6:
                   addr = _resolveIPv6(self.interface, self.port)
               else:
                   addr = (self.interface, self.port)
               # 绑定
               skt.bind(addr)
           except socket.error as le:
               raise CannotListenError(self.interface, self.port, le)
           # 监听
           skt.listen(self.backlog)
       else:
           # Re-use the externally specified socket
           skt = self._preexistingSocket
           self._preexistingSocket = None
           # Avoid shutting it down at the end.
           self._shouldShutdown = False

       # Make sure that if we listened on port 0, we update that to
       # reflect what the OS actually assigned us.
       self._realPortNumber = skt.getsockname()[1]

       log.msg(&amp;quot;%s starting on %s&amp;quot; % (
               self._getLogPrefix(self.factory), self._realPortNumber))

       # The order of the next 5 lines is kind of bizarre.  If no one
       # can explain it, perhaps we should re-arrange them.
       self.factory.doStart()
       self.connected = True
       self.socket = skt
       self.fileno = self.socket.fileno
       self.numberAccepts = 100

       # startReading调用reactor的addReader方法将Port加入读集合
       self.startReading()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;整个逻辑很简单，和正常的server端一样，创建套接字、绑定、监听。不同的是将套接字的描述符添加到了reactor的读集合。那么假如有了client连接过来的话，reactor会监控到，然后触发事件处理程序。&lt;/p&gt;

&lt;h2 id=&#34;reacotr-run-事件主循环&#34;&gt;reacotr.run()事件主循环&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# twisted/internet/posixbase.py
@implementer(IReactorTCP, IReactorUDP, IReactorMulticast)
class PosixReactorBase(_SignalReactorMixin, _DisconnectSelectableMixin,
                       ReactorBase)

# twisted/internet/base.py
class _SignalReactorMixin(object):

    def startRunning(self, installSignalHandlers=True):
        &amp;quot;&amp;quot;&amp;quot;
        PosixReactorBase的父类_SignalReactorMixin和ReactorBase都有该函数，但是
        _SignalReactorMixin在前，安装mro顺序的话，会先调用_SignalReactorMixin中的。
        &amp;quot;&amp;quot;&amp;quot;
        self._installSignalHandlers = installSignalHandlers
        ReactorBase.startRunning(self)

    def run(self, installSignalHandlers=True):
        self.startRunning(installSignalHandlers=installSignalHandlers)
        self.mainLoop()

    def mainLoop(self):
        while self._started:
            try:
                while self._started:
                    # Advance simulation time in delayed event
                    # processors.
                    self.runUntilCurrent()
                    t2 = self.timeout()
                    t = self.running and t2
                    # doIteration是关键，select,poll,epool实现各有不同
                    self.doIteration(t)
            except:
                log.msg(&amp;quot;Unexpected error in main loop.&amp;quot;)
                log.err()
            else:
                log.msg(&#39;Main loop terminated.&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mianLoop就是最终的主循环了，在循环中，调用doIteration方法监控读写描述符的集合，一旦发现有描述符准备好读写，就会调用相应的事件处理程序。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# twisted/internet/selectreactor.py
@implementer(IReactorFDSet)
class SelectReactor(posixbase.PosixReactorBase, _extraBase):

    def __init__(self):
        &amp;quot;&amp;quot;&amp;quot;
        Initialize file descriptor tracking dictionaries and the base class.
        &amp;quot;&amp;quot;&amp;quot;
        self._reads = set()
        self._writes = set()
        posixbase.PosixReactorBase.__init__(self)

    def doSelect(self, timeout):
        &amp;quot;&amp;quot;&amp;quot;
        Run one iteration of the I/O monitor loop.

        This will run all selectables who had input or output readiness
        waiting for them.
        &amp;quot;&amp;quot;&amp;quot;
        try:
            # 调用select方法监控读写集合，返回准备好读写的描述符
            r, w, ignored = _select(self._reads,
                                    self._writes,
                                    [], timeout)
        except ValueError:
            # Possibly a file descriptor has gone negative?
            self._preenDescriptors()
            return
        except TypeError:
            # Something *totally* invalid (object w/o fileno, non-integral
            # result) was passed
            log.err()
            self._preenDescriptors()
            return
        except (select.error, socket.error, IOError) as se:
            # select(2) encountered an error, perhaps while calling the fileno()
            # method of a socket.  (Python 2.6 socket.error is an IOError
            # subclass, but on Python 2.5 and earlier it is not.)
            if se.args[0] in (0, 2):
                # windows does this if it got an empty list
                if (not self._reads) and (not self._writes):
                    return
                else:
                    raise
            elif se.args[0] == EINTR:
                return
            elif se.args[0] == EBADF:
                self._preenDescriptors()
                return
            else:
                # OK, I really don&#39;t know what&#39;s going on.  Blow up.
                raise

        _drdw = self._doReadOrWrite
        _logrun = log.callWithLogger
        for selectables, method, fdset in ((r, &amp;quot;doRead&amp;quot;, self._reads),
                                           (w,&amp;quot;doWrite&amp;quot;, self._writes)):
            for selectable in selectables:
                # if this was disconnected in another thread, kill it.
                # ^^^^ --- what the !@#*?  serious!  -exarkun
                if selectable not in fdset:
                    continue
                # This for pausing input when we&#39;re not ready for more.

                # 调用_doReadOrWrite方法
                _logrun(selectable, _drdw, selectable, method)

    doIteration = doSelect

    def _doReadOrWrite(self, selectable, method):
        try:
            # 调用method，doRead或者是doWrite，
            # 这里的selectable可能是我们监听的tcp.Port
            why = getattr(selectable, method)()
        except:
            why = sys.exc_info()[1]
            log.err()
        if why:
            self._disconnectSelectable(selectable, why, method==&amp;quot;doRead&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么假如客户端有连接请求了，就会调用读集合中tcp.Port的doRead方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# twisted/internet/tcp.py

@implementer(interfaces.IListeningPort)
class Port(base.BasePort, _SocketCloser):

    def doRead(self):
        &amp;quot;&amp;quot;&amp;quot;Called when my socket is ready for reading.
        当套接字准备好读的时候调用

        This accepts a connection and calls self.protocol() to handle the
        wire-level protocol.
        &amp;quot;&amp;quot;&amp;quot;
        try:
            if platformType == &amp;quot;posix&amp;quot;:
                numAccepts = self.numberAccepts
            else:
                numAccepts = 1
            for i in range(numAccepts):
                if self.disconnecting:
                    return
                try:
                    # 调用accept
                    skt, addr = self.socket.accept()
                except socket.error as e:
                    if e.args[0] in (EWOULDBLOCK, EAGAIN):
                        self.numberAccepts = i
                        break
                    elif e.args[0] == EPERM:
                        continue
                    elif e.args[0] in (EMFILE, ENOBUFS, ENFILE, ENOMEM, ECONNABORTED):
                        log.msg(&amp;quot;Could not accept new connection (%s)&amp;quot; % (
                            errorcode[e.args[0]],))
                        break
                    raise

                fdesc._setCloseOnExec(skt.fileno())
                protocol = self.factory.buildProtocol(self._buildAddr(addr))
                if protocol is None:
                    skt.close()
                    continue
                s = self.sessionno
                self.sessionno = s+1
                # transport初始化的过程中，会将自身假如到reactor的读集合中，那么当它准备
                # 好读的时候，就可以调用它的doRead方法读取客户端发过来的数据了
                transport = self.transport(skt, protocol, addr, self, s, self.reactor)
                protocol.makeConnection(transport)
            else:
                self.numberAccepts = self.numberAccepts+20
        except:
            log.deferr()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;doRead方法中，调用accept产生了用于接收客户端数据的套接字，将套接字与transport绑定，然后把transport加入到reactor的读集合。当客户端有数据到来时，就会调用transport的doRead方法进行数据读取了。&lt;/p&gt;

&lt;p&gt;Connection是Server（transport实例的类）的父类，它实现了doRead方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# twisted/internet/tcp.py
@implementer(interfaces.ITCPTransport, interfaces.ISystemHandle)
class Connection(_TLSConnectionMixin, abstract.FileDescriptor, _SocketCloser,
                 _AbortingMixin):

    def doRead(self):
        try:
            # 接收数据
            data = self.socket.recv(self.bufferSize)
        except socket.error as se:
            if se.args[0] == EWOULDBLOCK:
                return
            else:
                return main.CONNECTION_LOST

        return self._dataReceived(data)

    def _dataReceived(self, data):
        if not data:
            return main.CONNECTION_DONE
        # 调用我们自定义protocol的dataReceived方法处理数据
        rval = self.protocol.dataReceived(data)
        if rval is not None:
            offender = self.protocol.dataReceived
            warningFormat = (
                &#39;Returning a value other than None from %(fqpn)s is &#39;
                &#39;deprecated since %(version)s.&#39;)
            warningString = deprecate.getDeprecationWarningString(
                offender, versions.Version(&#39;Twisted&#39;, 11, 0, 0),
                format=warningFormat)
            deprecate.warnAboutFunction(offender, warningString)
        return rval
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;_dataReceived中调用了示例中我们自定义的EchoProtocol的dataReceived方法处理数据。&lt;/p&gt;

&lt;p&gt;至此，一个简单的流程，从创建监听事件，到接收客户端数据就此结束了。&lt;/p&gt;

&lt;p&gt;一些细节的地方我并未说明，这里只是说明一个大概的流程，想看的细一点的，可以直接跟着这个流程去看源码。&lt;/p&gt;

&lt;p&gt;这个系列应该会不定时更新，如果有人感兴趣的，也可以和我直接交流。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>浅谈Python的with语句(转载)</title>
      <link>/post/python-with/</link>
      <pubDate>Tue, 07 Jul 2015 22:20:10 +0800</pubDate>
      
      <guid>/post/python-with/</guid>
      <description>&lt;p&gt;本文转自&lt;a href=&#34;http://www.ibm.com/developerworks/cn/opensource/os-cn-pythonwith/&#34;&gt;浅谈Python的with语句&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;引言&#34;&gt;引言&lt;/h2&gt;

&lt;p&gt;with 语句是从 Python 2.5 开始引入的一种与异常处理相关的功能（2.5 版本中要通过 from __future__ import with_statement 导入后才可以使用），从 2.6 版本开始缺省可用（参考 &lt;a href=&#34;https://docs.python.org/release/2.6/whatsnew/2.6.html#pep-343-the-with-statement&#34;&gt;What&amp;rsquo;s new in Python 2.6?&lt;/a&gt; 中 with 语句相关部分介绍）。with 语句适用于对资源进行访问的场合，确保不管使用过程中是否发生异常都会执行必要的“清理”操作，释放资源，比如文件使用后自动关闭、线程中锁的自动获取和释放等。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;术语&#34;&gt;术语&lt;/h2&gt;

&lt;p&gt;要使用 with 语句，首先要明白上下文管理器这一概念。有了上下文管理器，with 语句才能工作。
下面是一组与上下文管理器和with 语句有关的概念。&lt;/p&gt;

&lt;p&gt;上下文管理协议（Context Management Protocol）：包含方法 __enter__() 和 __exit__()，支持
该协议的对象要实现这两个方法。&lt;/p&gt;

&lt;p&gt;上下文管理器（Context Manager）：支持上下文管理协议的对象，这种对象实现了
__enter__() 和 __exit__() 方法。上下文管理器定义执行 with 语句时要建立的运行时上下文，
负责执行 with 语句块上下文中的进入与退出操作。通常使用 with 语句调用上下文管理器，
也可以通过直接调用其方法来使用。&lt;/p&gt;

&lt;p&gt;运行时上下文（runtime context）：由上下文管理器创建，通过上下文管理器的 __enter__() 和
__exit__() 方法实现，__enter__() 方法在语句体执行之前进入运行时上下文，__exit__() 在
语句体执行完后从运行时上下文退出。with 语句支持运行时上下文这一概念。&lt;/p&gt;

&lt;p&gt;上下文表达式（Context Expression）：with 语句中跟在关键字 with 之后的表达式，该表达式
要返回一个上下文管理器对象。&lt;/p&gt;

&lt;p&gt;语句体（with-body）：with 语句包裹起来的代码块，在执行语句体之前会调用上下文管
理器的 __enter__() 方法，执行完语句体之后会执行 __exit__() 方法。&lt;/p&gt;

&lt;h2 id=&#34;基本语法和工作原理&#34;&gt;基本语法和工作原理&lt;/h2&gt;

&lt;p&gt;with 语句的语法格式如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 清单 1. with 语句的语法格式
with context_expression [as target(s)]:
    with-body
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里 context_expression 要返回一个上下文管理器对象，该对象并不赋值给 as 子句中的 target(s) ，如果指定了 as 子句的话，会将上下文管理器的__enter__() 方法的返回值赋值给 target(s)。target(s) 可以是单个变量，或者由“()”括起来的元组（不能是仅仅由“,”分隔的变量列表，必须加“()”）。&lt;/p&gt;

&lt;p&gt;Python 对一些内建对象进行改进，加入了对上下文管理器的支持，可以用于 with 语句中，比如可以自动关闭文件、线程锁的自动获取和释放等。假设要对一个文件进行操作，使用 with 语句可以有如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 清单 2. 使用 with 语句操作文件对象
with open(r&#39;somefileName&#39;) as somefile:
    for line in somefile:
        print line
        # ...more code
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里使用了 with 语句，不管在处理文件过程中是否发生异常，都能保证 with 语句执行完毕后已经关闭了打开的文件句柄。如果使用传统的 try/finally 范式，则要使用类似如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 清单 3. try/finally 方式操作文件对象
somefile = open(r&#39;somefileName&#39;)
try:
    for line in somefile:
        print line
        # ...more code
finally:
    somefile.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;比较起来，使用 with 语句可以减少编码量。已经加入对上下文管理协议支持的还有模块 threading、decimal 等。&lt;/p&gt;

&lt;p&gt;PEP 0343 对 with 语句的实现进行了描述。with 语句的执行过程类似如下代码块：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 清单 4. with 语句执行过程
context_manager = context_expression
exit = type(context_manager).__exit__
value = type(context_manager).__enter__(context_manager)
exc = True   # True 表示正常执行，即便有异常也忽略；False 表示重新抛出异常，需要对异常进行处理
try:
    try:
        target = value  # 如果使用了 as 子句
        with-body     # 执行 with-body
    except:
        # 执行过程中有异常发生
        exc = False
        # 如果 __exit__ 返回 True，则异常被忽略；如果返回 False，则重新抛出异常
        # 由外层代码对异常进行处理
        if not exit(context_manager, *sys.exc_info()):
            raise
finally:
    # 正常退出，或者通过 statement-body 中的 break/continue/return 语句退出
    # 或者忽略异常退出
    if exc:
        exit(context_manager, None, None, None)
    # 缺省返回 None，None 在布尔上下文中看做是 False
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;执行 context_expression，生成上下文管理器 context_manager&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;调用上下文管理器的 __enter__() 方法；如果使用了 as 子句，则将 __enter__() 方法的返回值赋值给 as 子句中的 target(s)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;执行语句体 with-body&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;不管是否执行过程中是否发生了异常，执行上下文管理器的 __exit__() 方法，__exit__() 方法负责执行“清理”工作，如释放资源等。如果执行过程中没有出现异常，或者语句体中执行了语句 break/continue/return，则以 None 作为参数调用 __exit__(None, None, None) ；如果执行过程中出现异常，则使用 sys.exc_info 得到的异常信息为参数调用__exit__(exc_type, exc_value, exc_traceback)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;出现异常时，如果 __exit__(type, value, traceback) 返回 False，则会重新抛出异常，让with 之外的语句逻辑来处理异常，这也是通用做法；如果返回 True，则忽略异常，不再对异常进行处理&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;自定义上下文管理器&#34;&gt;自定义上下文管理器&lt;/h2&gt;

&lt;p&gt;开发人员可以自定义支持上下文管理协议的类。自定义的上下文管理器要实现上下文管理协议所需要的 __enter__() 和 __exit__() 两个方法：&lt;/p&gt;

&lt;p&gt;context_manager.__enter__()：进入上下文管理器的运行时上下文，在语句体执行前调用。with 语句将该方法的返回值赋值给 as 子句中的 target，如果指定了 as 子句的话&lt;/p&gt;

&lt;p&gt;context_manager.__exit__(exc_type, exc_value, exc_traceback)： 退出与上下文管理器相关的运行时上下文，返回一个布尔值表示是否对发生的异常进行处理。参数表示引起退出操作的异常，如果退出时没有发生异常，则3个参数都为None。如果发生异常，返回True 表示不处理异常，否则会在退出该方法后重新抛出异常以由 with 语句之外的代码逻辑进行处理。如果该方法内部产生异常，则会取代由 statement-body 中语句产生的异常。要处理异常时，不要显示重新抛出异常，即不能重新抛出通过参数传递进来的异常，只需要将返回值设置为 False 就可以了。之后，上下文管理代码会检测是否__exit__() 失败来处理异常&lt;/p&gt;

&lt;p&gt;下面通过一个简单的示例来演示如何构建自定义的上下文管理器。注意，上下文管理器必须同时提供 __enter__() 和 __exit__() 方法的定义，缺少任何一个都会导致 AttributeError；with 语句会先检查是否提供了 __exit__() 方法，然后检查是否定义了 __enter__() 方法。&lt;/p&gt;

&lt;p&gt;假设有一个资源 DummyResource，这种资源需要在访问前先分配，使用完后再释放掉；分配操作可以放到 __enter__() 方法中，释放操作可以放到 __exit__() 方法中。简单起见，这里只通过打印语句来表明当前的操作，并没有实际的资源分配与释放。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 清单 5. 自定义支持 with 语句的对象
class DummyResource:
    def __init__(self, tag):
            self.tag = tag
            print &#39;Resource [%s]&#39; % tag
        def __enter__(self):
            print &#39;[Enter %s]: Allocate resource.&#39; % self.tag
            return self	  # 可以返回不同的对象
        def __exit__(self, exc_type, exc_value, exc_tb):
            print &#39;[Exit %s]: Free resource.&#39; % self.tag
            if exc_tb is None:
                print &#39;[Exit %s]: Exited without exception.&#39; % self.tag
            else:
                print &#39;[Exit %s]: Exited with exception raised.&#39; % self.tag
                return False   # 可以省略，缺省的None也是被看做是False
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;DummyResource 中的 __enter__() 返回的是自身的引用，这个引用可以赋值给 as 子句中的 target 变量；返回值的类型可以根据实际需要设置为不同的类型，不必是上下文管理器对象本身。&lt;/p&gt;

&lt;p&gt;__exit__() 方法中对变量 exc_tb 进行检测，如果不为 None，表示发生了异常，返回 False 表示需要由外部代码逻辑对异常进行处理；注意到如果没有发生异常，缺省的返回值为 None，在布尔环境中也是被看做 False，但是由于没有异常发生，__exit__() 的三个参数都为 None，上下文管理代码可以检测这种情况，做正常处理。&lt;/p&gt;

&lt;p&gt;下面在 with 语句中访问 DummyResource ：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 清单 6. 使用自定义的支持 with 语句的对象
with DummyResource(&#39;Normal&#39;):
    print &#39;[with-body] Run without exceptions.&#39;

with DummyResource(&#39;With-Exception&#39;):
    print &#39;[with-body] Run with exception.&#39;
    raise Exception
    print &#39;[with-body] Run with exception. Failed to finish statement-body!&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第1个 with 语句的执行结果如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 清单 7. with 语句1执行结果
Resource [Normal]
[Enter Normal]: Allocate resource.
[with-body] Run without exceptions.
[Exit Normal]: Free resource.
[Exit Normal]: Exited without exception.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，正常执行时会先执行完语句体 with-body，然后执行 __exit__() 方法释放资源。&lt;/p&gt;

&lt;p&gt;第2个 with 语句的执行结果如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 清单 8. with 语句2执行结果
Resource [With-Exception]
[Enter With-Exception]: Allocate resource.
[with-body] Run with exception.
[Exit With-Exception]: Free resource.
[Exit With-Exception]: Exited with exception raised.

Traceback (most recent call last):
  File &amp;quot;G:/demo&amp;quot;, line 20, in &amp;lt;module&amp;gt;
    raise Exception
Exception
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，with-body 中发生异常时with-body 并没有执行完，但资源会保证被释放掉，同时产生的异常由 with 语句之外的代码逻辑来捕获处理。&lt;/p&gt;

&lt;p&gt;可以自定义上下文管理器来对软件系统中的资源进行管理，比如数据库连接、共享资源的访问控制等。Python 在线文档 Writing Context Managers 提供了一个针对数据库连接进行管理的上下文管理器的简单范例。&lt;/p&gt;

&lt;h2 id=&#34;contextlib-模块&#34;&gt;contextlib 模块&lt;/h2&gt;

&lt;p&gt;contextlib 模块提供了3个对象：装饰器 contextmanager、函数 nested 和上下文管理器 closing。使用这些对象，可以对已有的生成器函数或者对象进行包装，加入对上下文管理协议的支持，避免了专门编写上下文管理器来支持 with 语句。&lt;/p&gt;

&lt;h3 id=&#34;装饰器-contextmanager&#34;&gt;装饰器 contextmanager&lt;/h3&gt;

&lt;p&gt;contextmanager 用于对生成器函数进行装饰，生成器函数被装饰以后，返回的是一个上下文管理器，其 __enter__() 和 __exit__() 方法由 contextmanager 负责提供，而不再是之前的迭代子。被装饰的生成器函数只能产生一个值，否则会导致异常 RuntimeError；产生的值会赋值给 as 子句中的 target，如果使用了 as 子句的话。下面看一个简单的例子。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 清单 9. 装饰器 contextmanager 使用示例
from contextlib import contextmanager

@contextmanager
def demo():
    print &#39;[Allocate resources]&#39;
    print &#39;Code before yield-statement executes in \_\_enter\_\_&#39;
    yield &#39;*** contextmanager demo ***&#39;
    print &#39;Code after yield-statement executes in \_\_exit\_\_&#39;
    print &#39;[Free resources]&#39;

with demo() as value:
    print &#39;Assigned Value: %s&#39; % value

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果输出如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 清单 10. contextmanager 使用示例执行结果
[Allocate resources]
Code before yield-statement executes in __enter__
Assigned Value: *** contextmanager demo ***
Code after yield-statement executes in __exit__
[Free resources]
``
可以看到，生成器函数中 yield 之前的语句在 \_\_enter\_\_() 方法中执行，yield 之后的语句在 \_\_exit\_\_() 中执行，而 yield 产生的值赋给了 as 子句中的 value 变量。

需要注意的是，contextmanager 只是省略了 \_\_enter\_\_() / \_\_exit\_\_() 的编写，但并不负责实现资源的“获取”和“清理”工作；“获取”操作需要定义在 yield 语句之前，“清理”操作需要定义 yield 语句之后，这样 with 语句在执行 \_\_enter\_\_() / \_\_exit\_\_() 方法时会执行这些语句以获取/释放资源，即生成器函数中需要实现必要的逻辑控制，包括资源访问出现错误时抛出适当的异常。

### 函数 nested

nested 可以将多个上下文管理器组织在一起，避免使用嵌套 with 语句。

```python
# 清单 11. nested 语法
with nested(A(), B(), C()) as (X, Y, Z):
      # with-body code here
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;类似于：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 清单 12. nested 执行过程
with A() as X:
    with B() as Y:
        with C() as Z:
              # with-body code here
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要注意的是，发生异常后，如果某个上下文管理器的 __exit__() 方法对异常处理返回 False，则更外层的上下文管理器不会监测到异常。&lt;/p&gt;

&lt;h3 id=&#34;上下文管理器-closing&#34;&gt;上下文管理器 closing&lt;/h3&gt;

&lt;p&gt;closing 的实现如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 清单 13. 上下文管理 closing 实现
class closing(object):
    # help doc here
    def __init__(self, thing):
        self.thing = thing
    def __enter__(self):
        return self.thing
    def __exit__(self, *exc_info):
        self.thing.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上下文管理器会将包装的对象赋值给 as 子句的 target 变量，同时保证打开的对象在 with-body 执行完后会关闭掉。closing 上下文管理器包装起来的对象必须提供 close() 方法的定义，否则执行时会报 AttributeError 错误。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 清单 14. 自定义支持 closing 的对象
class ClosingDemo(object):
    def __init__(self):
        self.acquire()
    def acquire(self):
        print &#39;Acquire resources.&#39;
    def free(self):
        print &#39;Clean up any resources acquired.&#39;
    def close(self):
        self.free()

with closing(ClosingDemo()):
    print &#39;Using resources&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果输出如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 清单 15. 自定义 closing 对象的输出结果
Acquire resources.
Using resources
Clean up any resources acquired.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;closing 适用于提供了 close() 实现的对象，比如网络连接、数据库连接等，也可以在自定义类时通过接口 close() 来执行所需要的资源“清理”工作。&lt;/p&gt;

&lt;h2 id=&#34;小结&#34;&gt;小结&lt;/h2&gt;

&lt;p&gt;本文对 with 语句的语法和工作机理进行了介绍，并通过示例介绍了如何实现自定义的上下文管理器，最后介绍了如何使用 contextlib 模块来简化上下文管理器的编写。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Python __future__ 模块</title>
      <link>/post/python-future/</link>
      <pubDate>Fri, 03 Jul 2015 22:18:29 +0800</pubDate>
      
      <guid>/post/python-future/</guid>
      <description>&lt;p&gt;在Python2.7代码中经常能看到使用__future__模块。那么__future__到底是做什么的呢？&lt;/p&gt;

&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;

&lt;p&gt;从单词含义上猜应该是“未来”的模块。它有下面几个&lt;a href=&#34;https://docs.python.org/2.7/library/__future__.html&#34;&gt;目的&lt;/a&gt;：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;避免和现有分析import工具混淆，并得到你期望的模块&lt;/li&gt;
&lt;li&gt;确保2.1之前的版本导入__future__产生运行时异常，因为2.1之前没有这个模块&lt;/li&gt;
&lt;li&gt;文档化不兼容的改变，通常这些改变会在新版中强制执行。这类文档以可执行的形式组织，通过导入__future__进行可编程式的检查。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;以上是对官方解释的粗略翻译，翻译起来感觉有些拗口。我是这么理解的，某个版本中出现了某个新的功能特性，而且这个特性和当前版本中使用的不兼容，也就是它在该版本中不是语言标准，那么我如果想要使用的话就需要从__future__模块导入。在2.1版本之前并没有__future__，所以使用它会引发异常。当然，在以后的某个版本中，比如说3中，某个特性已经成为标准的一部分，那么使用该特性就不用从__future__导入了。&lt;/p&gt;

&lt;p&gt;下面说一下__future__是如何实现新特性的。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;feature类&#34;&gt;_Feature类&lt;/h2&gt;

&lt;p&gt;__future__.py中有形如下面的语句：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;FeatureName = _Feature(OptionalRelease, MandatoryRelease, CompilerFlag)

class _Feature:
    def __init__(self, optionalRelease, mandatoryRelease, compiler_flag):
        self.optional = optionalRelease    # 某个特性被认可的初始版本
        self.mandatory = mandatoryRelease  # 某个特性成为标准的版本
        self.compiler_flag = compiler_flag

    def getOptionalRelease(self):
        &amp;quot;&amp;quot;&amp;quot;Return first release in which this feature was recognized.

        This is a 5-tuple, of the same form as sys.version_info.
        &amp;quot;&amp;quot;&amp;quot;

        return self.optional

    def getMandatoryRelease(self):
        &amp;quot;&amp;quot;&amp;quot;Return release in which this feature will become mandatory.

        This is a 5-tuple, of the same form as sys.version_info, or, if
        the feature was dropped, is None.
        &amp;quot;&amp;quot;&amp;quot;

        return self.mandatory

    def __repr__(self):
        return &amp;quot;_Feature&amp;quot; + repr((self.optional,
                                  self.mandatory,
                                  self.compiler_flag))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;optionalrelease参数&#34;&gt;OptionalRelease参数&lt;/h2&gt;

&lt;p&gt;通常OptionalRelease版本小于MandatoryRelease，每个都是5个元素的元组，类似sys.version_info。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;(PY_MAJOR_VERSION, # the 2 in 2.1.0a3; an int
PY_MINOR_VERSION, # the 1; an int
PY_MICRO_VERSION, # the 0; an int
PY_RELEASE_LEVEL, # &amp;quot;alpha&amp;quot;, &amp;quot;beta&amp;quot;, &amp;quot;candidate&amp;quot; or &amp;quot;final&amp;quot;; string
PY_RELEASE_SERIAL # the 3; an int
)

# 例如: (2, 1, 0, &amp;quot;alpha&amp;quot;, 3)表示2.1.0a3版
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OptionalRelease版本中开始通过下列方式使用某个特性：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from __future__ import FeatureName
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;mandatoryrelease参数&#34;&gt;MandatoryRelease参数&lt;/h2&gt;

&lt;p&gt;在MandatoryRelease版本中该特性变成Python标准的一部分。此外MandatoryRelease版本后不需要上面的导入语句就能使用该特性。MandatoryRelease可能是None，表示一个计划中的特性被放弃了。&lt;/p&gt;

&lt;h2 id=&#34;compilerflag参数&#34;&gt;CompilerFlag参数&lt;/h2&gt;

&lt;p&gt;CompilerFlag编译器标志，它是一个位域标志，传给内建函数compile()做第四个参数，用来在动态编译代码的时候允许新的特性。&lt;/p&gt;

&lt;p&gt;CompilerFlag值等价于Include/compile.h的预定义的CO_xxx标志。&lt;/p&gt;

&lt;h2 id=&#34;python2-future-模块的features&#34;&gt;Python2 __future__模块的features&lt;/h2&gt;

&lt;p&gt;一共是以下7种，其对应的CompilerFlag:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;all_feature_names = [
    &amp;quot;nested_scopes&amp;quot;,
    &amp;quot;generators&amp;quot;,
    &amp;quot;division&amp;quot;,
    &amp;quot;absolute_import&amp;quot;,
    &amp;quot;with_statement&amp;quot;,
    &amp;quot;print_function&amp;quot;,
    &amp;quot;unicode_literals&amp;quot;,
]

CO_NESTED            = 0x0010   # nested_scopes
CO_GENERATOR_ALLOWED = 0        # generators (obsolete, was 0x1000)
CO_FUTURE_DIVISION   = 0x2000   # division
CO_FUTURE_ABSOLUTE_IMPORT = 0x4000 # perform absolute imports by default
CO_FUTURE_WITH_STATEMENT  = 0x8000   # with statement
CO_FUTURE_PRINT_FUNCTION  = 0x10000   # print function
CO_FUTURE_UNICODE_LITERALS = 0x20000 # unicode string literals
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;nested-scopes&#34;&gt;nested_scopes&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;nested_scopes = _Feature((2, 1, 0, &amp;quot;beta&amp;quot;,  1),
                         (2, 2, 0, &amp;quot;alpha&amp;quot;, 0),
                         CO_NESTED)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;nested_scopes指的是嵌套作用域，2.1.0b1中出现，2.2.0a0中成为标准。&lt;/p&gt;

&lt;p&gt;提到作用域，那么就不得不说命名空间。&lt;/p&gt;

&lt;h4 id=&#34;命名空间的定义&#34;&gt;命名空间的定义&lt;/h4&gt;

&lt;p&gt;Python命名空间是名称到对象的映射，目前是用字典实现，键名是变量名，值是变量的值。比如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; x = 3
&amp;gt;&amp;gt;&amp;gt; globals()
{&#39;__builtins__&#39;: &amp;lt;module &#39;__builtin__&#39; (built-in)&amp;gt;, &#39;__name__&#39;: &#39;__main__&#39;, &#39;__doc__&#39;: None, &#39;x&#39;: 3, &#39;__package__&#39;: None}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到变量x，3以字典的形式存放在globals空间内。以之对应的名称空间还有：locals()。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; locals()
{&#39;__builtins__&#39;: &amp;lt;module &#39;__builtin__&#39; (built-in)&amp;gt;, &#39;__name__&#39;: &#39;__main__&#39;, &#39;__doc__&#39;: None, &#39;x&#39;: 3, &#39;__package__&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实际上，你可以通过向名字添加键名和值，然后就可以直接使用名称了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; globals()[&#39;y&#39;] = 5
&amp;gt;&amp;gt;&amp;gt; y
5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通常，我们用属性来称呼&amp;rsquo;.&amp;lsquo;点号之后的名称为属性。比如，在z.real中，real是z的一个属性。严格来说，模块中的名称引用就是属性引用。modname.funcname中，modname是一个模块对象，而funcname是它的一个属性。模块属性和全局名称有映射关系，它们共享全局命名空间。上面代码中的x和y都是模块&lt;strong&gt;main&lt;/strong&gt;的属性。&lt;/p&gt;

&lt;p&gt;属性可能是只读的，也可能是可写的。模块属性是可写的，你可以这么做，modname.the_answer = 42。可写的属性能够用del语句来删除。比如，del modname.the_answer将会从模块modname中删除the_answer属性。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; x = 3
&amp;gt;&amp;gt;&amp;gt; globals()
{&#39;__builtins__&#39;: &amp;lt;module &#39;__builtin__&#39; (built-in)&amp;gt;, &#39;__package__&#39;: None, &#39;func&#39;: &amp;lt;function func at 0x029FA270&amp;gt;, &#39;x&#39;: 3, &#39;__name__&#39;: &#39;__main__&#39;, &#39;__doc__&#39;: None}
&amp;gt;&amp;gt;&amp;gt; del x
&amp;gt;&amp;gt;&amp;gt; globals()
{&#39;__builtins__&#39;: &amp;lt;module &#39;__builtin__&#39; (built-in)&amp;gt;, &#39;__package__&#39;: None, &#39;func&#39;: &amp;lt;function func at 0x029FA270&amp;gt;, &#39;__name__&#39;: &#39;__main__&#39;, &#39;__doc__&#39;: None}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;del做的事实际上是删除了全局名称字典中的x键值。&lt;/p&gt;

&lt;h4 id=&#34;命名空间的种类&#34;&gt;命名空间的种类&lt;/h4&gt;

&lt;p&gt;Python中有三种命名空间：&lt;/p&gt;

&lt;p&gt;a) 局部，函数内的命名空间就是局部的，它记录了函数的变量，包括函数的参数和局部定义的变量。&lt;/p&gt;

&lt;p&gt;b) 全局，模块内的命名空间就是全局的，它记录了模块的变量，包括函数、类、其它导入的模块、模块级的变量和常量。&lt;/p&gt;

&lt;p&gt;c) 内置，包括异常类型、内建函数和特殊方法，可以代码中任意地方调用；&lt;/p&gt;

&lt;p&gt;上面提到的globals是全局命名空间，locals是局部命名空间。&lt;/p&gt;

&lt;p&gt;命名空间会在不同的时间创建，并有不同的生命周期。包含内置名称的命名空间是在python解释器启动的时候创建的，并且不会被删除。一个模块的全局命名空间是在模块定义代码被读入的时候创建的，一般情况下，模块命名空间会持续到解释器结束。在解释器最上层调用的代码，不管是从脚本中读入的还是在交互式界面中，都会被认为是属于一个叫做&lt;strong&gt;main&lt;/strong&gt;模块的,所以它们有自己的全局命名空间。（内置名称实际上也放置在一个模块中，称为builtins）。&lt;/p&gt;

&lt;p&gt;一个函数的局部命名空间在函数被调用的时候创建，在函数返回或者引发一个不在函数内部处理的异常时被删除。（实际上用遗忘来描述这个删除比较好。）当然了，递归调用的函数每个都有它们自己的命名空间。&lt;/p&gt;

&lt;h4 id=&#34;命名空间的可见性-作用域&#34;&gt;命名空间的可见性（作用域）&lt;/h4&gt;

&lt;p&gt;作用域是一个Python程序中命名空间直接可见的代码区域，也就是说这个区域内可以直接使用命名空间内的名称。&lt;/p&gt;

&lt;p&gt;a) 内置命名空间在代码所有位置都是可见的，所以可以随时被调用；&lt;/p&gt;

&lt;p&gt;b) 全局命名空间和局部命名空间中， 如果有同名变量，在全局命名空间处，局部命名空间内的同名变量是不可见的；&lt;/p&gt;

&lt;p&gt;c) 在局部命名空间处，全局命名空间的同名变量是不可见的（只有变量不同名的情况下，可使用 global关键字让其可见）。&lt;/p&gt;

&lt;h4 id=&#34;命名空间的查找顺序&#34;&gt;命名空间的查找顺序&lt;/h4&gt;

&lt;p&gt;a) 如果在函数内调用一个变量，先在函数内（局部命名空间）查找，如果找到则停止查找。否则在函数外部（全局命名空间）查找，如果还是没找到，则查找内置命名空间。如果以上三个命名都未找到，则抛出NameError 的异常错误。&lt;/p&gt;

&lt;p&gt;b) 如果在函数外调用一个变量，则在函数外查找（全局命名空间，局部命名空间此时不可见），如果找到则停止查找，否则到内置命名空间中查找。如果两者都找不到，则抛出异常。只有当局部命名空间内，使用global 关键字声明了一个变量时，查找顺序则是 a) 的查找顺序。&lt;/p&gt;

&lt;h4 id=&#34;nested-scopes说明&#34;&gt;nested_scopes说明&lt;/h4&gt;

&lt;p&gt;Python2.2引入了一种略有不同但重要的改变，它会影响命名空间的搜索顺序：嵌套的作用域。在2.0中，当你在一个嵌套函数或 lambda 函数中引用一个变量时，Python会在当前（嵌套的或 lambda）函数的名称空间中搜索，然后在模块的名称空间。2.2将支在当前（嵌套的或 lambda）函数的名称空间中搜索，然后是在父函数的名称空间，接着是模块的名称空间。2.1可以两种方式工作，缺省地，按n2.0的方式工作，如果想像2.2中那样工作，使用下面的导入语句：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from __future__ import nested_scopes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然现在一般都用2.7或者3了，所以已经是嵌套作用域了。&lt;/p&gt;

&lt;p&gt;来看下面一段代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; x = 3
&amp;gt;&amp;gt;&amp;gt; globals()
{&#39;__builtins__&#39;: &amp;lt;module &#39;__builtin__&#39; (built-in)&amp;gt;, &#39;__package__&#39;: None, &#39;func&#39;: &amp;lt;function func at 0x028BA2B0&amp;gt;, &#39;x&#39;: 3, &#39;__name__&#39;: &#39;__main__&#39;, &#39;__doc__&#39;: None}
&amp;gt;&amp;gt;&amp;gt; def func():
        x = 2
	      print locals()

&amp;gt;&amp;gt;&amp;gt; func()
{&#39;x&#39;: 2}
&amp;gt;&amp;gt;&amp;gt; globals()
{&#39;__builtins__&#39;: &amp;lt;module &#39;__builtin__&#39; (built-in)&amp;gt;, &#39;__package__&#39;: None, &#39;func&#39;: &amp;lt;function func at 0x028BA2B0&amp;gt;, &#39;x&#39;: 3, &#39;__name__&#39;: &#39;__main__&#39;, &#39;__doc__&#39;: None}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;全局命名空间中x的值前后并没有改变，反而在func函数的局部命名空间中产生了一个新的名称x。由此可以看出，外层作用域的命名空间对于内层来说是只读的，当写一个同名的名称时，只会在内层生成一个新的名称。但是如果一个名称被声明为global，对其引用和复制都会直接作用域全局名称。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; x = 2
&amp;gt;&amp;gt;&amp;gt; def func():
        global x
	      x = 3
	      print locals()

&amp;gt;&amp;gt;&amp;gt; globals()
{&#39;__builtins__&#39;: &amp;lt;module &#39;__builtin__&#39; (built-in)&amp;gt;, &#39;__package__&#39;: None, &#39;func&#39;: &amp;lt;function func at 0x029FA270&amp;gt;, &#39;x&#39;: 2, &#39;__name__&#39;: &#39;__main__&#39;, &#39;__doc__&#39;: None
&amp;gt;&amp;gt;&amp;gt; func()
{}
&amp;gt;&amp;gt;&amp;gt; globals()
{&#39;__builtins__&#39;: &amp;lt;module &#39;__builtin__&#39; (built-in)&amp;gt;, &#39;__package__&#39;: None, &#39;func&#39;: &amp;lt;function func at 0x029FA270&amp;gt;, &#39;x&#39;: 3, &#39;__name__&#39;: &#39;__main__&#39;, &#39;__doc__&#39;: None}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;x的值前后改变了，而且func函数中也没用增加x。&lt;/p&gt;

&lt;h4 id=&#34;import-module和from-module-import-func&#34;&gt;import module和from module import func&lt;/h4&gt;

&lt;p&gt;import module将模块自身导入到当前命名空间，所以如果要使用module的某个函数或属性，只能module.func这么用。&lt;/p&gt;

&lt;p&gt;而使用from module import func，则是将函数func导入当前的名称空间，这时候使用这个函数就不需要模块名称而是直接使用func。&lt;/p&gt;

&lt;p&gt;我们通过一段代码来描述：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; globals()
{&#39;__builtins__&#39;: &amp;lt;module &#39;__builtin__&#39; (built-in)&amp;gt;, &#39;__package__&#39;: None, &#39;__name__&#39;: &#39;__main__&#39;, &#39;__doc__&#39;: None}
&amp;gt;&amp;gt;&amp;gt; import os
&amp;gt;&amp;gt;&amp;gt; globals()
{&#39;__builtins__&#39;: &amp;lt;module &#39;__builtin__&#39; (built-in)&amp;gt;, &#39;__package__&#39;: None, &#39;__name__&#39;: &#39;__main__&#39;, &#39;os&#39;: &amp;lt;module &#39;os&#39; from &#39;C:\Python27\lib\os.pyc&#39;&amp;gt;, &#39;__doc__&#39;: None}
&amp;gt;&amp;gt;&amp;gt; del os
&amp;gt;&amp;gt;&amp;gt; from os import sys
&amp;gt;&amp;gt;&amp;gt; globals()
{&#39;__builtins__&#39;: &amp;lt;module &#39;__builtin__&#39; (built-in)&amp;gt;, &#39;__package__&#39;: None, &#39;sys&#39;: &amp;lt;module &#39;sys&#39; (built-in)&amp;gt;, &#39;__name__&#39;: &#39;__main__&#39;, &#39;__doc__&#39;: None}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;是不是很清晰，担任sys也是一个模块，如果要使用sys模块的属性，也必须要使用sys模块名了。这也是嵌套作用域的一个例子。&lt;/p&gt;

&lt;p&gt;额。。。貌似本文的正题是__future__，哈哈，扯远了，我们继续来看下面一个feauture。&lt;/p&gt;

&lt;h3 id=&#34;generators&#34;&gt;generators&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;generators = _Feature((2, 2, 0, &amp;quot;alpha&amp;quot;, 1),
                      (2, 3, 0, &amp;quot;final&amp;quot;, 0),
                      CO_GENERATOR_ALLOWED)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;generators生成器起于2.2.0a1版，在2.3.0f0中成为标准。&lt;/p&gt;

&lt;h4 id=&#34;简介-1&#34;&gt;简介&lt;/h4&gt;

&lt;p&gt;生成器是这样一个函数，它记住上一次返回时在函数体中的位置。对生成器函数的第二次（或第 n 次）调用跳转至该函数中间，而上次调用的所有局部变量都保持不变。Python中yeild就是一个生成器。&lt;/p&gt;

&lt;h4 id=&#34;yield-生成器的运行机制&#34;&gt;yield 生成器的运行机制&lt;/h4&gt;

&lt;p&gt;当你问生成器要一个数时，生成器会执行，直至出现 yield 语句，生成器把 yield 的参数给你，之后生成器就不会往下继续运行。 当你问他要下一个数时，他会从上次的状态。开始运行，直至出现yield语句，把参数给你，之后停下。如此反复直至退出函数。&lt;/p&gt;

&lt;h4 id=&#34;示例&#34;&gt;示例&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; def my_generator():
	      yield 1
	      yield 2
	      yield 3

&amp;gt;&amp;gt;&amp;gt; gen = my_generator()
&amp;gt;&amp;gt;&amp;gt; gen.next()
1
&amp;gt;&amp;gt;&amp;gt; gen.next()
2
&amp;gt;&amp;gt;&amp;gt; gen.next()
3
&amp;gt;&amp;gt;&amp;gt; gen.next()

Traceback (most recent call last):
  File &amp;quot;&amp;lt;pyshell#92&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt;
    gen.next()
StopIteration
&amp;gt;&amp;gt;&amp;gt; for n in my_generator:
        print n
1
2
3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;yield在被next调用之前并没有执行（for循环内部也是使用next），在执行完最后一个yield之后再继续调用next，那么就好遇到StopIteration异常了。这里涉及到迭代器了，不再进行详细的描述了，后面会单开一章来讲Python的三大器：迭代器、生成器、装饰器。&lt;/p&gt;

&lt;h3 id=&#34;division&#34;&gt;division&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;division = _Feature((2, 2, 0, &amp;quot;alpha&amp;quot;, 2),
                    (3, 0, 0, &amp;quot;alpha&amp;quot;, 0),
                    CO_FUTURE_DIVISION)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个很简单，举例说明一下大家就懂了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# python2.7中，不导入__future__
&amp;gt;&amp;gt;&amp;gt; 10/3
3

# 导入__future__
&amp;gt;&amp;gt;&amp;gt; from __future__ import division
&amp;gt;&amp;gt;&amp;gt; 10/3
3.3333333333333335
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;很容易看出来，2.7中默认的整数除法是结果向下取整，而导入了__future__之后除法就是真正的除法了。这也是python2和python3的一个重要区别。&lt;/p&gt;

&lt;h3 id=&#34;absolute-import&#34;&gt;absolute_import&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;absolute_import = _Feature((2, 5, 0, &amp;quot;alpha&amp;quot;, 1),
                           (3, 0, 0, &amp;quot;alpha&amp;quot;, 0),
                           CO_FUTURE_ABSOLUTE_IMPORT)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;python2.7中，在默认情况下，导入模块是相对导入的（relative import），比如说&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from . import json
from .json import json_dump
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这些以&amp;rsquo;.&amp;lsquo;点导入的是相对导入，而绝对导入（absolute import）则是指从系统路径sys.path最底层的模块导入。比如:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import os
from os import sys
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;with-statement&#34;&gt;with_statement&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;with_statement = _Feature((2, 5, 0, &amp;quot;alpha&amp;quot;, 1),
                          (2, 6, 0, &amp;quot;alpha&amp;quot;, 0),
                          CO_FUTURE_WITH_STATEMENT)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;with语句也不详细讲了，看这篇&lt;a href=&#34;http://blog.syfun.net/2015/07/07/python-with-statement&#34;&gt;浅谈Python的with语句&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;print-function&#34;&gt;print_function&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;print_function = _Feature((2, 6, 0, &amp;quot;alpha&amp;quot;, 2),
                          (3, 0, 0, &amp;quot;alpha&amp;quot;, 0),
                          CO_FUTURE_PRINT_FUNCTION)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个就是最经典的python2和python3的区别了，python2中print不需要括号，而在python3中则需要。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# python2.7
print &amp;quot;Hello world&amp;quot;

# python3
print(&amp;quot;Hello world&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;unicode-literals&#34;&gt;unicode_literals&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;unicode_literals = _Feature((2, 6, 0, &amp;quot;alpha&amp;quot;, 2),
                            (3, 0, 0, &amp;quot;alpha&amp;quot;, 0),
                            CO_FUTURE_UNICODE_LITERALS)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是unicode的问题，讲起来又是长篇大论了，容我偷个懒，后面再讲吧。&lt;/p&gt;

&lt;p&gt;至此，__future__模块的几个特性，算是说完了。好多内容都是参照官方文档，所以大家还是多看文档吧。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Paste deployment(转)</title>
      <link>/post/paste-deploy/</link>
      <pubDate>Sat, 09 Aug 2014 19:16:16 +0800</pubDate>
      
      <guid>/post/paste-deploy/</guid>
      <description>&lt;p&gt;转载自&lt;a href=&#34;http://blog.csdn.net/ztejiagn/article/details/8722765&#34;&gt;Python.Paste指南之Deploy&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Paste.Deploy主要是用来载入WSGI中的Web App应用，其核心函数是loadapp(),下文中PD就指代Paste.Deploy。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;简介及安装&#34;&gt;简介及安装&lt;/h2&gt;

&lt;p&gt;Paste Deployment是一种机制，通过loadapp函数和一个配置文件或者egg包来载入WSGI应用。可以通过Pip或者easy_install安装。&lt;/p&gt;

&lt;h2 id=&#34;配置文件config-flie&#34;&gt;配置文件Config Flie&lt;/h2&gt;

&lt;p&gt;一个配置文件后缀为ini，内容被分为很多段（section），PD只关心带有前缀的段，比如[app:main]或者[filter:errors]，总的来说，一个section的标识就是[type:name],不是这种类型的section将会被忽略。&lt;br/&gt;
一个section的内容是以键=值来标示的。#是一个注释。在段的定义中，有以下几类：&lt;br/&gt;
[app:main]:定义WSGI应用，main表示只有一个应用，有多个应用的话main改为应用名字&lt;br/&gt;
[server:main]:定义WSGI的一个server。&lt;br/&gt;
[composite:xxx]：表示需要将一个请求调度定向（dispatched）到多个,或者多种应用上。以下是一个简单的例子，例子中，使用了composite，通过urlmap来实现载入多应用。&lt;br/&gt;
[fliter:]：定义“过滤器”，将应用进行进一步的封装。&lt;br/&gt;
[DEFAULT]：定义一些默认变量的值。&lt;/p&gt;

&lt;p&gt;以下是一个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[composite:main]
use = egg:Paste#urlmap
/ = home
/blog = blog
/wiki = wiki
/cms = config:cms.ini

[app:home]
use = egg:Paste#static
document_root = %(here)s/htdocs

[filter-app:blog]
use = egg:Authentication#auth
next = blogapp
roles = admin
htpasswd = /home/me/users.htpasswd

[app:blogapp]
use = egg:BlogApp
database = sqlite:/home/me/blog.db

[app:wiki]
use = call:mywiki.main:application
database = sqlite:/home/me/wiki.db
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面会进行分段的讲解&lt;/p&gt;

&lt;h3 id=&#34;composite&#34;&gt;composite&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[composite:main]
use = egg:Paste#urlmap
/ = home
/blog = blog
/wiki = wiki
/cms = config:cms.ini
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是一个composite段，表示这将会根据一些条件将web请求调度到不同的应用。use = egg:Paste#urlmap表示我们奖使用Pasteegg包中urlmap来实现composite，这一个段(urlmap)可以算是一个通用的composite程序了。根据web请求的path的前缀进行一个到应用的映射(map)。这些被映射的程序就包括blog,home,wiki,config:cms.ini（映射到了另外一个配置文件，PD再根据这个文件进行载入）&lt;/p&gt;

&lt;h3 id=&#34;app-type1&#34;&gt;App type1&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[app:home]
use = egg:Paste#static
document_root = %(here)s/htdocs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;app是一个callable object，接受的参数(environ,start_response)，这是paste系统交给application的，符合WSGI规范的参数. app需要完成的任务是响应envrion中的请求，准备好响应头和消息体，然后交给start_response处理，并返回响应消息体。egg:Paste#static也是Paste包中的一个简单程序，它只处理静态文件。它需要一个配置文件document_root,后面的值可以是一个变量,形式为%（var）s相应的值应该在[DEFAULT]字段指明以便Paste读取。比如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[app:test]
use = egg:Paste#static
document_root = %(path)s/htdocs
[DEFAULT]
path = /etc/test
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;fliter&#34;&gt;fliter&lt;/h3&gt;

&lt;p&gt;filter是一个callable object，其唯一参数是(app)，这是WSGI的application对象，filter需要完成的工作是将application包装成另一个application（“过滤”），并返回这个包装后的application。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[filter-app:blog]
use = egg:Authentication#auth
next = blogapp
roles = admin
htpasswd = /home/me/users.htpasswd

[app:blogapp]
use = egg:BlogApp
database = sqlite:/home/me/blog.db
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;[filter-app:blog]fliter-app字段表明你希望对某个应用进行包装，需要包装的应用通过next指明（表明在下一个段中），这个字段的意思就是，在正式调用blogapp之前，我会调用egg:Authentication#auth进行一个用户的验证，随后才会调用blogapp进行处理。后面的[app:blogapp]则是定义了blogapp，并指明了需要的database参数。&lt;/p&gt;

&lt;h3 id=&#34;app-type2&#34;&gt;App type2&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[app:wiki]
use = call:mywiki.main:application
database = sqlite:/home/me/wiki.db
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个段和之前的app段定义类似，不同的是对于wiki这个应用，我们没有使用egg包，而是直接对mywiki.main这个模块中的application对象使用了call方法。python，中一切皆对象，作为WSGI app的可以是一个函数，一个类，或者一个实例，使用call的话，相应的函数，类，实例中必须实现call()方法。此类app的格式用冒号分割: call(表示使用call方法):模块的完成路径名字:应用变量的完整名字&lt;/p&gt;

&lt;h2 id=&#34;基本使用&#34;&gt;基本使用&lt;/h2&gt;

&lt;p&gt;PD的主要使用就是通过读取配置文件载入WSGI应用。如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from paste.deploy import loadapp
wsgi_app = loadapp(&#39;config:/path/to/config.ini&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意，这里需要指明绝对路径。&lt;/p&gt;

&lt;h2 id=&#34;更多关于配置文件&#34;&gt;更多关于配置文件&lt;/h2&gt;

&lt;h3 id=&#34;app&#34;&gt;App&lt;/h3&gt;

&lt;p&gt;单个配置文件中可以定义多个应用个，每个应用有自己独立的段。应用的定义以[app:name]的格式，[app:main]表示只有一个应用。应用的定义支持以下五种格式：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[app:myapp]
use = config:another_config_file.ini#app_name
#使用另外一个配置文件

[app:myotherapp]
use = egg:MyApp
#使用egg包中的内容

[app:mythirdapp]
use = call:my.project:myapplication
#使用模块中的callable对象

[app:mylastapp]
use = myotherapp
#使用另外一个section

[app:myfacapp]
paste.app_factory = myapp.modulename:app_factory
#使用工厂函数
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中，最后一种方式，将一个app指向了某些python代码。此模式下，必须执行app协议，以app_factory表示，后面的值需要import的东西，在这个例子中myapp.modulename被载入，并从其中取得了app_factory的实例。&lt;br/&gt;
app_factory是一个callable object，其接受的参数是一些关于application的配置信息：(global_conf,**kwargs)，global_conf是在ini文件中default section中定义的一系列key-value对，而**kwargs，即一些本地配置，是在ini文件中，app:xxx section中定义的一系列key-value对。app_factory返回值是一个application对象&lt;br/&gt;
在app的配置中，use参数以后配置就算结束了。其余的键值参数将会作为参数，传递到factory中，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[app:blog]
use = egg:MyBlog
database = mysql://localhost/blogdb #这是参数
blogname = This Is My Blog! #这是参数
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;全局配置&#34;&gt;全局配置&lt;/h3&gt;

&lt;p&gt;全局配置主要是用于多个应用共用一些变量，这些变量我们规定放在段[DEFAULT]中，如果需要覆盖，可以在自己的app中重新定义，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[DEFAULT]
admin_email = webmaster@example.com
[app:main]
use = ...
set admin_email = bob@example.com
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;composite-app&#34;&gt;composite app&lt;/h3&gt;

&lt;p&gt;composite是一个运行着像是app，但是实际上是由多个应用组成的。urlmap就是composite app的一个例子，url不同的path对应了不同的应用。如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[composite:main]
use = egg:Paste#urlmap
/ = mainapp
/files = staticapp

[app:mainapp]
use = egg:MyApp

[app:staticapp]
use = egg:Paste#static
document_root = /path/to/docroot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在loadapp函数的执行中，composite app被实例化，它同时还会访问配置文件中定义的其他应用。&lt;/p&gt;

&lt;h3 id=&#34;app定义高级用法&#34;&gt;app定义高级用法&lt;/h3&gt;

&lt;p&gt;在app段中，你可以定义fliters和servers，通过fliter:和server: PD通过loadserver和loadfilter函数进行调用，工作机制都一样，返回不同的对象。&lt;/p&gt;

&lt;h3 id=&#34;filter-composition&#34;&gt;filter composition&lt;/h3&gt;

&lt;p&gt;应用filter的方式很多，重要的是看你filter的数量和组织形式。下面会一一介绍应用fliter的几种方式：&lt;/p&gt;

&lt;h4 id=&#34;使用filter-with&#34;&gt;使用filter-with&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[app:main]
use = egg:MyEgg
filter-with = printdebug

[filter:printdebug]
use = egg:Paste#printdebug
# and you could have another filter-with here, and so on...
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;使用fliter-app&#34;&gt;使用fliter-app&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[fliter-app:printdebug]
use = egg:Paste
next = main

[app:main]
use = egg:MyEgg
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;使用pipeline&#34;&gt;使用pipeline&lt;/h4&gt;

&lt;p&gt;当使用多个filter的时候需要使用pipeline的方式，它需要提供一个key参数pipeline,后面的值是一个列表，最后以应用结尾。如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[pipeline:main]
pipeline = filter1 egg:FilterEgg#filter2 filter3 app

[filter:filter1]
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;假设在ini文件中, 某条pipeline的顺序是filter1, filter2, filter3，app, 那么，最终运行的app_real是这样组织的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;app_real = filter1(filter2(filter3(app)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在app真正被调用的过程中，filter1.__call__(environ,start_response)被首先调用，若某种检查未通过，filter1做出反应；否则交给filter2.__call__(environ,start_response)进一步处理，若某种检查未通过，filter2做出反应，中断链条，否则交给filter3.__call__(environ,start_response)处理，若filter3的某种检查都通过了，最后交给app.__call__(environ,start_response)进行处理。&lt;/p&gt;

&lt;h4 id=&#34;读取配置文件&#34;&gt;读取配置文件&lt;/h4&gt;

&lt;p&gt;如果希望在不创建应用的情况下得到配置文件，可以使用appconfig(uri)函数，将会以字典形式返回使用的配置。这个字典包括了全局很本地的配置信息，所以可以通过属性方法获得相应的attributes （.local_conf and .global_conf）&lt;/p&gt;

&lt;h2 id=&#34;其他&#34;&gt;其他&lt;/h2&gt;

&lt;h3 id=&#34;如何引用egg包&#34;&gt;如何引用Egg包&lt;/h3&gt;

&lt;p&gt;egg是python的一个包，pip easy_install等都是安装egg包的方式。关注egg包要注意： +某一egg包是有标准说明的&lt;br/&gt;
python setup.py name +有entry point，不用太在意，这个只是说明调用程序的参数。&lt;/p&gt;

&lt;h3 id=&#34;定义factory函数&#34;&gt;定义factory函数&lt;/h3&gt;

&lt;p&gt;工厂函数的定义还是遵循之前提到的应用的协议。目前，用于工厂函数的协议有以下：&lt;br/&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;paste.app_factory&lt;/li&gt;
&lt;li&gt;paste.composite_factory&lt;/li&gt;
&lt;li&gt;paste.filter_factory&lt;/li&gt;
&lt;li&gt;paste.server_factory&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所有的这些都希望有一个含有__call__方法的（函数，方法，类）。&lt;/p&gt;

&lt;h4 id=&#34;paste-app-factory&#34;&gt;paste.app_factory&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def app_factory(global_config, **local_conf):
    return wsgi_app
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;global_config是一个字典，而local_conf则是关键字参数。返回一个wsgi_app（含有call方法。）&lt;/p&gt;

&lt;h4 id=&#34;paste-composite-factory&#34;&gt;paste.composite_factory&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def composite_factory(loader, global_config, **local_conf):
   return wsgi_app
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;loader是一个对象，有几个有趣的方法,get_app(name_or_uri, global_conf=None)根据name返回一个wsgi应用，get_filter（）和get_server（）也是一样。看一个更加复杂的例子，举例一个pipeline应用：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def pipeline_factory(loader, global_config, pipeline):
    # space-separated list of filter and app names:
    pipeline = pipeline.split()
    filters = [loader.get_filter(n) for n in pipeline[:-1]]
    app = loader.get_app(pipeline[-1])
    filters.reverse() # apply in reverse order!
    for filter in filters:
      app = filter(app)
    return app
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;相应的配置文件如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[composite:main]
use = &amp;lt;pipeline_factory_uri&amp;gt;
pipeline = egg:Paste#printdebug session myapp

[filter:session]
use = egg:Paste#session
store = memory

[app:myapp]
use = egg:MyApp
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;paste-filter-factory&#34;&gt;paste.filter_factory&lt;/h4&gt;

&lt;p&gt;fliter的工厂函数和app的共产函数类似，除了它返回的是一个filter,fliter是一个仅仅把一个wsgi应用作为唯一参数的callable对象，返回一个被filter了的应用。 以下是一个例子，这个filter会检查CGI中REMOTE_USER变量是否存在，并创建一个简单的认证过滤器。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def auth_filter_factory(global_conf, req_usernames):
    # space-separated list of usernames:
    req_usernames = req_usernames.split()
    def filter(app):
        return AuthFilter(app, req_usernames)
    return filter

class AuthFilter(object):
    def __init__(self, app, req_usernames):
        self.app = app
        self.req_usernames = req_usernames

def __call__(self, environ, start_response):
    if environ.get(&#39;REMOTE_USER&#39;) in self.req_usernames:
            return self.app(environ, start_response)
    start_response(
            &#39;403 Forbidden&#39;, [(&#39;Content-type&#39;, &#39;text/html&#39;)])
    return [&#39;You are forbidden to view this resource&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;paste-filter-app-factory&#34;&gt;paste.filter_app_factory&lt;/h4&gt;

&lt;p&gt;和paste.filter_factory类似，接受一个wsgi应用参数，返回一个WSGI应用，所以如果改变以上代码的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class AuthFilter(object):
    def __init__(self, app, global_conf, req_usernames):
        ....
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么，类 AuthFilter就会作为一个filter_app_factory函数使用。&lt;/p&gt;

&lt;h4 id=&#34;paste-server-factory&#34;&gt;paste.server_factory&lt;/h4&gt;

&lt;p&gt;与以上不同的是，函数返回的是一个server,一个server也是一个callable对象，以一个WSGI应用作为参数，而后为这个应用服务。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def server_factory(global_conf, host, port):
    port = int(port)
    def serve(app):
        s = Server(app, host=host, port=port)
        s.serve_forever()
    return serve
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Server的实现用户可以自定义，可以参考python包wsgiref&lt;/p&gt;

&lt;h4 id=&#34;paste-server-runner&#34;&gt;paste.server_runner&lt;/h4&gt;

&lt;p&gt;与 paste.server_factory类似，不同的是参数格式。&lt;/p&gt;

&lt;h2 id=&#34;代码实践&#34;&gt;代码实践&lt;/h2&gt;

&lt;h3 id=&#34;配置文件&#34;&gt;配置文件&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[DEFAULT]
company = UESTC
school = Commuication and Information

[composite:common]
use = egg:Paste#urlmap
/ = showversion
/detail = showdetail

[pipeline:showdetail]
pipeline = filter1 filter2 showstudetail

[filter:filter1]
#filter1 deal with auth,read args below
paste.filter_factory = python_paste:AuthFilter.factory
user = admin
passwd = admin

[filter:filter2]
#filter2 deal with time,read args below
paste.filter_factory = python_paste:LogFilter.factory
#all value is string
date = 20121120

[app:showstudetail]
name = wangchang
age = 23
paste.app_factory = python_paste:ShowStuDetail.factory

[app:showversion]
version = 1.0.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从配置文件可以看出，这个程序会有如下操作：&lt;/p&gt;

&lt;p&gt;对于&lt;a href=&#34;http://localhost/的访问，会调用showversion这个应用，应用读取ini文件中的version值并返回。注意，在ini中的所有值都是字符串。&#34;&gt;http://localhost/的访问，会调用showversion这个应用，应用读取ini文件中的version值并返回。注意，在ini中的所有值都是字符串。&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;对于&lt;a href=&#34;http://localhost/detail的访问，会先经过filter1以及filter2，这两个filter分别处理认证和LOG信息，他们会读取ini配置中的用户信息以及时间。最后才是交给showstudetail处理，showstudetail会读取ini中的用户信息并返回。注意，使用多个filter的时候需要使用pipeline方式。&#34;&gt;http://localhost/detail的访问，会先经过filter1以及filter2，这两个filter分别处理认证和LOG信息，他们会读取ini配置中的用户信息以及时间。最后才是交给showstudetail处理，showstudetail会读取ini中的用户信息并返回。注意，使用多个filter的时候需要使用pipeline方式。&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# -*- coding:utf-8 -*-
__author__ = &#39;sunyu&#39;

import os
from webob import Request
from webob import Response
from paste.deploy import loadapp
from wsgiref.simple_server import make_server


class AuthFilter(object):
    &amp;quot;&amp;quot;&amp;quot;filter1,auth
       1.factory read args and print,return self instance
       2.call method return app
       3.AuthFilter(app)
    &amp;quot;&amp;quot;&amp;quot;

    def __init__(self, app):
        self.app = app

    def __call__(self, environ, start_response):
        print &#39;this is Auth call filter1&#39;
        #pass environ and start_response to app
        return self.app(environ, start_response)

    @classmethod
    def factory(cls, global_conf, **kwargs):
        &amp;quot;&amp;quot;&amp;quot;global_conf and kwargs are dict&amp;quot;&amp;quot;&amp;quot;
        print &#39;######filter1##########&#39;
        print &#39;global_conf type:&#39;, type(global_conf)
        print &#39;[DEFAULT]&#39;, global_conf
        print &#39;kwargs type:&#39;, type(kwargs)
        print &#39;Auth Info&#39;, kwargs

        return AuthFilter


class LogFilter(object):
    &amp;quot;&amp;quot;&amp;quot;filter2,Log&amp;quot;&amp;quot;&amp;quot;

    def __init__(self, app):
        self.app = app

    def __call__(self, environ, start_response):
        print &#39;This is call LogFilter filter2&#39;
        return self.app(environ,start_response)

    @classmethod
    def factory(cls, global_conf, **kwargs):
        #print type(global_conf)
        #print type(kwargs)
        print &#39;######filter2###########&#39;
        print &#39;[DEFAULT]&#39;, global_conf
        print &#39;Log Info&#39;, kwargs

        return LogFilter


class ShowStuDetail(object):
    &amp;quot;&amp;quot;&amp;quot;app&amp;quot;&amp;quot;&amp;quot;
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __call__(self, environ, start_response):
        print &#39;this is call ShowStuDetail&#39;
        start_response(&amp;quot;200 OK&amp;quot;, [(&amp;quot;Content-type&amp;quot;, &amp;quot;text/plain&amp;quot;)])
        content = []
        content.append(&amp;quot;name: %s age:%s\n&amp;quot; % (self.name, self.age))
        content.append(&amp;quot;**********WSGI INFO***********\n&amp;quot;)

        for k, v in environ.iteritems():
            content.append(&#39;%s:%s \n&#39; % (k, v))

        return [&#39;\n&#39;.join(content)]

    @classmethod
    def factory(cls, global_conf, **kwargs):
        #self.name = kwargs[&#39;name&#39;]
        #self.age = kwargs[&#39;age&#39;]
        return ShowStuDetail(kwargs[&#39;name&#39;],kwargs[&#39;age&#39;])


class ShowVersion(object):
    &amp;quot;&amp;quot;&amp;quot;app&amp;quot;&amp;quot;&amp;quot;
    def __init__(self, version):
        self.version = version

    def __call__(self, environ, start_response):
        print &#39;this is call ShowVersion&#39;
        req = Request(environ)
        res = Response()
        res.status = &#39;200 OK&#39;
        res.content_type = &amp;quot;text/plain&amp;quot;
        content = []

        content.append(&amp;quot;%s\n&amp;quot; % self.version)
        content.append(&amp;quot;*********WSGI INFO*********&amp;quot;)
        for k, v in environ.iteritems():
            content.append(&#39;%s:%s\n&#39; % (k, v))
        res.body = &#39;\n&#39;.join(content)
        return res(environ,start_response)

    @classmethod
    def factory(cls, global_conf, **kwargs):
        #self.version = kwargs[&#39;version&#39;]
        return ShowVersion(kwargs[&#39;version&#39;])

if __name__ == &#39;__main__&#39;:
    config = &amp;quot;python_paste.ini&amp;quot;
    app_name = &amp;quot;common&amp;quot;
    app = loadapp(&amp;quot;config:%s&amp;quot; % os.path.abspath(config), app_name)
    server = make_server(&#39;localhost&#39;, 7070, app)
    server.serve_forever()
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Openstack oslo.config介绍(转)</title>
      <link>/post/oslo-config/</link>
      <pubDate>Fri, 11 Jul 2014 19:15:05 +0800</pubDate>
      
      <guid>/post/oslo-config/</guid>
      <description>&lt;p&gt;&lt;strong&gt;本文转自&lt;a href=&#34;http://blog.csdn.net/networm3/article/details/8946556&#34;&gt;OpenStack源码探秘（二）——Oslo.config&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;oslo.config, OpenStack中负责CLI和CONF配置项解析的组件。E版本前，这个功能是放在cfg模块中的，
后来社区中考虑将OpenStack中共性的组件都剥离出来，统一放在oslo模块中。今后开发新的OpenStack组件，估计都要用到Oslo模块。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;下面说明一下用法：
在oslo的cfg模块载入的时候(from oslo.config import cfg)，会自动运行模块中的载入代码CONF = ConfigOpts()，
创建一个全局的配置项管理类。和许多Conf配置模块一样，oslo.conf在使用时，需要先声明配置项的名称、定义类型、帮助文字、缺省值等，
然后再按照事先声明的配置项，对CLI或conf中的内容进行解析。&lt;br /&gt;
配置项声明结构示例如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;common_opts = [
    cfg.StrOpt(&#39;bind_host&#39;,
           default=&#39;0.0.0.0&#39;,
               help=&#39;IP address to listen on&#39;),
    cfg.IntOpt(&#39;bind_port&#39;,
               default=9292,
               help=&#39;Port number to listen on&#39;)
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;类型的定义对应Opt的各个子类。&lt;br /&gt;
oslo使用register_opt方法，将配置项定义向配置项管理类configOpts的注册是在程序的运行时刻，但是必须在配置项的引用前完成。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;CONF = cfg.CONF
CONF.register_opts(common_opts)

port = CONF.bind_port
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用conf.register_cli_opts()方法，配置项还可以在管理类ConfigOpts中可选注册为CLI配置项，
通过程序运行的CLI参数中获得配置项取值，并在错误打印时，自动输出给CLI配置项参数的帮助文档。&lt;br /&gt;
conf配置文件采用的是ini风格的格式&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;  glance-api.conf:
    [DEFAULT]
    bind_port = 9292
      ...

    [rabbit]
    host = localhost
    port = 5672
    use_ssl = False
    userid = guest
    password = guest
    virtual_host = /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后通过ConfigOpts类的&lt;strong&gt;call()&lt;/strong&gt;方法，执行配置项的解析以及从CLI或配置文件读取配置项的值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def __call__(self,
             args=None,
             project=None,
             prog=None,
             version=None,
             usage=None,
             default_config_files=None):
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是一个完整的示例&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from oslo.config import cfg

opts = [
    cfg.StrOpt(&#39;bind_host&#39;, default=&#39;0.0.0.0&#39;),
    cfg.IntOpt(&#39;bind_port&#39;, default=9292),
]

CONF = cfg.CONF
CONF.register_opts(opts)
CONF(default_config_files=&#39;glance.conf&#39;)
def start(server, app):
    server.start(app, CONF.bind_port, CONF.bind_host)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OpenStack项目的配置项声明和许多其他开源Python项目一样，配置项声明是放在各个调用的模块里面的。
也就是说哪里用到才到哪里声明。我觉得这种方式是完全体现了Pthonic的一种声明方式，有别于其他方式，
程序员在阅读程序的时候可以非常方便的在文件开头就能找到配置项的声明定义，而不用到某个指定的文件去查找，实现了KISS的原则。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>