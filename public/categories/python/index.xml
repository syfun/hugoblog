<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Python on Sung Yung</title>
    <link>/categories/python/index.xml</link>
    <description>Recent content in Python on Sung Yung</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="/categories/python/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Pythons HOWTO之属性描述符</title>
      <link>/post/python-howto-descriptor/</link>
      <pubDate>Sat, 08 Aug 2015 22:27:41 +0800</pubDate>
      
      <guid>/post/python-howto-descriptor/</guid>
      <description>&lt;p&gt;今天开个新坑，Pythons HOWTOS系列，主要是对官方文档的翻译。由于英语水平有限，基本上都是意译。这里附上&lt;a href=&#34;https://docs.python.org/2.7/howto/index.html&#34;&gt;链接&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;本篇是第一篇，主要说的是&lt;a href=&#34;https://docs.python.org/2.7/howto/descriptor.html#id2&#34;&gt;属性描述符&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;摘要&#34;&gt;摘要&lt;/h2&gt;

&lt;p&gt;本篇的内容主要是定义属性描述符(descriptor)，概述一下描述符协议的内容。通过自定义的的一个描述符和Python内建的描述符(functions, properties, static methods, class methods)来演示属性描述符是如何调用的。同时会给出相同功能的Python实现代码和一个简单的程序。&lt;/p&gt;

&lt;p&gt;属性描述符不仅给一个大的工具集(暂时没发现是什么)提供了接口，它还能加深理解Python的工作原理和优雅的设计思想。&lt;/p&gt;

&lt;h2 id=&#34;定义和介绍&#34;&gt;定义和介绍&lt;/h2&gt;

&lt;p&gt;一般来说，一个描述符是一个有“绑定行为”的对象属性，这个属性访问被描述符协议中的方法所覆盖。这些方法是__get__()，__set__()和__delete__()。如果某个对象定义了其中一个，那么这个对象就可以被叫做描述符。&lt;/p&gt;

&lt;p&gt;访问属性默认通过get，set或者是delete来操作对象属性字典来实现。例如，a.x有一个查找队列，从a.__dict__[&amp;lsquo;x&amp;rsquo;]开始，然后是type(a).__dict__[&amp;lsquo;x&amp;rsquo;]，接着是type(a)的基类(metaclass除外)，以此类推。如果查找的是一个定义了描述符方法的对象，那么Python会覆盖默认行为而去调用描述符方法。发生在优先级队列的哪个位置取决于定义的描述符方法。注意，属性描述符只适用于新式类(从object或者typ继承的类)。&lt;/p&gt;

&lt;p&gt;属性描述符是一个强大的通用协议。它是properties, methods, static methods, class methods 和super()的调用原理。它贯穿整个Python，并且用来实现2.2版本中引进的新式类。属性描述符简化了底层的C代码，还为日常Python编程提供了新的工具集。&lt;/p&gt;

&lt;h2 id=&#34;描述符协议&#34;&gt;描述符协议&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;descr.__get__(self, obj, type=None) --&amp;gt; value

descr.__set__(self, obj, value) --&amp;gt; None

descr.__delete__(self, obj) --&amp;gt; None
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的三个方法就是协议的全部内容了。定义其中任意一个方法的对象就被称为属性描述符，能够覆盖默认的属性查找规则。&lt;/p&gt;

&lt;p&gt;如果一个对象同时定义了__get__和__set__方法，它被称做数据描述符(data descriptor)。只定义__get__方法的对象则被称为非数据描述符(non-data descriptor，一般用在函数方法上，其他用法也是可能的)。&lt;/p&gt;

&lt;p&gt;数据和非数据描述符的区别在于如果某个实例属性字典中有项和描述符同名，那么属性访问的优先级是不同的。数据描述符的优先级比实例字典中项的高，非数据描述符则相反。&lt;/p&gt;

&lt;p&gt;举个例子说明一下优先级问题:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class DataDesc(object):

    def __init__(self, name=None):
        self.name = name
        self.value = None

    def __get__(self, obj, type=None):
        return self.value

    def __set__(self, obj, value):
        self.value = value


class NonDataDesc(object):

    def __init__(self, name=None):
        self.name = name
        self.value = None

    def __get__(self, obj, type=None):
        return self.value


class DataTest(object):
    x = DataDesc()


class NonDataTest(object):
    x = NonDataDesc()

&amp;gt;&amp;gt;&amp;gt; d = DataTest()
&amp;gt;&amp;gt;&amp;gt; nd = NonDataTest()
&amp;gt;&amp;gt;&amp;gt; d.__dict__[&#39;x&#39;] = 2
&amp;gt;&amp;gt;&amp;gt; nd.__dict__[&#39;x&#39;] = 2
&amp;gt;&amp;gt;&amp;gt; print d.__dict__, nd.__dict__
{&#39;x&#39;: 2} {&#39;x&#39;: 2}
&amp;gt;&amp;gt;&amp;gt; print d.x, nd.x
None 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果想要构造一个只读的数据描述符，同时定义__get__和__set__方法，并且__set__调用时引发一个AtrributeError异常。&lt;/p&gt;

&lt;h2 id=&#34;属性描述符调用&#34;&gt;属性描述符调用&lt;/h2&gt;

&lt;p&gt;一个属性描述符可以通过它的方法名直接调用。比如，d.__get__(obj)。更常见的方式是通过属性访问自动调用。比如，obj.d在obj的字典中查找d。如果d定义了__get__()，那么根据下文将要提到的优先级规则，d.__get__(obj)将会被调用。&lt;/p&gt;

&lt;p&gt;调用的细节由obj是对象还是类来决定。&lt;/p&gt;

&lt;p&gt;对于对象，访问是调用object.__getattribute__()，其中将b.x转换成type(b).__dict__[&amp;lsquo;x&amp;rsquo;].__get__(b, type(b))。在实现中，数据描述符优先级最高，依次是实例变量，非数据描述符，最后是__getattr__()(如果定义了)。C实现能够在&lt;a href=&#34;https://hg.python.org/cpython/file/2.7/Objects/object.c&#34;&gt;Objects/object.c&lt;/a&gt;中的&lt;a href=&#34;https://docs.python.org/2.7/c-api/object.html#c.PyObject_GenericGetAttr&#34;&gt;PyObject_GenericGetAttr()&lt;/a&gt;找到。&lt;/p&gt;

&lt;p&gt;对于类，访问是调用type.__getattribute__()，其中将B.x转换成B.__[&amp;lsquo;x&amp;rsquo;].__get__(None, B)。如果用Python实现，它是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def __getattribute__(self, key):
    &amp;quot;Emulate type_getattro() in Objects/typeobject.c&amp;quot;
    v = object.__getattribute__(self, key)
    if hasattr(v, &#39;__get__&#39;):
       return v.__get__(None, self)
    return v
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要记住下面几个重要的点:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;描述符通过__getattribute__()被调用&lt;/li&gt;
&lt;li&gt;重写__getattribute__()能够改变自动的调用&lt;/li&gt;
&lt;li&gt;__getattribute__()只适用于新式类&lt;/li&gt;
&lt;li&gt;object.__getattribute__()和type.__getattribute__()调用__get__()的方式不同&lt;/li&gt;
&lt;li&gt;数据描述符总是覆盖实例字典&lt;/li&gt;
&lt;li&gt;非数据描述符可能被实例字典覆盖&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;super()返回的对象有一个自定义的__getattribute__()。调用super(B, obj).m()在obj.__class__.__mro__查找到紧跟在B后面的基类A，然后返回A.__dict__[&amp;rsquo;m&amp;rsquo;].__get__(obj, B)。如果不是一个描述符，m被原封不动的返回。如果不在字典中，m转而去调用object.__getattribute__()查找。&lt;/p&gt;

&lt;p&gt;注意，在Python2.2中，运行super(B, obj).m()时，如果m是一个数据描述符，将会只调用__get__()。在Python2.3中，除了是旧式类，非数据描述符也会得到调用。具体实现在&lt;a href=&#34;https://hg.python.org/cpython/file/2.7/Objects/typeobject.c&#34;&gt;Objects/typeobject.c&lt;/a&gt;的super_getattro()中。&lt;/p&gt;

&lt;p&gt;综上所述，描述符机制嵌入到了object、type和super()的__getattribute__()方法中。如果类需要这个机制，必须继承自object或者是有metaclass提供类似的功能。同样的，也可以通过重写__getattribute__()来改变属性描述符。&lt;/p&gt;

&lt;h2 id=&#34;属性描述符示例&#34;&gt;属性描述符示例&lt;/h2&gt;

&lt;p&gt;下面的代码创建了一个类，它的实例对象是数据描述符，get和set方法中都打印了一条信息。重写__getattribute__()方法也可以做到这个。但是，使用描述符对监控一些属性很有用：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class RevealAccess(object):
    &amp;quot;&amp;quot;&amp;quot;A data descriptor that sets and returns values
       normally and prints a message logging their access.
    &amp;quot;&amp;quot;&amp;quot;

    def __init__(self, initval=None, name=&#39;var&#39;):
        self.val = initval
        self.name = name

    def __get__(self, obj, objtype):
        print &#39;Retrieving&#39;, self.name
        return self.val

    def __set__(self, obj, val):
        print &#39;Updating&#39;, self.name
        self.val = val

&amp;gt;&amp;gt;&amp;gt; class MyClass(object):
    x = RevealAccess(10, &#39;var &amp;quot;x&amp;quot;&#39;)
    y = 5

&amp;gt;&amp;gt;&amp;gt; m = MyClass()
&amp;gt;&amp;gt;&amp;gt; m.x
Retrieving var &amp;quot;x&amp;quot;
10
&amp;gt;&amp;gt;&amp;gt; m.x = 20
Updating var &amp;quot;x&amp;quot;
&amp;gt;&amp;gt;&amp;gt; m.x
Retrieving var &amp;quot;x&amp;quot;
20
&amp;gt;&amp;gt;&amp;gt; m.y
5
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;properties&#34;&gt;Properties&lt;/h2&gt;

&lt;p&gt;使用property()能够把数据描述符变成属性调用。形式如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;property(fget=None, fset=None, fdel=None, doc=None) -&amp;gt; property attribute
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一个典型的用法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class C(object):
    def getx(self): return self.__x
    def setx(self, value): self.__x = value
    def delx(self): del self.__x
    x = property(getx, setx, delx, &amp;quot;I&#39;m the &#39;x&#39; property.&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以使用装饰器:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class C(object):
  @property
  def x(self):
    return self.__x

  @x.setter
  def setx(self, value):
    self.__x = value

  @x.deleter
  del delx(self):
    self.__x

&amp;gt;&amp;gt;&amp;gt; c = C()
&amp;gt;&amp;gt;&amp;gt; c.x = 2
&amp;gt;&amp;gt;&amp;gt; c.x
2
&amp;gt;&amp;gt;&amp;gt; del c.x
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;proptery()是C实现的，我们这里给出Python版本的等价实现：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Property(object):
    &amp;quot;Emulate PyProperty_Type() in Objects/descrobject.c&amp;quot;

    def __init__(self, fget=None, fset=None, fdel=None, doc=None):
        self.fget = fget
        self.fset = fset
        self.fdel = fdel
        if doc is None and fget is not None:
            doc = fget.__doc__
        self.__doc__ = doc

    def __get__(self, obj, objtype=None):
        if obj is None:
            return self
        if self.fget is None:
            raise AttributeError(&amp;quot;unreadable attribute&amp;quot;)
        return self.fget(obj)

    def __set__(self, obj, value):
        if self.fset is None:
            raise AttributeError(&amp;quot;can&#39;t set attribute&amp;quot;)
        self.fset(obj, value)

    def __delete__(self, obj):
        if self.fdel is None:
            raise AttributeError(&amp;quot;can&#39;t delete attribute&amp;quot;)
        self.fdel(obj)

    def getter(self, fget):
        return type(self)(fget, self.fset, self.fdel, self.__doc__)

    def setter(self, fset):
        return type(self)(self.fget, fset, self.fdel, self.__doc__)

    def deleter(self, fdel):
        return type(self)(self.fget, self.fset, fdel, self.__doc__)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一个电子表格类可能通过Cell(&amp;lsquo;b10&amp;rsquo;).value访问某个单元，后面希望改进成每次访问都重新计算。但是开发者不想直接改变现有的属性访问代码。那么便可以用proptery数据描述符封装属性访问。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Cell(object):
    . . .
    def getvalue(self, obj):
        &amp;quot;Recalculate cell before returning value&amp;quot;
        self.recalc()
        return obj._value
    value = property(getvalue)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;functions-and-methods&#34;&gt;Functions and methods&lt;/h2&gt;

&lt;p&gt;Python的面向对象特征是建立在基于函数的环境上。使用非数据描述符，两者能够无缝融合。&lt;/p&gt;

&lt;p&gt;类字典中用函数(function)形式存储方法(method)。在类的定义中，用def和lambda定义方法，这也是定义函数的方式。方法和普通函数唯一的区别是方法的第一个参数预留给了对象实例。按照Python的惯例，实例引用一般用self表示，当然也有可能用this或者其他变量表示。&lt;/p&gt;

&lt;p&gt;为了支持方法调用，函数中包含了__get__()属性。这意味着，所有的函数都是非数据描述符。对象和类的方法，__get__()返回值是不同的，分别绑定(bound)和非绑定(unbound)方法。如果用纯Python表示，可能是这样的:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Function(object):
    . . .
    def __get__(self, obj, objtype=None):
        &amp;quot;Simulate func_descr_get() in Objects/funcobject.c&amp;quot;
        return types.MethodType(self, obj, objtype)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; class D(object):
     def f(self, x):
          return x

&amp;gt;&amp;gt;&amp;gt; d = D()
&amp;gt;&amp;gt;&amp;gt; D.__dict__[&#39;f&#39;] # Stored internally as a function
&amp;lt;function f at 0x00C45070&amp;gt;
&amp;gt;&amp;gt;&amp;gt; D.f             # Get from a class becomes an unbound method
&amp;lt;unbound method D.f&amp;gt;
&amp;gt;&amp;gt;&amp;gt; d.f             # Get from an instance becomes a bound method
&amp;lt;bound method D.f of &amp;lt;__main__.D object at 0x00B18C90&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;bound和unbound方法是两个不同的类型。C实现中只是一个相同的对象的两种不同表现，区别就在于im_self被设置了或者是NULL值，具体实现位于&lt;a href=&#34;https://hg.python.org/cpython/file/2.7/Objects/classobject.c&#34;&gt;Objects/classobject.c&lt;/a&gt;中&lt;a href=&#34;https://docs.python.org/2.7/c-api/method.html#c.PyMethod_Type&#34;&gt;PyMethod_Type&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;同样地，调用方法时有没有im_self效果是不同的。如果被设置了，表明是bound方法，原始函数(存在im_func中)被调用，当然第一个参数被设置成对象实例。如果是unbound方法，所有参数原封不动地传给原始函数。C实现instancemethod_call()会更加复杂，因为有很多类型检测。&lt;/p&gt;

&lt;h2 id=&#34;static-methods-and-class-methods&#34;&gt;Static methods and class methods&lt;/h2&gt;

&lt;p&gt;函数有__get__()属性，所以当它们被当成属性访问时会被转变成方法。非数据描述符将obj.f(*args)转换成了f(obj, *args)。调用klass.f(*args)变成了f(*args)。&lt;/p&gt;

&lt;p&gt;下面这个表格总结了这转变方式，以及两个变种staticmethod和classmethod。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Transformation&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Called from an Object&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Called from a Class&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;function&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;f(obj, *args)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;f(*args)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;staticmethod&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;f(*args)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;f(*args)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;classmethod&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;f(type(obj), *args)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;f(klass, *args)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;静态方法没有对函数做任何改变。调用c.f等价于object.__getattribute__(c, &amp;ldquo;f&amp;rdquo;)，调C.f等于object.__getattribute__(C, &amp;ldquo;f&amp;rdquo;)。所以，对象和类对静态方法的调用方式是统一的。静态方法不需要self。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; class E(object):
     def f(x):
          print x
     f = staticmethod(f)

&amp;gt;&amp;gt;&amp;gt; print E.f(3)
3
&amp;gt;&amp;gt;&amp;gt; print E().f(3)
3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;纯Pythond的staticmethod()实现可能是这样的:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class StaticMethod(object):
 &amp;quot;Emulate PyStaticMethod_Type() in Objects/funcobject.c&amp;quot;

 def __init__(self, f):
      self.f = f

 def __get__(self, obj, objtype=None):
      return self.f
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而类方法的第一个参数是类的引用。也是分为对象调用和类调用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; class E(object):
     def f(klass, x):
          return klass.__name__, x
     f = classmethod(f)

&amp;gt;&amp;gt;&amp;gt; print E.f(3)
(&#39;E&#39;, 3)
&amp;gt;&amp;gt;&amp;gt; print E().f(3)
(&#39;E&#39;, 3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果函数只需要类引用而不关心底层的数据，那么类方法就会很有用。一个使用classmethod的例子是创建类构造器。在Python2.3中dict.fromkeys()从关键字列表中创建一个新的字典。纯Python可能是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Dict(object):
    . . .
    def fromkeys(klass, iterable, value=None):
        &amp;quot;Emulate dict_fromkeys() in Objects/dictobject.c&amp;quot;
        d = klass()
        for key in iterable:
            d[key] = value
        return d
    fromkeys = classmethod(fromkeys)

&amp;gt;&amp;gt;&amp;gt; Dict.fromkeys(&#39;abracadabra&#39;)
{&#39;a&#39;: None, &#39;r&#39;: None, &#39;b&#39;: None, &#39;c&#39;: None, &#39;d&#39;: None}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;classmethod的纯Python实现可能是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class ClassMethod(object):
     &amp;quot;Emulate PyClassMethod_Type() in Objects/funcobject.c&amp;quot;

     def __init__(self, f):
          self.f = f

     def __get__(self, obj, klass=None):
          if klass is None:
               klass = type(obj)
          def newfunc(*args):
               return self.f(klass, *args)
          return newfunc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;终于结束了，这篇断断续续的翻译了好几天，几次都想放弃了，但还是忍着翻译了下来，算是收获了许多。学习是没有捷径的。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Python装饰器的几种类型</title>
      <link>/post/python-decorate/</link>
      <pubDate>Mon, 27 Jul 2015 22:25:34 +0800</pubDate>
      
      <guid>/post/python-decorate/</guid>
      <description>&lt;p&gt;装饰器的原理就是闭包，这在&lt;a href=&#34;/post/python-bibao/&#34;&gt;前面&lt;/a&gt;已经提到过了。本篇主要记录一下装饰器的几种类型。&lt;/p&gt;

&lt;h2 id=&#34;无参数装饰器&#34;&gt;无参数装饰器&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def deco(func):
    def _deco(*args, **kwargs):
        print &#39;call deco&#39;
        func(*args, **kwargs)
    return _deco

@deco
def test():
    print &#39;call test&#39;

# 等同于
def test():
    print &#39;call test&#39;
test = deco(func)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;有参数装饰器&#34;&gt;有参数装饰器&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def deco(*args, **kwargs):
    def _deco(func):
        print args, kwargs
        def __deco(*args, **kwargs):
            print &#39;call deco&#39;
            func(*args, **kwargs)
        return __deco
    return _deco

@deco(&#39;hello&#39;, x=&#39;nihao&#39;)
def test():
    print &#39;call test&#39;

# 等同于
def test():
    print &#39;call test&#39;
test = deco(&#39;hello&#39;, x=&#39;nihao&#39;)(test)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;类装饰器&#34;&gt;类装饰器&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def deco(*args, **kwargs):
    def _deco(cls):
        cls.x = 12
        return cls
    return _deco

@deco(&#39;hello&#39;)
class A(object):
    pass

&amp;gt;&amp;gt;&amp;gt; A.x
12

# 等同于
class A(object):
    pass
A = deco(&#39;hello&#39;)(A)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;装饰器类&#34;&gt;装饰器类&lt;/h2&gt;

&lt;p&gt;类作为装饰器，分为有参数和无参数。同时，需要装饰的是类方法时，需要用到&lt;strong&gt;get&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&#34;无参数&#34;&gt;无参数&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Deco(object):
    def __init__(self, func):
        self.func = func

    def __call__(self, *args, **kwargs):
        print &#39;call Deco&#39;
        self.func(*args, **kwargs)

@Deco
def test():
    print &#39;call test&#39;

# 等同于
test = Deco(test)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;有参数&#34;&gt;有参数&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Deco(object):
    def __init__(self, *args, **kwargs):
        print args, kwargs

    def __call__(self, func):
        def _deco(*args, **kwargs):
            print &#39;call Deco&#39;
            func(*args, **kwargs)
        return _deco

@Deco(&#39;hello&#39;)
def test():
    print &#39;call test&#39;

# 等同于
test = Deco(&#39;hello&#39;)(func)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;装饰类方法&#34;&gt;装饰类方法&lt;/h3&gt;

&lt;h4 id=&#34;无参数-1&#34;&gt;无参数&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Deco(object):
    def __init__(self, func):
        self.func = func

    def __get__(self, instance, owner):
        def _deco(*args, **kwargs):
            print &#39;call Deco&#39;
            self.func(instance, *args, **kwargs)
        return _deco

class A(object):
    @Deco
    def test(self):
        print &#39;call test&#39;

# 等同于
class A(object):

    def test(self):
        print &#39;call test&#39;
    test = Deco(test)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;有参数-1&#34;&gt;有参数&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Deco(object):
    def __init__(self, *args, **kwargs):
        print args, kwargs

    def __get__(self, instance, owner):
        def _deco(*args, **kwargs):
            print &#39;call Deco&#39;
            self.func(instance, *args, **kwargs)
        return _deco

    def __call__(self, func):
        self.func = func
        return self

class A(object):

    @Deco(&#39;hello&#39;)
    def test(self):
        print &#39;call test&#39;

# 等同于
class A(object):

    def test(self):
        print &#39;call test&#39;
    test = Deco(&#39;hello&#39;)(test)
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Python闭包的作用域理解</title>
      <link>/post/python-bibao/</link>
      <pubDate>Wed, 22 Jul 2015 22:23:31 +0800</pubDate>
      
      <guid>/post/python-bibao/</guid>
      <description>&lt;h2 id=&#34;什么是闭包&#34;&gt;什么是闭包&lt;/h2&gt;

&lt;p&gt;在维基中，闭包的解释是这样的：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;在计算机科学中，闭包（Closure）是词法闭包（Lexical Closure）的简称，是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。所以，有另一种说法认为闭包是由函数和与其相关的引用环境组合而成的实体。闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;我们来看一个简单的实例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def outer(arg):
    def inner():
        print arg * arg
    return inner

&amp;gt;&amp;gt;&amp;gt; f = outer(2)
&amp;gt;&amp;gt;&amp;gt; f()
4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;内部函数inner调用外部函数outer的局部变量arg，它保存了outer的arg值。这就是闭包。&lt;/p&gt;

&lt;h2 id=&#34;从作用域的角度理解&#34;&gt;从作用域的角度理解&lt;/h2&gt;

&lt;p&gt;把上面的例子改一下，在函数内部输出局部命名空间:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def outer(arg):
    print locals()
    def inner():
        x = arg * arg
        print locals()
        print x
    return inner

&amp;gt;&amp;gt;&amp;gt; f = outer(2)
{&#39;arg&#39;: 2}
&amp;gt;&amp;gt;&amp;gt; f()
{&#39;x&#39;: 4, &#39;arg&#39;: 2}
4
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在outer中，局部命名空间只有一个键arg，而在inner内部也有arg。上面说的inner保存了outer的arg值，我们就可以理解为inner的局部命名空间保存了arg。&lt;/p&gt;

&lt;p&gt;这么一理解，就会发现闭包其实就这么简单。&lt;/p&gt;

&lt;p&gt;另外再瞎扯一句，python中的装饰器其实就是闭包。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Twisted源码分析系列01-reactor</title>
      <link>/post/python-twisted01/</link>
      <pubDate>Tue, 14 Jul 2015 22:22:03 +0800</pubDate>
      
      <guid>/post/python-twisted01/</guid>
      <description>&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;

&lt;p&gt;Twisted是用Python实现的事件驱动的网络框架。&lt;/p&gt;

&lt;p&gt;如果想看教程的话，我觉得写得最好的就是&lt;a href=&#34;http://krondo.com/?page_id=1327&#34;&gt;Twisted Introduction&lt;/a&gt;了，这是&lt;a href=&#34;https://github.com/syfun/twisted-intro-cn&#34;&gt;翻译&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;下面就直接进入主题了。&lt;/p&gt;

&lt;p&gt;我们通过一个示例开始分析源码，那么先看下面这个示例。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python
# coding=utf8

from twisted.internet.protocol import Protocol, ServerFactory


HOST = &#39;127.0.0.1&#39;
PORT = 8080


class EchoProtocol(Protocol):

    def dataReceived(self, data):
        self.transport.write(data)


if __name__ == &#39;__main__&#39;:
    factory = ServerFactory()
    factory.protocol = EchoProtocol

    from twisted.internet import reactor
    reactor.listenTCP(PORT, factory, interface=HOST)
    reactor.run()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是一个非常简单的Echo server，每当有数据发来，都会将数据往回发。&lt;/p&gt;

&lt;h2 id=&#34;reactor&#34;&gt;reactor&lt;/h2&gt;

&lt;p&gt;reactor是事件管理器，用于注册、注销事件，运行事件循环，当事件发生时调用回调函数处理。关于reactor有下面几个结论:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Twisted的reactor只有通过调用reactor.run()来启动。&lt;/li&gt;
&lt;li&gt;reactor循环是在其开始的进程中运行，也就是运行在主进程中。&lt;/li&gt;
&lt;li&gt;一旦启动，就会一直运行下去。reactor就会在程序的控制下（或者具体在一个启动它的线程的控制下）。&lt;/li&gt;
&lt;li&gt;reactor循环并不会消耗任何CPU的资源。&lt;/li&gt;
&lt;li&gt;并不需要显式的创建reactor，只需要引入就OK了。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最后一条需要解释清楚。在Twisted中，reactor是Singleton（也就是单例模式），即在一个程序中只能有一个reactor，并且只要你引入它就相应地创建一个。上面引入的方式这是twisted默认使用的方法，当然了，twisted还有其它可以引入reactor的方法。例如，可以使用twisted.internet.pollreactor中的系统调用来poll来代替select方法。
若使用其它的reactor，需要在引入twisted.internet.reactor前安装它。下面是安装pollreactor的方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from twisted.internet import pollreactor
pollreactor.install()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你没有安装其它特殊的reactor而引入了twisted.internet.reactor，那么Twisted会根据操作系统安装默认的reactor。正因为如此，习惯性做法不要在最顶层的模块内引入reactor以避免安装默认reactor，而是在你要使用reactor的区域内安装。
下面是使用 pollreactor重写上上面的程序:tho&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from twited.internet import pollreactor
pollreactor.install()
from twisted.internet import reactor
reactor.run()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么reactor是如何实现单例的？来看一下from twisted.internet import reactor做了哪些事情就并明白了。&lt;/p&gt;

&lt;p&gt;下面是twisted/internet/reactor.py的部分代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# twisted/internet/reactor.py
import sys
del sys.modules[&#39;twisted.internet.reactor&#39;]
from twisted.internet import default
default.install()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注：Python中所有加载到内存的模块都放在sys.modules，它是一个全局字典。当import一个模块时首先会在这个列表中查找是否已经加载了此模块，如果加载了则只是将模块的名字加入到正在调用import的模块的命名空间中。如果没有加载则从sys.path目录中按照模块名称查找模块文件，找到后将模块载入内存，并加入到sys.modules中，并将名称导入到当前的命名空间中。&lt;/p&gt;

&lt;p&gt;假如我们是第一次运行from twisted.internet import reactor，因为sys.modules中还没有twisted.internet.reactor，所以会运行reactory.py中的代码，安装默认的reactor。之后，如果导入的话，因为sys.modules中已存在该模块，所以会直接将sys.modules中的twisted.internet.reactor导入到当前命名空间。&lt;/p&gt;

&lt;p&gt;default中的install：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# twisted/internet/default.py
def _getInstallFunction(platform):
    &amp;quot;&amp;quot;&amp;quot;
    Return a function to install the reactor most suited for the given platform.

    @param platform: The platform for which to select a reactor.
    @type platform: L{twisted.python.runtime.Platform}

    @return: A zero-argument callable which will install the selected
        reactor.
    &amp;quot;&amp;quot;&amp;quot;
    try:
        if platform.isLinux():
            try:
                from twisted.internet.epollreactor import install
            except ImportError:
                from twisted.internet.pollreactor import install
        elif platform.getType() == &#39;posix&#39; and not platform.isMacOSX():
            from twisted.internet.pollreactor import install
        else:
            from twisted.internet.selectreactor import install
    except ImportError:
        from twisted.internet.selectreactor import install
    return install


install = _getInstallFunction(platform)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;很明显，default中会根据平台获取相应的install。Linux下会首先使用epollreactor，如果内核还不支持，就只能使用pollreactor。Mac平台使用pollreactor，windows使用selectreactor。每种install的实现差不多，这里我们抽取selectreactor中的install来看看。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# twisted/internet/selectreactor.py：
def install():
    &amp;quot;&amp;quot;&amp;quot;Configure the twisted mainloop to be run using the select() reactor.
    &amp;quot;&amp;quot;&amp;quot;
    # 单例
    reactor = SelectReactor()
    from twisted.internet.main import installReactor
    installReactor(reactor)

# twisted/internet/main.py：
def installReactor(reactor):
    &amp;quot;&amp;quot;&amp;quot;
    Install reactor C{reactor}.

    @param reactor: An object that provides one or more IReactor* interfaces.
    &amp;quot;&amp;quot;&amp;quot;
    # this stuff should be common to all reactors.
    import twisted.internet
    import sys
    if &#39;twisted.internet.reactor&#39; in sys.modules:
        raise error.ReactorAlreadyInstalledError(&amp;quot;reactor already installed&amp;quot;)
    twisted.internet.reactor = reactor
    sys.modules[&#39;twisted.internet.reactor&#39;] = reactor
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在installReactor中，向sys.modules添加twisted.internet.reactor键，值就是再install中创建的单例reactor。以后要使用reactor，就会导入这个单例了。&lt;/p&gt;

&lt;h2 id=&#34;selectreactor&#34;&gt;SelectReactor&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# twisted/internet/selectreactor.py
@implementer(IReactorFDSet)
class SelectReactor(posixbase.PosixReactorBase, _extraBase)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;implementer表示SelectReactor实现了IReactorFDSet接口的方法，这里用到了&lt;a href=&#34;http://docs.zope.org/zope.interface/&#34;&gt;zope.interface&lt;/a&gt;，它是python中的接口实现，有兴趣的同学可以去看下。&lt;/p&gt;

&lt;p&gt;IReactorFDSet接口主要对描述符的获取、添加、删除等操作的方法。这些方法看名字就能知道意思，所以我就没有加注释。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# twisted/internet/interfaces.py
class IReactorFDSet(Interface):

    def addReader(reader):

    def addWriter(writer):

    def removeReader(reader):

    def removeWriter(writer):

    def removeAll():

    def getReaders():

    def getWriters():

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;reactor-listentcp&#34;&gt;reactor.listenTCP()&lt;/h3&gt;

&lt;p&gt;示例中的reactor.listenTCP()注册了一个监听事件，它是父类PosixReactorBase中方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# twisted/internet/posixbase.py
@implementer(IReactorTCP, IReactorUDP, IReactorMulticast)
class PosixReactorBase(_SignalReactorMixin, _DisconnectSelectableMixin,
                       ReactorBase):

    def listenTCP(self, port, factory, backlog=50, interface=&#39;&#39;):
        p = tcp.Port(port, factory, backlog, interface, self)
        p.startListening()
        return p

# twisted/internet/tcp.py
@implementer(interfaces.IListeningPort)
class Port(base.BasePort, _SocketCloser):
    def __init__(self, port, factory, backlog=50, interface=&#39;&#39;, reactor=None):
       &amp;quot;&amp;quot;&amp;quot;Initialize with a numeric port to listen on.
       &amp;quot;&amp;quot;&amp;quot;
       base.BasePort.__init__(self, reactor=reactor)
       self.port = port
       self.factory = factory
       self.backlog = backlog
       if abstract.isIPv6Address(interface):
           self.addressFamily = socket.AF_INET6
           self._addressType = address.IPv6Address
       self.interface = interface
    ...

    def startListening(self):
       &amp;quot;&amp;quot;&amp;quot;Create and bind my socket, and begin listening on it.
          创建并绑定套接字，开始监听。

       This is called on unserialization, and must be called after creating a
       server to begin listening on the specified port.
       &amp;quot;&amp;quot;&amp;quot;
       if self._preexistingSocket is None:
           # Create a new socket and make it listen
           try:
               # 创建套接字
               skt = self.createInternetSocket()
               if self.addressFamily == socket.AF_INET6:
                   addr = _resolveIPv6(self.interface, self.port)
               else:
                   addr = (self.interface, self.port)
               # 绑定
               skt.bind(addr)
           except socket.error as le:
               raise CannotListenError(self.interface, self.port, le)
           # 监听
           skt.listen(self.backlog)
       else:
           # Re-use the externally specified socket
           skt = self._preexistingSocket
           self._preexistingSocket = None
           # Avoid shutting it down at the end.
           self._shouldShutdown = False

       # Make sure that if we listened on port 0, we update that to
       # reflect what the OS actually assigned us.
       self._realPortNumber = skt.getsockname()[1]

       log.msg(&amp;quot;%s starting on %s&amp;quot; % (
               self._getLogPrefix(self.factory), self._realPortNumber))

       # The order of the next 5 lines is kind of bizarre.  If no one
       # can explain it, perhaps we should re-arrange them.
       self.factory.doStart()
       self.connected = True
       self.socket = skt
       self.fileno = self.socket.fileno
       self.numberAccepts = 100

       # startReading调用reactor的addReader方法将Port加入读集合
       self.startReading()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;整个逻辑很简单，和正常的server端一样，创建套接字、绑定、监听。不同的是将套接字的描述符添加到了reactor的读集合。那么假如有了client连接过来的话，reactor会监控到，然后触发事件处理程序。&lt;/p&gt;

&lt;h2 id=&#34;reacotr-run-事件主循环&#34;&gt;reacotr.run()事件主循环&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# twisted/internet/posixbase.py
@implementer(IReactorTCP, IReactorUDP, IReactorMulticast)
class PosixReactorBase(_SignalReactorMixin, _DisconnectSelectableMixin,
                       ReactorBase)

# twisted/internet/base.py
class _SignalReactorMixin(object):

    def startRunning(self, installSignalHandlers=True):
        &amp;quot;&amp;quot;&amp;quot;
        PosixReactorBase的父类_SignalReactorMixin和ReactorBase都有该函数，但是
        _SignalReactorMixin在前，安装mro顺序的话，会先调用_SignalReactorMixin中的。
        &amp;quot;&amp;quot;&amp;quot;
        self._installSignalHandlers = installSignalHandlers
        ReactorBase.startRunning(self)

    def run(self, installSignalHandlers=True):
        self.startRunning(installSignalHandlers=installSignalHandlers)
        self.mainLoop()

    def mainLoop(self):
        while self._started:
            try:
                while self._started:
                    # Advance simulation time in delayed event
                    # processors.
                    self.runUntilCurrent()
                    t2 = self.timeout()
                    t = self.running and t2
                    # doIteration是关键，select,poll,epool实现各有不同
                    self.doIteration(t)
            except:
                log.msg(&amp;quot;Unexpected error in main loop.&amp;quot;)
                log.err()
            else:
                log.msg(&#39;Main loop terminated.&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mianLoop就是最终的主循环了，在循环中，调用doIteration方法监控读写描述符的集合，一旦发现有描述符准备好读写，就会调用相应的事件处理程序。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# twisted/internet/selectreactor.py
@implementer(IReactorFDSet)
class SelectReactor(posixbase.PosixReactorBase, _extraBase):

    def __init__(self):
        &amp;quot;&amp;quot;&amp;quot;
        Initialize file descriptor tracking dictionaries and the base class.
        &amp;quot;&amp;quot;&amp;quot;
        self._reads = set()
        self._writes = set()
        posixbase.PosixReactorBase.__init__(self)

    def doSelect(self, timeout):
        &amp;quot;&amp;quot;&amp;quot;
        Run one iteration of the I/O monitor loop.

        This will run all selectables who had input or output readiness
        waiting for them.
        &amp;quot;&amp;quot;&amp;quot;
        try:
            # 调用select方法监控读写集合，返回准备好读写的描述符
            r, w, ignored = _select(self._reads,
                                    self._writes,
                                    [], timeout)
        except ValueError:
            # Possibly a file descriptor has gone negative?
            self._preenDescriptors()
            return
        except TypeError:
            # Something *totally* invalid (object w/o fileno, non-integral
            # result) was passed
            log.err()
            self._preenDescriptors()
            return
        except (select.error, socket.error, IOError) as se:
            # select(2) encountered an error, perhaps while calling the fileno()
            # method of a socket.  (Python 2.6 socket.error is an IOError
            # subclass, but on Python 2.5 and earlier it is not.)
            if se.args[0] in (0, 2):
                # windows does this if it got an empty list
                if (not self._reads) and (not self._writes):
                    return
                else:
                    raise
            elif se.args[0] == EINTR:
                return
            elif se.args[0] == EBADF:
                self._preenDescriptors()
                return
            else:
                # OK, I really don&#39;t know what&#39;s going on.  Blow up.
                raise

        _drdw = self._doReadOrWrite
        _logrun = log.callWithLogger
        for selectables, method, fdset in ((r, &amp;quot;doRead&amp;quot;, self._reads),
                                           (w,&amp;quot;doWrite&amp;quot;, self._writes)):
            for selectable in selectables:
                # if this was disconnected in another thread, kill it.
                # ^^^^ --- what the !@#*?  serious!  -exarkun
                if selectable not in fdset:
                    continue
                # This for pausing input when we&#39;re not ready for more.

                # 调用_doReadOrWrite方法
                _logrun(selectable, _drdw, selectable, method)

    doIteration = doSelect

    def _doReadOrWrite(self, selectable, method):
        try:
            # 调用method，doRead或者是doWrite，
            # 这里的selectable可能是我们监听的tcp.Port
            why = getattr(selectable, method)()
        except:
            why = sys.exc_info()[1]
            log.err()
        if why:
            self._disconnectSelectable(selectable, why, method==&amp;quot;doRead&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么假如客户端有连接请求了，就会调用读集合中tcp.Port的doRead方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# twisted/internet/tcp.py

@implementer(interfaces.IListeningPort)
class Port(base.BasePort, _SocketCloser):

    def doRead(self):
        &amp;quot;&amp;quot;&amp;quot;Called when my socket is ready for reading.
        当套接字准备好读的时候调用

        This accepts a connection and calls self.protocol() to handle the
        wire-level protocol.
        &amp;quot;&amp;quot;&amp;quot;
        try:
            if platformType == &amp;quot;posix&amp;quot;:
                numAccepts = self.numberAccepts
            else:
                numAccepts = 1
            for i in range(numAccepts):
                if self.disconnecting:
                    return
                try:
                    # 调用accept
                    skt, addr = self.socket.accept()
                except socket.error as e:
                    if e.args[0] in (EWOULDBLOCK, EAGAIN):
                        self.numberAccepts = i
                        break
                    elif e.args[0] == EPERM:
                        continue
                    elif e.args[0] in (EMFILE, ENOBUFS, ENFILE, ENOMEM, ECONNABORTED):
                        log.msg(&amp;quot;Could not accept new connection (%s)&amp;quot; % (
                            errorcode[e.args[0]],))
                        break
                    raise

                fdesc._setCloseOnExec(skt.fileno())
                protocol = self.factory.buildProtocol(self._buildAddr(addr))
                if protocol is None:
                    skt.close()
                    continue
                s = self.sessionno
                self.sessionno = s+1
                # transport初始化的过程中，会将自身假如到reactor的读集合中，那么当它准备
                # 好读的时候，就可以调用它的doRead方法读取客户端发过来的数据了
                transport = self.transport(skt, protocol, addr, self, s, self.reactor)
                protocol.makeConnection(transport)
            else:
                self.numberAccepts = self.numberAccepts+20
        except:
            log.deferr()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;doRead方法中，调用accept产生了用于接收客户端数据的套接字，将套接字与transport绑定，然后把transport加入到reactor的读集合。当客户端有数据到来时，就会调用transport的doRead方法进行数据读取了。&lt;/p&gt;

&lt;p&gt;Connection是Server（transport实例的类）的父类，它实现了doRead方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# twisted/internet/tcp.py
@implementer(interfaces.ITCPTransport, interfaces.ISystemHandle)
class Connection(_TLSConnectionMixin, abstract.FileDescriptor, _SocketCloser,
                 _AbortingMixin):

    def doRead(self):
        try:
            # 接收数据
            data = self.socket.recv(self.bufferSize)
        except socket.error as se:
            if se.args[0] == EWOULDBLOCK:
                return
            else:
                return main.CONNECTION_LOST

        return self._dataReceived(data)

    def _dataReceived(self, data):
        if not data:
            return main.CONNECTION_DONE
        # 调用我们自定义protocol的dataReceived方法处理数据
        rval = self.protocol.dataReceived(data)
        if rval is not None:
            offender = self.protocol.dataReceived
            warningFormat = (
                &#39;Returning a value other than None from %(fqpn)s is &#39;
                &#39;deprecated since %(version)s.&#39;)
            warningString = deprecate.getDeprecationWarningString(
                offender, versions.Version(&#39;Twisted&#39;, 11, 0, 0),
                format=warningFormat)
            deprecate.warnAboutFunction(offender, warningString)
        return rval
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;_dataReceived中调用了示例中我们自定义的EchoProtocol的dataReceived方法处理数据。&lt;/p&gt;

&lt;p&gt;至此，一个简单的流程，从创建监听事件，到接收客户端数据就此结束了。&lt;/p&gt;

&lt;p&gt;一些细节的地方我并未说明，这里只是说明一个大概的流程，想看的细一点的，可以直接跟着这个流程去看源码。&lt;/p&gt;

&lt;p&gt;这个系列应该会不定时更新，如果有人感兴趣的，也可以和我直接交流。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>浅谈Python的with语句(转载)</title>
      <link>/post/python-with/</link>
      <pubDate>Tue, 07 Jul 2015 22:20:10 +0800</pubDate>
      
      <guid>/post/python-with/</guid>
      <description>&lt;p&gt;本文转自&lt;a href=&#34;http://www.ibm.com/developerworks/cn/opensource/os-cn-pythonwith/&#34;&gt;浅谈Python的with语句&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;引言&#34;&gt;引言&lt;/h2&gt;

&lt;p&gt;with 语句是从 Python 2.5 开始引入的一种与异常处理相关的功能（2.5 版本中要通过 from __future__ import with_statement 导入后才可以使用），从 2.6 版本开始缺省可用（参考 &lt;a href=&#34;https://docs.python.org/release/2.6/whatsnew/2.6.html#pep-343-the-with-statement&#34;&gt;What&amp;rsquo;s new in Python 2.6?&lt;/a&gt; 中 with 语句相关部分介绍）。with 语句适用于对资源进行访问的场合，确保不管使用过程中是否发生异常都会执行必要的“清理”操作，释放资源，比如文件使用后自动关闭、线程中锁的自动获取和释放等。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;术语&#34;&gt;术语&lt;/h2&gt;

&lt;p&gt;要使用 with 语句，首先要明白上下文管理器这一概念。有了上下文管理器，with 语句才能工作。
下面是一组与上下文管理器和with 语句有关的概念。&lt;/p&gt;

&lt;p&gt;上下文管理协议（Context Management Protocol）：包含方法 __enter__() 和 __exit__()，支持
该协议的对象要实现这两个方法。&lt;/p&gt;

&lt;p&gt;上下文管理器（Context Manager）：支持上下文管理协议的对象，这种对象实现了
__enter__() 和 __exit__() 方法。上下文管理器定义执行 with 语句时要建立的运行时上下文，
负责执行 with 语句块上下文中的进入与退出操作。通常使用 with 语句调用上下文管理器，
也可以通过直接调用其方法来使用。&lt;/p&gt;

&lt;p&gt;运行时上下文（runtime context）：由上下文管理器创建，通过上下文管理器的 __enter__() 和
__exit__() 方法实现，__enter__() 方法在语句体执行之前进入运行时上下文，__exit__() 在
语句体执行完后从运行时上下文退出。with 语句支持运行时上下文这一概念。&lt;/p&gt;

&lt;p&gt;上下文表达式（Context Expression）：with 语句中跟在关键字 with 之后的表达式，该表达式
要返回一个上下文管理器对象。&lt;/p&gt;

&lt;p&gt;语句体（with-body）：with 语句包裹起来的代码块，在执行语句体之前会调用上下文管
理器的 __enter__() 方法，执行完语句体之后会执行 __exit__() 方法。&lt;/p&gt;

&lt;h2 id=&#34;基本语法和工作原理&#34;&gt;基本语法和工作原理&lt;/h2&gt;

&lt;p&gt;with 语句的语法格式如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 清单 1. with 语句的语法格式
with context_expression [as target(s)]:
    with-body
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里 context_expression 要返回一个上下文管理器对象，该对象并不赋值给 as 子句中的 target(s) ，如果指定了 as 子句的话，会将上下文管理器的__enter__() 方法的返回值赋值给 target(s)。target(s) 可以是单个变量，或者由“()”括起来的元组（不能是仅仅由“,”分隔的变量列表，必须加“()”）。&lt;/p&gt;

&lt;p&gt;Python 对一些内建对象进行改进，加入了对上下文管理器的支持，可以用于 with 语句中，比如可以自动关闭文件、线程锁的自动获取和释放等。假设要对一个文件进行操作，使用 with 语句可以有如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 清单 2. 使用 with 语句操作文件对象
with open(r&#39;somefileName&#39;) as somefile:
    for line in somefile:
        print line
        # ...more code
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里使用了 with 语句，不管在处理文件过程中是否发生异常，都能保证 with 语句执行完毕后已经关闭了打开的文件句柄。如果使用传统的 try/finally 范式，则要使用类似如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 清单 3. try/finally 方式操作文件对象
somefile = open(r&#39;somefileName&#39;)
try:
    for line in somefile:
        print line
        # ...more code
finally:
    somefile.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;比较起来，使用 with 语句可以减少编码量。已经加入对上下文管理协议支持的还有模块 threading、decimal 等。&lt;/p&gt;

&lt;p&gt;PEP 0343 对 with 语句的实现进行了描述。with 语句的执行过程类似如下代码块：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 清单 4. with 语句执行过程
context_manager = context_expression
exit = type(context_manager).__exit__
value = type(context_manager).__enter__(context_manager)
exc = True   # True 表示正常执行，即便有异常也忽略；False 表示重新抛出异常，需要对异常进行处理
try:
    try:
        target = value  # 如果使用了 as 子句
        with-body     # 执行 with-body
    except:
        # 执行过程中有异常发生
        exc = False
        # 如果 __exit__ 返回 True，则异常被忽略；如果返回 False，则重新抛出异常
        # 由外层代码对异常进行处理
        if not exit(context_manager, *sys.exc_info()):
            raise
finally:
    # 正常退出，或者通过 statement-body 中的 break/continue/return 语句退出
    # 或者忽略异常退出
    if exc:
        exit(context_manager, None, None, None)
    # 缺省返回 None，None 在布尔上下文中看做是 False
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;执行 context_expression，生成上下文管理器 context_manager&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;调用上下文管理器的 __enter__() 方法；如果使用了 as 子句，则将 __enter__() 方法的返回值赋值给 as 子句中的 target(s)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;执行语句体 with-body&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;不管是否执行过程中是否发生了异常，执行上下文管理器的 __exit__() 方法，__exit__() 方法负责执行“清理”工作，如释放资源等。如果执行过程中没有出现异常，或者语句体中执行了语句 break/continue/return，则以 None 作为参数调用 __exit__(None, None, None) ；如果执行过程中出现异常，则使用 sys.exc_info 得到的异常信息为参数调用__exit__(exc_type, exc_value, exc_traceback)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;出现异常时，如果 __exit__(type, value, traceback) 返回 False，则会重新抛出异常，让with 之外的语句逻辑来处理异常，这也是通用做法；如果返回 True，则忽略异常，不再对异常进行处理&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;自定义上下文管理器&#34;&gt;自定义上下文管理器&lt;/h2&gt;

&lt;p&gt;开发人员可以自定义支持上下文管理协议的类。自定义的上下文管理器要实现上下文管理协议所需要的 __enter__() 和 __exit__() 两个方法：&lt;/p&gt;

&lt;p&gt;context_manager.__enter__()：进入上下文管理器的运行时上下文，在语句体执行前调用。with 语句将该方法的返回值赋值给 as 子句中的 target，如果指定了 as 子句的话&lt;/p&gt;

&lt;p&gt;context_manager.__exit__(exc_type, exc_value, exc_traceback)： 退出与上下文管理器相关的运行时上下文，返回一个布尔值表示是否对发生的异常进行处理。参数表示引起退出操作的异常，如果退出时没有发生异常，则3个参数都为None。如果发生异常，返回True 表示不处理异常，否则会在退出该方法后重新抛出异常以由 with 语句之外的代码逻辑进行处理。如果该方法内部产生异常，则会取代由 statement-body 中语句产生的异常。要处理异常时，不要显示重新抛出异常，即不能重新抛出通过参数传递进来的异常，只需要将返回值设置为 False 就可以了。之后，上下文管理代码会检测是否__exit__() 失败来处理异常&lt;/p&gt;

&lt;p&gt;下面通过一个简单的示例来演示如何构建自定义的上下文管理器。注意，上下文管理器必须同时提供 __enter__() 和 __exit__() 方法的定义，缺少任何一个都会导致 AttributeError；with 语句会先检查是否提供了 __exit__() 方法，然后检查是否定义了 __enter__() 方法。&lt;/p&gt;

&lt;p&gt;假设有一个资源 DummyResource，这种资源需要在访问前先分配，使用完后再释放掉；分配操作可以放到 __enter__() 方法中，释放操作可以放到 __exit__() 方法中。简单起见，这里只通过打印语句来表明当前的操作，并没有实际的资源分配与释放。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 清单 5. 自定义支持 with 语句的对象
class DummyResource:
    def __init__(self, tag):
            self.tag = tag
            print &#39;Resource [%s]&#39; % tag
        def __enter__(self):
            print &#39;[Enter %s]: Allocate resource.&#39; % self.tag
            return self	  # 可以返回不同的对象
        def __exit__(self, exc_type, exc_value, exc_tb):
            print &#39;[Exit %s]: Free resource.&#39; % self.tag
            if exc_tb is None:
                print &#39;[Exit %s]: Exited without exception.&#39; % self.tag
            else:
                print &#39;[Exit %s]: Exited with exception raised.&#39; % self.tag
                return False   # 可以省略，缺省的None也是被看做是False
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;DummyResource 中的 __enter__() 返回的是自身的引用，这个引用可以赋值给 as 子句中的 target 变量；返回值的类型可以根据实际需要设置为不同的类型，不必是上下文管理器对象本身。&lt;/p&gt;

&lt;p&gt;__exit__() 方法中对变量 exc_tb 进行检测，如果不为 None，表示发生了异常，返回 False 表示需要由外部代码逻辑对异常进行处理；注意到如果没有发生异常，缺省的返回值为 None，在布尔环境中也是被看做 False，但是由于没有异常发生，__exit__() 的三个参数都为 None，上下文管理代码可以检测这种情况，做正常处理。&lt;/p&gt;

&lt;p&gt;下面在 with 语句中访问 DummyResource ：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 清单 6. 使用自定义的支持 with 语句的对象
with DummyResource(&#39;Normal&#39;):
    print &#39;[with-body] Run without exceptions.&#39;

with DummyResource(&#39;With-Exception&#39;):
    print &#39;[with-body] Run with exception.&#39;
    raise Exception
    print &#39;[with-body] Run with exception. Failed to finish statement-body!&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第1个 with 语句的执行结果如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 清单 7. with 语句1执行结果
Resource [Normal]
[Enter Normal]: Allocate resource.
[with-body] Run without exceptions.
[Exit Normal]: Free resource.
[Exit Normal]: Exited without exception.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，正常执行时会先执行完语句体 with-body，然后执行 __exit__() 方法释放资源。&lt;/p&gt;

&lt;p&gt;第2个 with 语句的执行结果如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 清单 8. with 语句2执行结果
Resource [With-Exception]
[Enter With-Exception]: Allocate resource.
[with-body] Run with exception.
[Exit With-Exception]: Free resource.
[Exit With-Exception]: Exited with exception raised.

Traceback (most recent call last):
  File &amp;quot;G:/demo&amp;quot;, line 20, in &amp;lt;module&amp;gt;
    raise Exception
Exception
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，with-body 中发生异常时with-body 并没有执行完，但资源会保证被释放掉，同时产生的异常由 with 语句之外的代码逻辑来捕获处理。&lt;/p&gt;

&lt;p&gt;可以自定义上下文管理器来对软件系统中的资源进行管理，比如数据库连接、共享资源的访问控制等。Python 在线文档 Writing Context Managers 提供了一个针对数据库连接进行管理的上下文管理器的简单范例。&lt;/p&gt;

&lt;h2 id=&#34;contextlib-模块&#34;&gt;contextlib 模块&lt;/h2&gt;

&lt;p&gt;contextlib 模块提供了3个对象：装饰器 contextmanager、函数 nested 和上下文管理器 closing。使用这些对象，可以对已有的生成器函数或者对象进行包装，加入对上下文管理协议的支持，避免了专门编写上下文管理器来支持 with 语句。&lt;/p&gt;

&lt;h3 id=&#34;装饰器-contextmanager&#34;&gt;装饰器 contextmanager&lt;/h3&gt;

&lt;p&gt;contextmanager 用于对生成器函数进行装饰，生成器函数被装饰以后，返回的是一个上下文管理器，其 __enter__() 和 __exit__() 方法由 contextmanager 负责提供，而不再是之前的迭代子。被装饰的生成器函数只能产生一个值，否则会导致异常 RuntimeError；产生的值会赋值给 as 子句中的 target，如果使用了 as 子句的话。下面看一个简单的例子。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 清单 9. 装饰器 contextmanager 使用示例
from contextlib import contextmanager

@contextmanager
def demo():
    print &#39;[Allocate resources]&#39;
    print &#39;Code before yield-statement executes in \_\_enter\_\_&#39;
    yield &#39;*** contextmanager demo ***&#39;
    print &#39;Code after yield-statement executes in \_\_exit\_\_&#39;
    print &#39;[Free resources]&#39;

with demo() as value:
    print &#39;Assigned Value: %s&#39; % value

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果输出如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 清单 10. contextmanager 使用示例执行结果
[Allocate resources]
Code before yield-statement executes in __enter__
Assigned Value: *** contextmanager demo ***
Code after yield-statement executes in __exit__
[Free resources]
``
可以看到，生成器函数中 yield 之前的语句在 \_\_enter\_\_() 方法中执行，yield 之后的语句在 \_\_exit\_\_() 中执行，而 yield 产生的值赋给了 as 子句中的 value 变量。

需要注意的是，contextmanager 只是省略了 \_\_enter\_\_() / \_\_exit\_\_() 的编写，但并不负责实现资源的“获取”和“清理”工作；“获取”操作需要定义在 yield 语句之前，“清理”操作需要定义 yield 语句之后，这样 with 语句在执行 \_\_enter\_\_() / \_\_exit\_\_() 方法时会执行这些语句以获取/释放资源，即生成器函数中需要实现必要的逻辑控制，包括资源访问出现错误时抛出适当的异常。

### 函数 nested

nested 可以将多个上下文管理器组织在一起，避免使用嵌套 with 语句。

```python
# 清单 11. nested 语法
with nested(A(), B(), C()) as (X, Y, Z):
      # with-body code here
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;类似于：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 清单 12. nested 执行过程
with A() as X:
    with B() as Y:
        with C() as Z:
              # with-body code here
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要注意的是，发生异常后，如果某个上下文管理器的 __exit__() 方法对异常处理返回 False，则更外层的上下文管理器不会监测到异常。&lt;/p&gt;

&lt;h3 id=&#34;上下文管理器-closing&#34;&gt;上下文管理器 closing&lt;/h3&gt;

&lt;p&gt;closing 的实现如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 清单 13. 上下文管理 closing 实现
class closing(object):
    # help doc here
    def __init__(self, thing):
        self.thing = thing
    def __enter__(self):
        return self.thing
    def __exit__(self, *exc_info):
        self.thing.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上下文管理器会将包装的对象赋值给 as 子句的 target 变量，同时保证打开的对象在 with-body 执行完后会关闭掉。closing 上下文管理器包装起来的对象必须提供 close() 方法的定义，否则执行时会报 AttributeError 错误。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 清单 14. 自定义支持 closing 的对象
class ClosingDemo(object):
    def __init__(self):
        self.acquire()
    def acquire(self):
        print &#39;Acquire resources.&#39;
    def free(self):
        print &#39;Clean up any resources acquired.&#39;
    def close(self):
        self.free()

with closing(ClosingDemo()):
    print &#39;Using resources&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果输出如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 清单 15. 自定义 closing 对象的输出结果
Acquire resources.
Using resources
Clean up any resources acquired.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;closing 适用于提供了 close() 实现的对象，比如网络连接、数据库连接等，也可以在自定义类时通过接口 close() 来执行所需要的资源“清理”工作。&lt;/p&gt;

&lt;h2 id=&#34;小结&#34;&gt;小结&lt;/h2&gt;

&lt;p&gt;本文对 with 语句的语法和工作机理进行了介绍，并通过示例介绍了如何实现自定义的上下文管理器，最后介绍了如何使用 contextlib 模块来简化上下文管理器的编写。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Python __future__ 模块</title>
      <link>/post/python-future/</link>
      <pubDate>Fri, 03 Jul 2015 22:18:29 +0800</pubDate>
      
      <guid>/post/python-future/</guid>
      <description>&lt;p&gt;在Python2.7代码中经常能看到使用__future__模块。那么__future__到底是做什么的呢？&lt;/p&gt;

&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;

&lt;p&gt;从单词含义上猜应该是“未来”的模块。它有下面几个&lt;a href=&#34;https://docs.python.org/2.7/library/__future__.html&#34;&gt;目的&lt;/a&gt;：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;避免和现有分析import工具混淆，并得到你期望的模块&lt;/li&gt;
&lt;li&gt;确保2.1之前的版本导入__future__产生运行时异常，因为2.1之前没有这个模块&lt;/li&gt;
&lt;li&gt;文档化不兼容的改变，通常这些改变会在新版中强制执行。这类文档以可执行的形式组织，通过导入__future__进行可编程式的检查。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;以上是对官方解释的粗略翻译，翻译起来感觉有些拗口。我是这么理解的，某个版本中出现了某个新的功能特性，而且这个特性和当前版本中使用的不兼容，也就是它在该版本中不是语言标准，那么我如果想要使用的话就需要从__future__模块导入。在2.1版本之前并没有__future__，所以使用它会引发异常。当然，在以后的某个版本中，比如说3中，某个特性已经成为标准的一部分，那么使用该特性就不用从__future__导入了。&lt;/p&gt;

&lt;p&gt;下面说一下__future__是如何实现新特性的。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;feature类&#34;&gt;_Feature类&lt;/h2&gt;

&lt;p&gt;__future__.py中有形如下面的语句：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;FeatureName = _Feature(OptionalRelease, MandatoryRelease, CompilerFlag)

class _Feature:
    def __init__(self, optionalRelease, mandatoryRelease, compiler_flag):
        self.optional = optionalRelease    # 某个特性被认可的初始版本
        self.mandatory = mandatoryRelease  # 某个特性成为标准的版本
        self.compiler_flag = compiler_flag

    def getOptionalRelease(self):
        &amp;quot;&amp;quot;&amp;quot;Return first release in which this feature was recognized.

        This is a 5-tuple, of the same form as sys.version_info.
        &amp;quot;&amp;quot;&amp;quot;

        return self.optional

    def getMandatoryRelease(self):
        &amp;quot;&amp;quot;&amp;quot;Return release in which this feature will become mandatory.

        This is a 5-tuple, of the same form as sys.version_info, or, if
        the feature was dropped, is None.
        &amp;quot;&amp;quot;&amp;quot;

        return self.mandatory

    def __repr__(self):
        return &amp;quot;_Feature&amp;quot; + repr((self.optional,
                                  self.mandatory,
                                  self.compiler_flag))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;optionalrelease参数&#34;&gt;OptionalRelease参数&lt;/h2&gt;

&lt;p&gt;通常OptionalRelease版本小于MandatoryRelease，每个都是5个元素的元组，类似sys.version_info。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;(PY_MAJOR_VERSION, # the 2 in 2.1.0a3; an int
PY_MINOR_VERSION, # the 1; an int
PY_MICRO_VERSION, # the 0; an int
PY_RELEASE_LEVEL, # &amp;quot;alpha&amp;quot;, &amp;quot;beta&amp;quot;, &amp;quot;candidate&amp;quot; or &amp;quot;final&amp;quot;; string
PY_RELEASE_SERIAL # the 3; an int
)

# 例如: (2, 1, 0, &amp;quot;alpha&amp;quot;, 3)表示2.1.0a3版
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OptionalRelease版本中开始通过下列方式使用某个特性：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from __future__ import FeatureName
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;mandatoryrelease参数&#34;&gt;MandatoryRelease参数&lt;/h2&gt;

&lt;p&gt;在MandatoryRelease版本中该特性变成Python标准的一部分。此外MandatoryRelease版本后不需要上面的导入语句就能使用该特性。MandatoryRelease可能是None，表示一个计划中的特性被放弃了。&lt;/p&gt;

&lt;h2 id=&#34;compilerflag参数&#34;&gt;CompilerFlag参数&lt;/h2&gt;

&lt;p&gt;CompilerFlag编译器标志，它是一个位域标志，传给内建函数compile()做第四个参数，用来在动态编译代码的时候允许新的特性。&lt;/p&gt;

&lt;p&gt;CompilerFlag值等价于Include/compile.h的预定义的CO_xxx标志。&lt;/p&gt;

&lt;h2 id=&#34;python2-future-模块的features&#34;&gt;Python2 __future__模块的features&lt;/h2&gt;

&lt;p&gt;一共是以下7种，其对应的CompilerFlag:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;all_feature_names = [
    &amp;quot;nested_scopes&amp;quot;,
    &amp;quot;generators&amp;quot;,
    &amp;quot;division&amp;quot;,
    &amp;quot;absolute_import&amp;quot;,
    &amp;quot;with_statement&amp;quot;,
    &amp;quot;print_function&amp;quot;,
    &amp;quot;unicode_literals&amp;quot;,
]

CO_NESTED            = 0x0010   # nested_scopes
CO_GENERATOR_ALLOWED = 0        # generators (obsolete, was 0x1000)
CO_FUTURE_DIVISION   = 0x2000   # division
CO_FUTURE_ABSOLUTE_IMPORT = 0x4000 # perform absolute imports by default
CO_FUTURE_WITH_STATEMENT  = 0x8000   # with statement
CO_FUTURE_PRINT_FUNCTION  = 0x10000   # print function
CO_FUTURE_UNICODE_LITERALS = 0x20000 # unicode string literals
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;nested-scopes&#34;&gt;nested_scopes&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;nested_scopes = _Feature((2, 1, 0, &amp;quot;beta&amp;quot;,  1),
                         (2, 2, 0, &amp;quot;alpha&amp;quot;, 0),
                         CO_NESTED)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;nested_scopes指的是嵌套作用域，2.1.0b1中出现，2.2.0a0中成为标准。&lt;/p&gt;

&lt;p&gt;提到作用域，那么就不得不说命名空间。&lt;/p&gt;

&lt;h4 id=&#34;命名空间的定义&#34;&gt;命名空间的定义&lt;/h4&gt;

&lt;p&gt;Python命名空间是名称到对象的映射，目前是用字典实现，键名是变量名，值是变量的值。比如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; x = 3
&amp;gt;&amp;gt;&amp;gt; globals()
{&#39;__builtins__&#39;: &amp;lt;module &#39;__builtin__&#39; (built-in)&amp;gt;, &#39;__name__&#39;: &#39;__main__&#39;, &#39;__doc__&#39;: None, &#39;x&#39;: 3, &#39;__package__&#39;: None}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到变量x，3以字典的形式存放在globals空间内。以之对应的名称空间还有：locals()。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; locals()
{&#39;__builtins__&#39;: &amp;lt;module &#39;__builtin__&#39; (built-in)&amp;gt;, &#39;__name__&#39;: &#39;__main__&#39;, &#39;__doc__&#39;: None, &#39;x&#39;: 3, &#39;__package__&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实际上，你可以通过向名字添加键名和值，然后就可以直接使用名称了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; globals()[&#39;y&#39;] = 5
&amp;gt;&amp;gt;&amp;gt; y
5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通常，我们用属性来称呼&amp;rsquo;.&amp;lsquo;点号之后的名称为属性。比如，在z.real中，real是z的一个属性。严格来说，模块中的名称引用就是属性引用。modname.funcname中，modname是一个模块对象，而funcname是它的一个属性。模块属性和全局名称有映射关系，它们共享全局命名空间。上面代码中的x和y都是模块&lt;strong&gt;main&lt;/strong&gt;的属性。&lt;/p&gt;

&lt;p&gt;属性可能是只读的，也可能是可写的。模块属性是可写的，你可以这么做，modname.the_answer = 42。可写的属性能够用del语句来删除。比如，del modname.the_answer将会从模块modname中删除the_answer属性。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; x = 3
&amp;gt;&amp;gt;&amp;gt; globals()
{&#39;__builtins__&#39;: &amp;lt;module &#39;__builtin__&#39; (built-in)&amp;gt;, &#39;__package__&#39;: None, &#39;func&#39;: &amp;lt;function func at 0x029FA270&amp;gt;, &#39;x&#39;: 3, &#39;__name__&#39;: &#39;__main__&#39;, &#39;__doc__&#39;: None}
&amp;gt;&amp;gt;&amp;gt; del x
&amp;gt;&amp;gt;&amp;gt; globals()
{&#39;__builtins__&#39;: &amp;lt;module &#39;__builtin__&#39; (built-in)&amp;gt;, &#39;__package__&#39;: None, &#39;func&#39;: &amp;lt;function func at 0x029FA270&amp;gt;, &#39;__name__&#39;: &#39;__main__&#39;, &#39;__doc__&#39;: None}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;del做的事实际上是删除了全局名称字典中的x键值。&lt;/p&gt;

&lt;h4 id=&#34;命名空间的种类&#34;&gt;命名空间的种类&lt;/h4&gt;

&lt;p&gt;Python中有三种命名空间：&lt;/p&gt;

&lt;p&gt;a) 局部，函数内的命名空间就是局部的，它记录了函数的变量，包括函数的参数和局部定义的变量。&lt;/p&gt;

&lt;p&gt;b) 全局，模块内的命名空间就是全局的，它记录了模块的变量，包括函数、类、其它导入的模块、模块级的变量和常量。&lt;/p&gt;

&lt;p&gt;c) 内置，包括异常类型、内建函数和特殊方法，可以代码中任意地方调用；&lt;/p&gt;

&lt;p&gt;上面提到的globals是全局命名空间，locals是局部命名空间。&lt;/p&gt;

&lt;p&gt;命名空间会在不同的时间创建，并有不同的生命周期。包含内置名称的命名空间是在python解释器启动的时候创建的，并且不会被删除。一个模块的全局命名空间是在模块定义代码被读入的时候创建的，一般情况下，模块命名空间会持续到解释器结束。在解释器最上层调用的代码，不管是从脚本中读入的还是在交互式界面中，都会被认为是属于一个叫做&lt;strong&gt;main&lt;/strong&gt;模块的,所以它们有自己的全局命名空间。（内置名称实际上也放置在一个模块中，称为builtins）。&lt;/p&gt;

&lt;p&gt;一个函数的局部命名空间在函数被调用的时候创建，在函数返回或者引发一个不在函数内部处理的异常时被删除。（实际上用遗忘来描述这个删除比较好。）当然了，递归调用的函数每个都有它们自己的命名空间。&lt;/p&gt;

&lt;h4 id=&#34;命名空间的可见性-作用域&#34;&gt;命名空间的可见性（作用域）&lt;/h4&gt;

&lt;p&gt;作用域是一个Python程序中命名空间直接可见的代码区域，也就是说这个区域内可以直接使用命名空间内的名称。&lt;/p&gt;

&lt;p&gt;a) 内置命名空间在代码所有位置都是可见的，所以可以随时被调用；&lt;/p&gt;

&lt;p&gt;b) 全局命名空间和局部命名空间中， 如果有同名变量，在全局命名空间处，局部命名空间内的同名变量是不可见的；&lt;/p&gt;

&lt;p&gt;c) 在局部命名空间处，全局命名空间的同名变量是不可见的（只有变量不同名的情况下，可使用 global关键字让其可见）。&lt;/p&gt;

&lt;h4 id=&#34;命名空间的查找顺序&#34;&gt;命名空间的查找顺序&lt;/h4&gt;

&lt;p&gt;a) 如果在函数内调用一个变量，先在函数内（局部命名空间）查找，如果找到则停止查找。否则在函数外部（全局命名空间）查找，如果还是没找到，则查找内置命名空间。如果以上三个命名都未找到，则抛出NameError 的异常错误。&lt;/p&gt;

&lt;p&gt;b) 如果在函数外调用一个变量，则在函数外查找（全局命名空间，局部命名空间此时不可见），如果找到则停止查找，否则到内置命名空间中查找。如果两者都找不到，则抛出异常。只有当局部命名空间内，使用global 关键字声明了一个变量时，查找顺序则是 a) 的查找顺序。&lt;/p&gt;

&lt;h4 id=&#34;nested-scopes说明&#34;&gt;nested_scopes说明&lt;/h4&gt;

&lt;p&gt;Python2.2引入了一种略有不同但重要的改变，它会影响命名空间的搜索顺序：嵌套的作用域。在2.0中，当你在一个嵌套函数或 lambda 函数中引用一个变量时，Python会在当前（嵌套的或 lambda）函数的名称空间中搜索，然后在模块的名称空间。2.2将支在当前（嵌套的或 lambda）函数的名称空间中搜索，然后是在父函数的名称空间，接着是模块的名称空间。2.1可以两种方式工作，缺省地，按n2.0的方式工作，如果想像2.2中那样工作，使用下面的导入语句：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from __future__ import nested_scopes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然现在一般都用2.7或者3了，所以已经是嵌套作用域了。&lt;/p&gt;

&lt;p&gt;来看下面一段代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; x = 3
&amp;gt;&amp;gt;&amp;gt; globals()
{&#39;__builtins__&#39;: &amp;lt;module &#39;__builtin__&#39; (built-in)&amp;gt;, &#39;__package__&#39;: None, &#39;func&#39;: &amp;lt;function func at 0x028BA2B0&amp;gt;, &#39;x&#39;: 3, &#39;__name__&#39;: &#39;__main__&#39;, &#39;__doc__&#39;: None}
&amp;gt;&amp;gt;&amp;gt; def func():
        x = 2
	      print locals()

&amp;gt;&amp;gt;&amp;gt; func()
{&#39;x&#39;: 2}
&amp;gt;&amp;gt;&amp;gt; globals()
{&#39;__builtins__&#39;: &amp;lt;module &#39;__builtin__&#39; (built-in)&amp;gt;, &#39;__package__&#39;: None, &#39;func&#39;: &amp;lt;function func at 0x028BA2B0&amp;gt;, &#39;x&#39;: 3, &#39;__name__&#39;: &#39;__main__&#39;, &#39;__doc__&#39;: None}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;全局命名空间中x的值前后并没有改变，反而在func函数的局部命名空间中产生了一个新的名称x。由此可以看出，外层作用域的命名空间对于内层来说是只读的，当写一个同名的名称时，只会在内层生成一个新的名称。但是如果一个名称被声明为global，对其引用和复制都会直接作用域全局名称。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; x = 2
&amp;gt;&amp;gt;&amp;gt; def func():
        global x
	      x = 3
	      print locals()

&amp;gt;&amp;gt;&amp;gt; globals()
{&#39;__builtins__&#39;: &amp;lt;module &#39;__builtin__&#39; (built-in)&amp;gt;, &#39;__package__&#39;: None, &#39;func&#39;: &amp;lt;function func at 0x029FA270&amp;gt;, &#39;x&#39;: 2, &#39;__name__&#39;: &#39;__main__&#39;, &#39;__doc__&#39;: None
&amp;gt;&amp;gt;&amp;gt; func()
{}
&amp;gt;&amp;gt;&amp;gt; globals()
{&#39;__builtins__&#39;: &amp;lt;module &#39;__builtin__&#39; (built-in)&amp;gt;, &#39;__package__&#39;: None, &#39;func&#39;: &amp;lt;function func at 0x029FA270&amp;gt;, &#39;x&#39;: 3, &#39;__name__&#39;: &#39;__main__&#39;, &#39;__doc__&#39;: None}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;x的值前后改变了，而且func函数中也没用增加x。&lt;/p&gt;

&lt;h4 id=&#34;import-module和from-module-import-func&#34;&gt;import module和from module import func&lt;/h4&gt;

&lt;p&gt;import module将模块自身导入到当前命名空间，所以如果要使用module的某个函数或属性，只能module.func这么用。&lt;/p&gt;

&lt;p&gt;而使用from module import func，则是将函数func导入当前的名称空间，这时候使用这个函数就不需要模块名称而是直接使用func。&lt;/p&gt;

&lt;p&gt;我们通过一段代码来描述：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; globals()
{&#39;__builtins__&#39;: &amp;lt;module &#39;__builtin__&#39; (built-in)&amp;gt;, &#39;__package__&#39;: None, &#39;__name__&#39;: &#39;__main__&#39;, &#39;__doc__&#39;: None}
&amp;gt;&amp;gt;&amp;gt; import os
&amp;gt;&amp;gt;&amp;gt; globals()
{&#39;__builtins__&#39;: &amp;lt;module &#39;__builtin__&#39; (built-in)&amp;gt;, &#39;__package__&#39;: None, &#39;__name__&#39;: &#39;__main__&#39;, &#39;os&#39;: &amp;lt;module &#39;os&#39; from &#39;C:\Python27\lib\os.pyc&#39;&amp;gt;, &#39;__doc__&#39;: None}
&amp;gt;&amp;gt;&amp;gt; del os
&amp;gt;&amp;gt;&amp;gt; from os import sys
&amp;gt;&amp;gt;&amp;gt; globals()
{&#39;__builtins__&#39;: &amp;lt;module &#39;__builtin__&#39; (built-in)&amp;gt;, &#39;__package__&#39;: None, &#39;sys&#39;: &amp;lt;module &#39;sys&#39; (built-in)&amp;gt;, &#39;__name__&#39;: &#39;__main__&#39;, &#39;__doc__&#39;: None}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;是不是很清晰，担任sys也是一个模块，如果要使用sys模块的属性，也必须要使用sys模块名了。这也是嵌套作用域的一个例子。&lt;/p&gt;

&lt;p&gt;额。。。貌似本文的正题是__future__，哈哈，扯远了，我们继续来看下面一个feauture。&lt;/p&gt;

&lt;h3 id=&#34;generators&#34;&gt;generators&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;generators = _Feature((2, 2, 0, &amp;quot;alpha&amp;quot;, 1),
                      (2, 3, 0, &amp;quot;final&amp;quot;, 0),
                      CO_GENERATOR_ALLOWED)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;generators生成器起于2.2.0a1版，在2.3.0f0中成为标准。&lt;/p&gt;

&lt;h4 id=&#34;简介-1&#34;&gt;简介&lt;/h4&gt;

&lt;p&gt;生成器是这样一个函数，它记住上一次返回时在函数体中的位置。对生成器函数的第二次（或第 n 次）调用跳转至该函数中间，而上次调用的所有局部变量都保持不变。Python中yeild就是一个生成器。&lt;/p&gt;

&lt;h4 id=&#34;yield-生成器的运行机制&#34;&gt;yield 生成器的运行机制&lt;/h4&gt;

&lt;p&gt;当你问生成器要一个数时，生成器会执行，直至出现 yield 语句，生成器把 yield 的参数给你，之后生成器就不会往下继续运行。 当你问他要下一个数时，他会从上次的状态。开始运行，直至出现yield语句，把参数给你，之后停下。如此反复直至退出函数。&lt;/p&gt;

&lt;h4 id=&#34;示例&#34;&gt;示例&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; def my_generator():
	      yield 1
	      yield 2
	      yield 3

&amp;gt;&amp;gt;&amp;gt; gen = my_generator()
&amp;gt;&amp;gt;&amp;gt; gen.next()
1
&amp;gt;&amp;gt;&amp;gt; gen.next()
2
&amp;gt;&amp;gt;&amp;gt; gen.next()
3
&amp;gt;&amp;gt;&amp;gt; gen.next()

Traceback (most recent call last):
  File &amp;quot;&amp;lt;pyshell#92&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt;
    gen.next()
StopIteration
&amp;gt;&amp;gt;&amp;gt; for n in my_generator:
        print n
1
2
3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;yield在被next调用之前并没有执行（for循环内部也是使用next），在执行完最后一个yield之后再继续调用next，那么就好遇到StopIteration异常了。这里涉及到迭代器了，不再进行详细的描述了，后面会单开一章来讲Python的三大器：迭代器、生成器、装饰器。&lt;/p&gt;

&lt;h3 id=&#34;division&#34;&gt;division&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;division = _Feature((2, 2, 0, &amp;quot;alpha&amp;quot;, 2),
                    (3, 0, 0, &amp;quot;alpha&amp;quot;, 0),
                    CO_FUTURE_DIVISION)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个很简单，举例说明一下大家就懂了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# python2.7中，不导入__future__
&amp;gt;&amp;gt;&amp;gt; 10/3
3

# 导入__future__
&amp;gt;&amp;gt;&amp;gt; from __future__ import division
&amp;gt;&amp;gt;&amp;gt; 10/3
3.3333333333333335
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;很容易看出来，2.7中默认的整数除法是结果向下取整，而导入了__future__之后除法就是真正的除法了。这也是python2和python3的一个重要区别。&lt;/p&gt;

&lt;h3 id=&#34;absolute-import&#34;&gt;absolute_import&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;absolute_import = _Feature((2, 5, 0, &amp;quot;alpha&amp;quot;, 1),
                           (3, 0, 0, &amp;quot;alpha&amp;quot;, 0),
                           CO_FUTURE_ABSOLUTE_IMPORT)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;python2.7中，在默认情况下，导入模块是相对导入的（relative import），比如说&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from . import json
from .json import json_dump
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这些以&amp;rsquo;.&amp;lsquo;点导入的是相对导入，而绝对导入（absolute import）则是指从系统路径sys.path最底层的模块导入。比如:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import os
from os import sys
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;with-statement&#34;&gt;with_statement&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;with_statement = _Feature((2, 5, 0, &amp;quot;alpha&amp;quot;, 1),
                          (2, 6, 0, &amp;quot;alpha&amp;quot;, 0),
                          CO_FUTURE_WITH_STATEMENT)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;with语句也不详细讲了，看这篇&lt;a href=&#34;http://blog.syfun.net/2015/07/07/python-with-statement&#34;&gt;浅谈Python的with语句&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;print-function&#34;&gt;print_function&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;print_function = _Feature((2, 6, 0, &amp;quot;alpha&amp;quot;, 2),
                          (3, 0, 0, &amp;quot;alpha&amp;quot;, 0),
                          CO_FUTURE_PRINT_FUNCTION)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个就是最经典的python2和python3的区别了，python2中print不需要括号，而在python3中则需要。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# python2.7
print &amp;quot;Hello world&amp;quot;

# python3
print(&amp;quot;Hello world&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;unicode-literals&#34;&gt;unicode_literals&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;unicode_literals = _Feature((2, 6, 0, &amp;quot;alpha&amp;quot;, 2),
                            (3, 0, 0, &amp;quot;alpha&amp;quot;, 0),
                            CO_FUTURE_UNICODE_LITERALS)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是unicode的问题，讲起来又是长篇大论了，容我偷个懒，后面再讲吧。&lt;/p&gt;

&lt;p&gt;至此，__future__模块的几个特性，算是说完了。好多内容都是参照官方文档，所以大家还是多看文档吧。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Python routes</title>
      <link>/post/python-routes/</link>
      <pubDate>Wed, 08 Apr 2015 19:21:51 +0800</pubDate>
      
      <guid>/post/python-routes/</guid>
      <description>&lt;h2 id=&#34;ruotes简介&#34;&gt;Ruotes简介&lt;/h2&gt;

&lt;p&gt;Routes解决了一个Web开发中经常遇到的问题，那就是怎么将url请求map到app，也就是，你怎么能说&amp;rsquo;/blog/2008/01/08&amp;rsquo;做这件事，而&amp;rsquo;/login&amp;rsquo;却做另外一个。许多Web框架都有一个内置的调度系统。比如，&amp;rsquo;/A/B/C&amp;rsquo;表示在目录B中读文件C，或者在&amp;rsquo;A.B&amp;rsquo;模块中调用B类的C方法。这样看，毫无问题。但是，当你要重新组织urls的时候，改动就会很大。&lt;/p&gt;

&lt;p&gt;Routes却另辟蹊径。它将url层次和action分离，你可以按照你想要的方式去连接它们。如果你要改变一个特定的url，只要改变route map的一行代码，而不用改变action的逻辑。甚至你可以将多个url指向相同的action。Routes最早起源于Ruby on Rails，到现在已经有很大的不同了。&lt;/p&gt;

&lt;p&gt;Ruotes是Pylons框架最初的调度系统，也是CherrPy的一种调度。所有的Web框架都能用它来处理整个url架构或者是url的subtree。它也可以将subtree指向其他的调度，TurboGear 2在Pylons就是这么实现的。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;搭建routes&#34;&gt;搭建Routes&lt;/h2&gt;

&lt;p&gt;Routes安装可以用pip或者easy_insatll，也可以下载源码用python setup.py install安装。&lt;/p&gt;

&lt;p&gt;Pylons中，在myapp/config/routing.py模块的make_map函数中定义routes，下面是一个典型的配置：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from routes import Mapper
map = Mapper()
map.connect(None, &amp;quot;/error/{action}/{id}&amp;quot;, controller=&amp;quot;error&amp;quot;)
map.connect(&amp;quot;home&amp;quot;, &amp;quot;/&amp;quot;, controller=&amp;quot;main&amp;quot;, action=&amp;quot;index&amp;quot;)
# ADD CUSTOM ROUTES HERE
map.connect(None, &amp;quot;/{controller}/{action}&amp;quot;)
map.connect(None, &amp;quot;/{controller}/{action}/{id}&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第1行和第2行创建一个mapper。&lt;/p&gt;

&lt;p&gt;第3行匹配以&amp;rsquo;/error&amp;rsquo;开头的三层url，将controller参数设置成常量。url请求&amp;rsquo;/error/images/arrow.jpg&amp;rsquo;会产生：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;{&amp;quot;controller&amp;quot;: &amp;quot;error&amp;quot;, &amp;quot;action&amp;quot;: &amp;quot;images&amp;quot;, &amp;quot;id&amp;quot;: &amp;quot;arrow.jpg&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第4行匹配&amp;rsquo;/&amp;lsquo;, controller和action参数都设置成了常量，还有route名称&amp;rsquo;home&amp;rsquo;，它可以用来生成url。（其他route用None代替name。建议生成url的route都命名，其他route没有必要。）&lt;/p&gt;

&lt;p&gt;第6行匹配任意的两层url，第7行匹配任意三层url。当我们不想为每个action都定义不同的route时，这么做是很有用的。当然，如果你为每个action都定义了route，就可以删掉这两行了。&lt;/p&gt;

&lt;p&gt;注意，&amp;rsquo;/error/images/arrow.jpg&amp;rsquo;可以匹配第3行和第7行。mapper是按顺序匹配，所以这个url匹配第3行。&lt;/p&gt;

&lt;p&gt;如果没有route能匹配url，mapper会返回&amp;rsquo;matach failed&amp;rsquo;，在Pylons就是&amp;rsquo;404 Not Found&amp;rsquo;。&lt;/p&gt;

&lt;p&gt;Route path必须以&amp;rsquo;/&amp;lsquo;开头。&lt;/p&gt;

&lt;h3 id=&#34;requirements&#34;&gt;Requirements&lt;/h3&gt;

&lt;p&gt;Route path可以使用正则表达式。有两种方式：一是行内，二是使用requirements参数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;map.connect(R&amp;quot;/blog/{id:\d+}&amp;quot;)
map.connect(R&amp;quot;/download/{platform:windows|mac}/{filename}&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;等同于：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;map.connect(&amp;quot;/blog/{id}&amp;quot;, requirements={&amp;quot;id&amp;quot;: R&amp;quot;\d+&amp;quot;}
map.connect(&amp;quot;/download/{platform}/{filename}&amp;quot;,
    requirements={&amp;quot;platform&amp;quot;: R&amp;quot;windows|mac&amp;quot;})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了包含&amp;rsquo;\&amp;lsquo;，正则表达式使用了R&amp;rdquo;&amp;ldquo;。如果不用R，就要使用&amp;rsquo;\&amp;lsquo;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;m.connect(&amp;quot;archives/{year}/{month}/{day}&amp;quot;, controller=&amp;quot;archives&amp;quot;,
          action=&amp;quot;view&amp;quot;, year=2004,
          requirements=dict(year=R&amp;quot;\d{2,4}&amp;quot;, month=R&amp;quot;\d{1,2}&amp;quot;))

NUMERIC = R&amp;quot;\d+&amp;quot;
map.connect(..., requirements={&amp;quot;id&amp;quot;: NUMERIC})

ARTICLE_REQS = {&amp;quot;year&amp;quot;: R&amp;quot;\d\d\d\d&amp;quot;, &amp;quot;month&amp;quot;: R&amp;quot;\d\d&amp;quot;, &amp;quot;day&amp;quot;: R&amp;quot;\d\d&amp;quot;}
map.connect(..., requirements=ARTICLE_REQS)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;conditions&#34;&gt;Conditions&lt;/h3&gt;

&lt;p&gt;Conditions决定匹配何种请求。conditions参数是一个字典，有三个key：&lt;/p&gt;

&lt;p&gt;method&lt;/p&gt;

&lt;p&gt;大写的HTTP方法列表，请求的方法必须是其中某一种。&lt;/p&gt;

&lt;p&gt;sub_domain&lt;/p&gt;

&lt;p&gt;可以是subdomain列表，True，False或者None。如果是列表，请求必须调用列表中的subdomain。如果是True，请求必须包括任意一个subdomain。如果是False或者None，不匹配subdomain。&lt;/p&gt;

&lt;p&gt;function&lt;/p&gt;

&lt;p&gt;验证request的函数。它必须是func(envirion, match_dict) =&amp;gt; bool这种类型。如果匹配成功返回True，否则返回False。第一个参数是WSGI环境变量，第二个参数是匹配成功后返回的变量。函数还可以改变mtach。&lt;/p&gt;

&lt;p&gt;例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Match only if the HTTP method is &amp;quot;GET&amp;quot; or &amp;quot;HEAD&amp;quot;.
m.connect(&amp;quot;/user/list&amp;quot;, controller=&amp;quot;user&amp;quot;, action=&amp;quot;list&amp;quot;,
          conditions=dict(method=[&amp;quot;GET&amp;quot;, &amp;quot;HEAD&amp;quot;]))

# A sub-domain should be present.
m.connect(&amp;quot;/&amp;quot;, controller=&amp;quot;user&amp;quot;, action=&amp;quot;home&amp;quot;,
          conditions=dict(sub_domain=True))

# Sub-domain should be either &amp;quot;fred&amp;quot; or &amp;quot;george&amp;quot;.
m.connect(&amp;quot;/&amp;quot;, controller=&amp;quot;user&amp;quot;, action=&amp;quot;home&amp;quot;,
          conditions=dict(sub_domain=[&amp;quot;fred&amp;quot;, &amp;quot;george&amp;quot;]))

# Put the referrer into the resulting match dictionary.
# This function always returns true, so it never prevents the match
# from succeeding.
def referals(environ, result):
    result[&amp;quot;referer&amp;quot;] = environ.get(&amp;quot;HTTP_REFERER&amp;quot;)
    return True
m.connect(&amp;quot;/{controller}/{action}/{id}&amp;quot;,
    conditions=dict(function=referals))
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;wildcard-routes&#34;&gt;Wildcard routes&lt;/h3&gt;

&lt;p&gt;path变量默认情况不匹配&amp;rsquo;/&amp;lsquo;。这是为了保证每个path精确匹配某一层url。你可以用requirements去覆盖：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;map.connect(&amp;quot;/static/{filename:.*?}&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;匹配&amp;rsquo;/static/foo.jpg&amp;rsquo;，&amp;rsquo;/static/bar/foo.jpg&amp;rsquo;等url。&lt;/p&gt;

&lt;h3 id=&#34;format-extensions&#34;&gt;Format extensions&lt;/h3&gt;

&lt;p&gt;path中包含&amp;rsquo;{.format}&amp;lsquo;会匹配可选的扩展名（如.html或者.json），在&amp;rsquo;.&amp;lsquo;之后设置format变量。例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;map.connect(&#39;/entries/{id}{.format}&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;匹配&amp;rsquo;/entries/1&amp;rsquo;和&amp;rsquo;/entires/1.mp3&amp;rsquo;。你可以用requirements去限制匹配的扩展名：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;map.connect(&#39;/entries/{id:\d+}{.format:json}&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;匹配&amp;rsquo;/entries/1&amp;rsquo;和&amp;rsquo;/entires/1.json&amp;rsquo;，但是不匹配&amp;rsquo;/entires/1.mp3&amp;rsquo;。&lt;/p&gt;

&lt;h3 id=&#34;submappers&#34;&gt;Submappers&lt;/h3&gt;

&lt;p&gt;如果有相同的Key-value参数，可以用Submapper来添加route。有两种语法，一个使用&lt;code&gt;with&lt;/code&gt;，一个不用：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Using &#39;with&#39;
with map.submapper(controller=&amp;quot;home&amp;quot;) as m:
    m.connect(&amp;quot;home&amp;quot;, &amp;quot;/&amp;quot;, action=&amp;quot;splash&amp;quot;)
    m.connect(&amp;quot;index&amp;quot;, &amp;quot;/index&amp;quot;, action=&amp;quot;index&amp;quot;)

# Not using &#39;with&#39;
m = map.submapper(controller=&amp;quot;home&amp;quot;)
m.connect(&amp;quot;home&amp;quot;, &amp;quot;/&amp;quot;, action=&amp;quot;splash&amp;quot;)
m.connect(&amp;quot;index&amp;quot;, &amp;quot;/index&amp;quot;, action=&amp;quot;index&amp;quot;)

# Both of these syntaxes create the following routes::
# &amp;quot;/&amp;quot;      =&amp;gt; {&amp;quot;controller&amp;quot;: &amp;quot;home&amp;quot;, action=&amp;quot;splash&amp;quot;}
# &amp;quot;/index&amp;quot; =&amp;gt; {&amp;quot;controller&amp;quot;: &amp;quot;home&amp;quot;, action=&amp;quot;index&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以使用&lt;code&gt;path_prefix&lt;/code&gt;参数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;with map.submapper(path_prefix=&amp;quot;/admin&amp;quot;, controller=&amp;quot;admin&amp;quot;) as m:
    m.connect(&amp;quot;admin_users&amp;quot;, &amp;quot;/users&amp;quot;, action=&amp;quot;users&amp;quot;)
    m.connect(&amp;quot;admin_databases&amp;quot;, &amp;quot;/databases&amp;quot;, action=&amp;quot;databases&amp;quot;)

# /admin/users     =&amp;gt; {&amp;quot;controller&amp;quot;: &amp;quot;admin&amp;quot;, &amp;quot;action&amp;quot;: &amp;quot;users&amp;quot;}
# /admin/databases =&amp;gt; {&amp;quot;controller&amp;quot;: &amp;quot;admin&amp;quot;, &amp;quot;action&amp;quot;: &amp;quot;databases&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;.submapper&lt;/code&gt;的参数必须是key-value。&lt;/p&gt;

&lt;h3 id=&#34;submapper-helpers&#34;&gt;Submapper helpers&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;with map.submapper(controller=&amp;quot;home&amp;quot;) as m:
    m.connect(&amp;quot;home&amp;quot;, &amp;quot;/&amp;quot;, action=&amp;quot;splash&amp;quot;)
    m.connect(&amp;quot;index&amp;quot;, &amp;quot;/index&amp;quot;, action=&amp;quot;index&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以写成：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;with map.submapper(controller=&amp;quot;home&amp;quot;, path_prefix=&amp;quot;/&amp;quot;) as m:
    m.action(&amp;quot;home&amp;quot;, action=&amp;quot;splash&amp;quot;)
    m.link(&amp;quot;index&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;action&lt;/code&gt;在submapper的path（上例中是&amp;rsquo;/&amp;lsquo;）上生成route。而&lt;code&gt;link&lt;/code&gt;根据相关的path生成route。&lt;/p&gt;

&lt;p&gt;还有一些其他的action，&lt;code&gt;index&lt;/code&gt;，&lt;code&gt;new&lt;/code&gt;，&lt;code&gt;create&lt;/code&gt;，&lt;code&gt;show&lt;/code&gt;，&lt;code&gt;edit&lt;/code&gt;，&lt;code&gt;update&lt;/code&gt;和&lt;code&gt;delete&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;with map.submapper(controller=&amp;quot;entries&amp;quot;, path_prefix=&amp;quot;/entries&amp;quot;) as entries:
    entries.index()
    with entries.submapper(path_prefix=&amp;quot;/{id}&amp;quot;) as entry:
        entry.show()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;with map.submapper(controller=&amp;quot;entries&amp;quot;, path_prefix=&amp;quot;/entries&amp;quot;,
                   actions=[&amp;quot;index&amp;quot;]) as entries:
    entries.submapper(path_prefix=&amp;quot;/{id}&amp;quot;, actions=[&amp;quot;show&amp;quot;])
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;map.collection(collection_name=&amp;quot;entries&amp;quot;, member_name=&amp;quot;entry&amp;quot;,
               controller=&amp;quot;entries&amp;quot;,
               collection_actions=[&amp;quot;index&amp;quot;], member_actions[&amp;quot;show&amp;quot;])
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;restful-services&#34;&gt;RESTful services&lt;/h2&gt;

&lt;p&gt;map.resource使Restful风格的url更加容易，它创建了一个&amp;rsquo;add/modify/delete&amp;rsquo;route集。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;map.resource(&amp;quot;message&amp;quot;, &amp;quot;messages&amp;quot;)

# The above command sets up several routes as if you had typed the
# following commands:
map.connect(&amp;quot;messages&amp;quot;, &amp;quot;/messages&amp;quot;,
    controller=&amp;quot;messages&amp;quot;, action=&amp;quot;create&amp;quot;,
    conditions=dict(method=[&amp;quot;POST&amp;quot;]))
map.connect(&amp;quot;messages&amp;quot;, &amp;quot;/messages&amp;quot;,
    controller=&amp;quot;messages&amp;quot;, action=&amp;quot;index&amp;quot;,
    conditions=dict(method=[&amp;quot;GET&amp;quot;]))
map.connect(&amp;quot;formatted_messages&amp;quot;, &amp;quot;/messages.{format}&amp;quot;,
    controller=&amp;quot;messages&amp;quot;, action=&amp;quot;index&amp;quot;,
    conditions=dict(method=[&amp;quot;GET&amp;quot;]))
map.connect(&amp;quot;new_message&amp;quot;, &amp;quot;/messages/new&amp;quot;,
    controller=&amp;quot;messages&amp;quot;, action=&amp;quot;new&amp;quot;,
    conditions=dict(method=[&amp;quot;GET&amp;quot;]))
map.connect(&amp;quot;formatted_new_message&amp;quot;, &amp;quot;/messages/new.{format}&amp;quot;,
    controller=&amp;quot;messages&amp;quot;, action=&amp;quot;new&amp;quot;,
    conditions=dict(method=[&amp;quot;GET&amp;quot;]))
map.connect(&amp;quot;/messages/{id}&amp;quot;,
    controller=&amp;quot;messages&amp;quot;, action=&amp;quot;update&amp;quot;,
    conditions=dict(method=[&amp;quot;PUT&amp;quot;]))
map.connect(&amp;quot;/messages/{id}&amp;quot;,
    controller=&amp;quot;messages&amp;quot;, action=&amp;quot;delete&amp;quot;,
    conditions=dict(method=[&amp;quot;DELETE&amp;quot;]))
map.connect(&amp;quot;edit_message&amp;quot;, &amp;quot;/messages/{id}/edit&amp;quot;,
    controller=&amp;quot;messages&amp;quot;, action=&amp;quot;edit&amp;quot;,
    conditions=dict(method=[&amp;quot;GET&amp;quot;]))
map.connect(&amp;quot;formatted_edit_message&amp;quot;, &amp;quot;/messages/{id}.{format}/edit&amp;quot;,
    controller=&amp;quot;messages&amp;quot;, action=&amp;quot;edit&amp;quot;,
    conditions=dict(method=[&amp;quot;GET&amp;quot;]))
map.connect(&amp;quot;message&amp;quot;, &amp;quot;/messages/{id}&amp;quot;,
    controller=&amp;quot;messages&amp;quot;, action=&amp;quot;show&amp;quot;,
    conditions=dict(method=[&amp;quot;GET&amp;quot;]))
map.connect(&amp;quot;formatted_message&amp;quot;, &amp;quot;/messages/{id}.{format}&amp;quot;,
    controller=&amp;quot;messages&amp;quot;, action=&amp;quot;show&amp;quot;,
    conditions=dict(method=[&amp;quot;GET&amp;quot;]))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;GET    /messages        =&amp;gt; messages.index()    =&amp;gt; url(&amp;quot;messages&amp;quot;)
POST   /messages        =&amp;gt; messages.create()   =&amp;gt; url(&amp;quot;messages&amp;quot;)
GET    /messages/new    =&amp;gt; messages.new()      =&amp;gt; url(&amp;quot;new_message&amp;quot;)
PUT    /messages/1      =&amp;gt; messages.update(id) =&amp;gt; url(&amp;quot;message&amp;quot;, id=1)
DELETE /messages/1      =&amp;gt; messages.delete(id) =&amp;gt; url(&amp;quot;message&amp;quot;, id=1)
GET    /messages/1      =&amp;gt; messages.show(id)   =&amp;gt; url(&amp;quot;message&amp;quot;, id=1)
GET    /messages/1/edit =&amp;gt; messages.edit(id)   =&amp;gt; url(&amp;quot;edit_message&amp;quot;, id=1)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;resource-options&#34;&gt;Resource options&lt;/h3&gt;

&lt;p&gt;controller&lt;/p&gt;

&lt;p&gt;collection&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;map.resource(&amp;quot;message&amp;quot;, &amp;quot;messages&amp;quot;, collection={&amp;quot;rss&amp;quot;: &amp;quot;GET&amp;quot;})
# &amp;quot;GET /messages/rss&amp;quot;  =&amp;gt;  ``Messages.rss()``.
# Defines a named route &amp;quot;rss_messages&amp;quot;.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;member&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;map.resource(&#39;message&#39;, &#39;messages&#39;, member={&#39;mark&#39;:&#39;POST&#39;})
# &amp;quot;POST /message/1/mark&amp;quot;  =&amp;gt;  ``Messages.mark(1)``
# also adds named route &amp;quot;mark_message&amp;quot;

map.resource(&amp;quot;message&amp;quot;, &amp;quot;messages&amp;quot;, member={&amp;quot;ask_delete&amp;quot;: &amp;quot;GET&amp;quot;}
# &amp;quot;GET /message/1/ask_delete&amp;quot;   =&amp;gt;   ``Messages.ask_delete(1)``.
# Also adds a named route &amp;quot;ask_delete_message&amp;quot;.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;new&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;map.resource(&amp;quot;message&amp;quot;, &amp;quot;messages&amp;quot;, new={&amp;quot;preview&amp;quot;: &amp;quot;POST&amp;quot;})
# &amp;quot;POST /messages/new/preview&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;path_prefix&lt;/p&gt;

&lt;p&gt;所有url的前置。&lt;/p&gt;

&lt;p&gt;name_prefix&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;map.resource(&amp;quot;message&amp;quot;, &amp;quot;messages&amp;quot;, controller=&amp;quot;categories&amp;quot;,
    path_prefix=&amp;quot;/category/{category_id}&amp;quot;,
    name_prefix=&amp;quot;category_&amp;quot;)
# GET /category/7/message/1
# Adds named route &amp;quot;category_message&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;parent_resource&lt;/p&gt;

&lt;p&gt;一个包含父resource信息的字典，在创建嵌套resource使用。它应该包含member_name和collection_name。&lt;/p&gt;

&lt;p&gt;如果指定parent_resource而没有path_prefix，path_prefix将用&amp;rsquo;&amp;lt;parent collection name&amp;gt;/:&amp;lt;parent member name&amp;gt;_id&amp;rsquo;生成。&lt;/p&gt;

&lt;p&gt;如果指定parent_resource而没有name_prefix，name_prefix将用&amp;rsquo;&amp;lt;parent member name&amp;gt;_&amp;lsquo;生成。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; m = Mapper()
&amp;gt;&amp;gt;&amp;gt; m.resource(&#39;location&#39;, &#39;locations&#39;,
...            parent_resource=dict(member_name=&#39;region&#39;,
...                                 collection_name=&#39;regions&#39;))
&amp;gt;&amp;gt;&amp;gt; # path_prefix is &amp;quot;regions/:region_id&amp;quot;
&amp;gt;&amp;gt;&amp;gt; # name prefix is &amp;quot;region_&amp;quot;
&amp;gt;&amp;gt;&amp;gt; url(&#39;region_locations&#39;, region_id=13)
&#39;/regions/13/locations&#39;
&amp;gt;&amp;gt;&amp;gt; url(&#39;region_new_location&#39;, region_id=13)
&#39;/regions/13/locations/new&#39;
&amp;gt;&amp;gt;&amp;gt; url(&#39;region_location&#39;, region_id=13, id=60)
&#39;/regions/13/locations/60&#39;
&amp;gt;&amp;gt;&amp;gt; url(&#39;region_edit_location&#39;, region_id=13, id=60)
&#39;/regions/13/locations/60/edit&#39;

Overriding generated path_prefix:

&amp;gt;&amp;gt;&amp;gt; m = Mapper()
&amp;gt;&amp;gt;&amp;gt; m.resource(&#39;location&#39;, &#39;locations&#39;,
...            parent_resource=dict(member_name=&#39;region&#39;,
...                                 collection_name=&#39;regions&#39;),
...            path_prefix=&#39;areas/:area_id&#39;)
&amp;gt;&amp;gt;&amp;gt; # name prefix is &amp;quot;region_&amp;quot;
&amp;gt;&amp;gt;&amp;gt; url(&#39;region_locations&#39;, area_id=51)
&#39;/areas/51/locations&#39;

Overriding generated name_prefix:

&amp;gt;&amp;gt;&amp;gt; m = Mapper()
&amp;gt;&amp;gt;&amp;gt; m.resource(&#39;location&#39;, &#39;locations&#39;,
...            parent_resource=dict(member_name=&#39;region&#39;,
...                                 collection_name=&#39;regions&#39;),
...            name_prefix=&#39;&#39;)
&amp;gt;&amp;gt;&amp;gt; # path_prefix is &amp;quot;regions/:region_id&amp;quot;
&amp;gt;&amp;gt;&amp;gt; url(&#39;locations&#39;, region_id=51)
&#39;/regions/51/locations&#39;
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Python argparse</title>
      <link>/post/python-argparse/</link>
      <pubDate>Thu, 02 Apr 2015 19:21:04 +0800</pubDate>
      
      <guid>/post/python-argparse/</guid>
      <description>&lt;p&gt;最近在看openstack cinderclient代码，就顺带着看了下argparse。argparse是Python官方推荐的命令行解析工具库。&lt;/p&gt;

&lt;p&gt;学习Python库首先要去看&lt;a href=&#34;https://docs.python.org/2.7/library/argparse.html&#34;&gt;官方文档&lt;/a&gt;，这里有个简单的&lt;a href=&#34;https://docs.python.org/2.7/howto/argparse.html#id1&#34;&gt;Tutorial&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;让我们看下Linux中常见的ls命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls
cpython  devguide  prog.py  pypy  rm-unused-function.patch
$ ls pypy
ctypes_configure  demo  dotviewer  include  lib_pypy  lib-python ...
$ ls -l
total 20
drwxr-xr-x 19 wena wena 4096 Feb 18 18:51 cpython
drwxr-xr-x  4 wena wena 4096 Feb  8 12:04 devguide
-rwxr-xr-x  1 wena wena  535 Feb 19 00:05 prog.py
drwxr-xr-x 14 wena wena 4096 Feb  7 00:59 pypy
-rw-r--r--  1 wena wena  741 Feb 18 01:01 rm-unused-function.patch
$ ls --help
Usage: ls [OPTION]... [FILE]...
List information about the FILEs (the current directory by default).
Sort entries alphabetically if none of -cftuvSUX nor --sort is specified.
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上面的四条命令我们可以学到一些概念：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;ls命令在没有参数时，默认显示当前目录下所有的内容&lt;/li&gt;
&lt;li&gt;加了pypy这个位置参数（positional argument），就会得到了pypy目录下的内容&lt;/li&gt;
&lt;li&gt;加了-l这个可选参数（optional argument）后，显示文件更多信息&lt;/li&gt;
&lt;li&gt;帮助文档&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下面我们来看argparse如何使用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;prog.py

import argparse
parser = argparse.ArgumentParser()
parser.add_argument(&amp;quot;echo&amp;quot;)
args = parser.parse_args()
print args.echo


$ python prog.py
usage: prog.py [-h] echo
prog.py: error: the following arguments are required: echo
$ python prog.py --help
usage: prog.py [-h] echo

positional arguments:
  echo

optional arguments:
  -h, --help  show this help message and exit
$ python prog.py foo
foo
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;add_argument()方法为程序添加命令行参数，而在加了参数之后，运行程序就需要额外的参数&lt;/li&gt;
&lt;li&gt;parse_args()方法返回接受到的参数，存放在args中，而且它有一个&amp;rsquo;echo&amp;rsquo;属性，值便是我们传进去的参数值，是不是很神奇？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上面的程序中，echo参数没有帮助说明，因此我们并不知道它是用来做什么的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;prog.py

import argparse
parser = argparse.ArgumentParser()
parser.add_argument(&amp;quot;echo&amp;quot;, help=&amp;quot;echo the string you use here&amp;quot;)
args = parser.parse_args()
print args.echo


$ python prog.py -h
usage: prog.py [-h] echo

positional arguments:
  echo        echo the string you use here

optional arguments:
  -h, --help  show this help message and exit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;来看一个更有意义的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;prog.py

import argparse
parser = argparse.ArgumentParser()
parser.add_argument(&amp;quot;square&amp;quot;, help=&amp;quot;display a square of a given number&amp;quot;)
args = parser.parse_args()
print args.square**2


$ python prog.py 4
Traceback (most recent call last):
  File &amp;quot;prog.py&amp;quot;, line 5, in &amp;lt;module&amp;gt;
    print args.square**2
TypeError: unsupported operand type(s) for ** or pow(): &#39;str&#39; and &#39;int&#39;


pyog.py
import argparse
parser = argparse.ArgumentParser()
parser.add_argument(&amp;quot;square&amp;quot;, help=&amp;quot;display a square of a given number&amp;quot;,
                    type=int)
args = parser.parse_args()
print args.square**2


$ python prog.py 4
16
$ python prog.py four
usage: prog.py [-h] square
prog.py: error: argument square: invalid int value: &#39;four&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上加的参数都是位置参数，下面我们试下可选参数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;prog.py

import argparse
parser = argparse.ArgumentParser()
parser.add_argument(&amp;quot;--verbosity&amp;quot;, help=&amp;quot;increase output verbosity&amp;quot;)
args = parser.parse_args()
if args.verbosity:
    print &amp;quot;verbosity turned on&amp;quot;


$ python prog.py --verbosity 1
verbosity turned on
$ python prog.py
$ python prog.py --help
usage: prog.py [-h] [--verbosity VERBOSITY]

optional arguments:
  -h, --help            show this help message and exit
  --verbosity VERBOSITY
                        increase output verbosity
$ python prog.py --verbosity
usage: prog.py [-h] [--verbosity VERBOSITY]
prog.py: error: argument --verbosity: expected one argument
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>url短网址算法python实现</title>
      <link>/post/swift-short-url/</link>
      <pubDate>Tue, 10 Jun 2014 19:22:40 +0800</pubDate>
      
      <guid>/post/swift-short-url/</guid>
      <description>&lt;p&gt;最近在做swift对象存储的共享功能，由于共享url过长，就想到有没有一种缩短的算法。网上查了下，便找到这种url短网址算法。&lt;/p&gt;

&lt;p&gt;算法的基本思路如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;短网址一般有6位，假如每一位是由[a-z0-9A-Z]共62个字符组成，一共有62^6~=568亿种组合。&lt;/li&gt;
&lt;li&gt;将长url存入数据库，用返回的ID转换成6位短url，再将该短url存入数据库，这样就有长短url的映射关系了。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;数据结构：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;id，int类型，自动增长&lt;/li&gt;
&lt;li&gt;lurl，string类型&lt;/li&gt;
&lt;li&gt;surl，string类型&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;那么如何转换ID呢？&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://stackoverflow.com/questions/742013/how-to-code-a-url-shortener&#34;&gt;How to code a URL shortener?&lt;/a&gt;告诉我们一种不错的方法，借鉴进制之间的转换。id是个十进制的值，上述62个字符可以组成一个62进制，这样便可以轻松的转换了。转换算法如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def base62(value_10):
    value_62 = []
    while 1:
        if value_10 &amp;lt; 62:
            value_62.append(value_10)
            break
        else:
            remainder = value_10 % 62
            value_62.append(remainder)
            value_10 = value_10 / 62
    zero_num = 6 - len(value_62)
    value_62.extend([0]*zero_num)
    return value_62

def base10(value_62):
    value_10 = 0
    for i in range(len(value_62)):
        value_10 += (value_62[i]*62**i)
    return value_10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述代码实现10进制id和了62进制的转换，之后找到对应的字符便能组成一个新的url，代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def shorturl(lurl):
    charlist = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;, &#39;i&#39;,
                &#39;j&#39;, &#39;k&#39;, &#39;l&#39;, &#39;m&#39;, &#39;n&#39;, &#39;o&#39;, &#39;p&#39;, &#39;q&#39;, &#39;r&#39;,
                &#39;s&#39;, &#39;t&#39;, &#39;u&#39;, &#39;v&#39;, &#39;w&#39;, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;, &#39;0&#39;,
                &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;,
                &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;,
                &#39;J&#39;, &#39;K&#39;, &#39;L&#39;, &#39;M&#39;, &#39;N&#39;, &#39;O&#39;, &#39;P&#39;, &#39;Q&#39;, &#39;R&#39;,
                &#39;S&#39;, &#39;T&#39;, &#39;U&#39;, &#39;V&#39;, &#39;W&#39;, &#39;X&#39;, &#39;Y&#39;, &#39;Z&#39;]
    id = db_add(lurl)
    value_62 = base62(id)
    surl = []
    for i in value_62:
        surl.append(charlist[i])
    surl = &#39;&#39;.join(surl)
    db_save(id, surl)
    return surl
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在实际应用中还要再考虑2个问题，62个字符的顺序以及用什么数据库来存储url。&lt;/p&gt;

&lt;p&gt;打乱62个字符的顺序可以用洗牌算法，思路如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;生成一个1到62之间的随机数，将1和这个随机数位置的字符调换位置&lt;/li&gt;
&lt;li&gt;生成一个2到62之间的随机数，将2和这个随机数位置的字符调换位置&lt;/li&gt;
&lt;li&gt;以此类推，第i次时，生成一个i到62的随机数，调换位置&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def shuffle(n):
    sl = []
    for i in range(n):
        sl.append(i)

    for i in range(n):
        rn = randint(i, n-1)
        sl[i], sl[rn] = sl[rn], sl[i]

    return sl
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;至于用什么数据库，个人推荐TTserver(Tokyo Cabinet)，它是一款 DBM 数据库，该数据库读写非常快，哈希模式写入100万条数据只需0.643秒，读取100万条数据只需0.773秒，是 Berkeley DB 等 DBM 的几倍。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>