<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Sung Yung</title>
    <link>/post/index.xml</link>
    <description>Recent content in Posts on Sung Yung</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 03 Jun 2016 19:10:15 +0800</lastBuildDate>
    <atom:link href="/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Python Week 0001 --- property</title>
      <link>/post/python-property/</link>
      <pubDate>Fri, 03 Jun 2016 19:10:15 +0800</pubDate>
      
      <guid>/post/python-property/</guid>
      <description>&lt;p&gt;博客搭了有好久了，都是断断续续的写，甚至大半年没有新的内容。已经掌握的或者是新学习的，没有记录一旦长时间不用就会忘掉，毕竟还没有形成本能。所以还是想记录一些东西吧。哈哈，其实还有个原因就是写了没人看哈，然后就没动力了。&lt;/p&gt;

&lt;p&gt;这个系列打算一周更新一篇。定位就是内容不一定多，尽量把东西讲清楚吧，按照为什么-是什么-怎么用的进行描述。&lt;/p&gt;

&lt;p&gt;那我们就开始吧，这篇主要是关于property。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;问题引出&#34;&gt;问题引出&lt;/h3&gt;

&lt;p&gt;我们一般对属性的的操作主要有2个，访问和修改。看个例子。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Person(object):
    def __init__(self, name):
        self.name = name

p = Person(&#39;Jack&#39;)
print p.name
p.name = &#39;Rose&#39;
print p.name

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们叫这种使用属性的方式叫点模式（我自己取得。。。），那么问题来了，如果我们想要修改属性的时候加入一个简单的类型检查，应该怎么做？&lt;/p&gt;

&lt;p&gt;很容易想到新增一个辅助方法来达成目标。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Person(object):
    def __init__(self, name):
        self.name = name
    
    def set_name(self, value):
        if not isinstance(value, str):
            raise TypeError(&#39;Expected a string&#39;)
        self.name = value
        
p = Person(&#39;Jack&#39;)
p.set_name(&#39;Rose&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们也看到了，这种方法虽然可以实现功能，但是使用起来不是很方便。所以我们会想有没有一种方法可以做到使用点模式的时候也能够做类型检查。&lt;/p&gt;

&lt;h3 id=&#34;解决方法&#34;&gt;解决方法&lt;/h3&gt;

&lt;p&gt;我们可以使用内置的property装饰器来实现。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Person(object):

    def __init__(self, name):
        self._name = name

    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, value):
        if not isinstance(value, basestring):
            raise TypeError(&#39;Expected a string&#39;)
        self._name = value

    @name.deleter
    def name(self):
        del self._name
        
p = Person(&#39;Jack&#39;)
p.name = &#39;Rose&#39;
p.name = 222
del p.name
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
&amp;lt;ipython-input-4-40579c6671bf&amp;gt; in &amp;lt;module&amp;gt;()
      1 p = Person(&#39;Jack&#39;)
      2 p.name = &#39;Rose&#39;
----&amp;gt; 3 p.name = 222

&amp;lt;ipython-input-3-335cb8c0ab8b&amp;gt; in name(self, value)
     14     def name(self, value):
     15         if not isinstance(value, str):
---&amp;gt; 16             raise TypeError(&#39;Expected a string&#39;)
     17         self._name = value
     18 

TypeError: Expected a string
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用起来真是so easy啊。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;虽然对外访问是name属性，但是内部有个实际存放值的属性_name。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;另外还有一种用法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Person(object):

    def __init__(self, name):
        self._name = name

    def get_name(self):
        return self._name

    def set_name(self, value):
        if not isinstance(value, str):
            raise TypeError(&#39;Expected a string&#39;)
        self._name = value

    def del_name(self):
        del self._name

    name = property(get_name, set_name, del_name)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们看看官方的代码注释，一目了然。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;quot;&amp;quot;&amp;quot;
property(fget=None, fset=None, fdel=None, doc=None) -&amp;gt; property attribute
        
fget is a function to be used for getting an attribute value, and likewise
fset is a function for setting, and fdel a function for del&#39;ing, an
attribute.  Typical use is to define a managed attribute x:
        
class C(object):
    def getx(self): return self._x
    def setx(self, value): self._x = value
    def delx(self): del self._x
    x = property(getx, setx, delx, &amp;quot;I&#39;m the &#39;x&#39; property.&amp;quot;)
        
Decorators make defining new properties or modifying existing ones easy:
        
class C(object):
    @property
    def x(self):
        &amp;quot;I am the &#39;x&#39; property.&amp;quot;
        return self._x
    @x.setter
    def x(self, value):
        self._x = value
    @x.deleter
    def x(self):
        del self._x
&amp;quot;&amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以后当我们遇到设置属性的时候需要额外逻辑的时候，就可以考虑使用property了。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Openstack Swift tempurl 和 largeobject 支持</title>
      <link>/post/swift-tempurl/</link>
      <pubDate>Mon, 04 Jan 2016 19:07:44 +0800</pubDate>
      
      <guid>/post/swift-tempurl/</guid>
      <description>&lt;h2 id=&#34;tempurl&#34;&gt;Tempurl&lt;/h2&gt;

&lt;p&gt;在使用网盘时，我们有时会把文件共享给没有账户权限的人，这时候就需要tempurl中间件的支持。tempurl中间件可以生成一个有时限的GET链接，其他人只需要这个链接就可以进行下载。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h4 id=&#34;url格式&#34;&gt;URL格式&lt;/h4&gt;

&lt;p&gt;我们先看下面的例子(偷懒了，这是官方提供的)：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;https://swift-cluster.example.com/v1/my_account/container/object
?temp_url_sig=da39a3ee5e6b4b0d3255bfef95601890afd80709
&amp;amp;temp_url_expires=1323479485
&amp;amp;filename=My+Test+File.pdf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个URL包括了下面几个部分：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;对象路径&lt;/li&gt;
&lt;li&gt;temp_url_sig，用HMAC-SHA1生成的签名，使用HTTP方法、过期时间、对象路径和一个秘钥生成&lt;/li&gt;
&lt;li&gt;temp_url_expires，过期时间&lt;/li&gt;
&lt;li&gt;文件名，这是可选的，覆盖默认的对象名&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;秘钥&#34;&gt;秘钥&lt;/h4&gt;

&lt;p&gt;秘钥主要指的是账户和容器的一个秘钥属性。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;账户：
X-Account-Meta-Temp-URL-Key
X-Account-Meta-Temp-URL-Key-2

容器：
X-Container-Meta-Temp-URL-Key
X-Container-Meta-Temp-URL-Key-2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过如下方式设置：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;账户：
swift post -m &amp;quot;Temp-URL-Key:MYKEY&amp;quot;

容器：
swift post container -m &amp;quot;Temp-URL-Key:MYKEY&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;hmac-sha1签名&#34;&gt;HMAC-SHA1签名&lt;/h4&gt;

&lt;p&gt;同样，先给例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import hmac
from hashlib import sha1
from time import time
method = &#39;GET&#39;
duration_in_seconds = 60*60*24
expires = int(time() + duration_in_seconds)
path = &#39;/v1/my_account/container/object&#39;
key = &#39;MYKEY&#39;
hmac_body = &#39;%s\n%s\n%s&#39; % (method, expires, path)
signature = hmac.new(key, hmac_body, sha1).hexdigest()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;method也可以是PUT方法。&lt;/p&gt;

&lt;h4 id=&#34;swift-tempurl命令&#34;&gt;swift tempurl命令&lt;/h4&gt;

&lt;p&gt;先看例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;swift tempurl GET 3600 /v1/my_account/container/object MYKEY
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;help信息：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;Generates a temporary URL for a Swift object.

Positional arguments:
  &amp;lt;method&amp;gt;              An HTTP method to allow for this temporary URL.
                        Usually &#39;GET&#39; or &#39;PUT&#39;.
  &amp;lt;seconds&amp;gt;             The amount of time in seconds the temporary URL will be
                        valid for; or, if --absolute is passed, the Unix
                        timestamp when the temporary URL will expire.
  &amp;lt;path&amp;gt;                The full path to the Swift object. Example:
                        /v1/AUTH_account/c/o.
  &amp;lt;key&amp;gt;                 The secret temporary URL key set on the Swift cluster.
                        To set a key, run &#39;swift post -m
                        &amp;quot;Temp-URL-Key:b3968d0207b54ece87cccc06515a89d4&amp;quot;&#39;

Optional arguments:
  --absolute            Interpet the &amp;lt;seconds&amp;gt; positional argument as a Unix
                        timestamp rather than a number of seconds in the
                        future.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;static-large-object&#34;&gt;Static Large object&lt;/h2&gt;

&lt;p&gt;manifest文件，分片按顺序存&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[
    {
        &amp;quot;path&amp;quot;: &amp;quot;mycontainer/objseg1&amp;quot;,
        &amp;quot;etag&amp;quot;: &amp;quot;0228c7926b8b642dfb29554cd1f00963&amp;quot;,
        &amp;quot;size_bytes&amp;quot;: 1468006
    },
    {
        &amp;quot;path&amp;quot;: &amp;quot;mycontainer/pseudodir/seg-obj2&amp;quot;,
        &amp;quot;etag&amp;quot;: &amp;quot;5bfc9ea51a00b790717eeb934fb77b9b&amp;quot;,
        &amp;quot;size_bytes&amp;quot;: 1572864
    },
    {
        &amp;quot;path&amp;quot;: &amp;quot;other-container/seg-final&amp;quot;,
        &amp;quot;etag&amp;quot;: &amp;quot;b9c3da507d2557c1ddc51f27c54bae51&amp;quot;,
        &amp;quot;size_bytes&amp;quot;: 256
    }
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将manifest上传，添加?multipart-manifest=put。上传完成后，X-Static-Large-Object为true。&lt;/p&gt;

&lt;p&gt;下载正常。&lt;/p&gt;

&lt;p&gt;删除要删除分片的话需要?multipart-manifest=delete&lt;/p&gt;

&lt;p&gt;COPY时候?multipart-manifest=get只拷贝manifest。&lt;/p&gt;

&lt;p&gt;断点续传：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http://192.168.99.100:8080/v1/AUTH_a5b3c5a9f5354e4da74e9d0af7b849a9/test?prefix=ss&amp;amp;format=json
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Pythons HOWTO之属性描述符</title>
      <link>/post/python-howto-descriptor/</link>
      <pubDate>Sat, 08 Aug 2015 22:27:41 +0800</pubDate>
      
      <guid>/post/python-howto-descriptor/</guid>
      <description>&lt;p&gt;今天开个新坑，Pythons HOWTOS系列，主要是对官方文档的翻译。由于英语水平有限，基本上都是意译。这里附上&lt;a href=&#34;https://docs.python.org/2.7/howto/index.html&#34;&gt;链接&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;本篇是第一篇，主要说的是&lt;a href=&#34;https://docs.python.org/2.7/howto/descriptor.html#id2&#34;&gt;属性描述符&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;摘要&#34;&gt;摘要&lt;/h2&gt;

&lt;p&gt;本篇的内容主要是定义属性描述符(descriptor)，概述一下描述符协议的内容。通过自定义的的一个描述符和Python内建的描述符(functions, properties, static methods, class methods)来演示属性描述符是如何调用的。同时会给出相同功能的Python实现代码和一个简单的程序。&lt;/p&gt;

&lt;p&gt;属性描述符不仅给一个大的工具集(暂时没发现是什么)提供了接口，它还能加深理解Python的工作原理和优雅的设计思想。&lt;/p&gt;

&lt;h2 id=&#34;定义和介绍&#34;&gt;定义和介绍&lt;/h2&gt;

&lt;p&gt;一般来说，一个描述符是一个有“绑定行为”的对象属性，这个属性访问被描述符协议中的方法所覆盖。这些方法是__get__()，__set__()和__delete__()。如果某个对象定义了其中一个，那么这个对象就可以被叫做描述符。&lt;/p&gt;

&lt;p&gt;访问属性默认通过get，set或者是delete来操作对象属性字典来实现。例如，a.x有一个查找队列，从a.__dict__[&amp;lsquo;x&amp;rsquo;]开始，然后是type(a).__dict__[&amp;lsquo;x&amp;rsquo;]，接着是type(a)的基类(metaclass除外)，以此类推。如果查找的是一个定义了描述符方法的对象，那么Python会覆盖默认行为而去调用描述符方法。发生在优先级队列的哪个位置取决于定义的描述符方法。注意，属性描述符只适用于新式类(从object或者typ继承的类)。&lt;/p&gt;

&lt;p&gt;属性描述符是一个强大的通用协议。它是properties, methods, static methods, class methods 和super()的调用原理。它贯穿整个Python，并且用来实现2.2版本中引进的新式类。属性描述符简化了底层的C代码，还为日常Python编程提供了新的工具集。&lt;/p&gt;

&lt;h2 id=&#34;描述符协议&#34;&gt;描述符协议&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;descr.__get__(self, obj, type=None) --&amp;gt; value

descr.__set__(self, obj, value) --&amp;gt; None

descr.__delete__(self, obj) --&amp;gt; None
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的三个方法就是协议的全部内容了。定义其中任意一个方法的对象就被称为属性描述符，能够覆盖默认的属性查找规则。&lt;/p&gt;

&lt;p&gt;如果一个对象同时定义了__get__和__set__方法，它被称做数据描述符(data descriptor)。只定义__get__方法的对象则被称为非数据描述符(non-data descriptor，一般用在函数方法上，其他用法也是可能的)。&lt;/p&gt;

&lt;p&gt;数据和非数据描述符的区别在于如果某个实例属性字典中有项和描述符同名，那么属性访问的优先级是不同的。数据描述符的优先级比实例字典中项的高，非数据描述符则相反。&lt;/p&gt;

&lt;p&gt;举个例子说明一下优先级问题:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class DataDesc(object):

    def __init__(self, name=None):
        self.name = name
        self.value = None

    def __get__(self, obj, type=None):
        return self.value

    def __set__(self, obj, value):
        self.value = value


class NonDataDesc(object):

    def __init__(self, name=None):
        self.name = name
        self.value = None

    def __get__(self, obj, type=None):
        return self.value


class DataTest(object):
    x = DataDesc()


class NonDataTest(object):
    x = NonDataDesc()

&amp;gt;&amp;gt;&amp;gt; d = DataTest()
&amp;gt;&amp;gt;&amp;gt; nd = NonDataTest()
&amp;gt;&amp;gt;&amp;gt; d.__dict__[&#39;x&#39;] = 2
&amp;gt;&amp;gt;&amp;gt; nd.__dict__[&#39;x&#39;] = 2
&amp;gt;&amp;gt;&amp;gt; print d.__dict__, nd.__dict__
{&#39;x&#39;: 2} {&#39;x&#39;: 2}
&amp;gt;&amp;gt;&amp;gt; print d.x, nd.x
None 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果想要构造一个只读的数据描述符，同时定义__get__和__set__方法，并且__set__调用时引发一个AtrributeError异常。&lt;/p&gt;

&lt;h2 id=&#34;属性描述符调用&#34;&gt;属性描述符调用&lt;/h2&gt;

&lt;p&gt;一个属性描述符可以通过它的方法名直接调用。比如，d.__get__(obj)。更常见的方式是通过属性访问自动调用。比如，obj.d在obj的字典中查找d。如果d定义了__get__()，那么根据下文将要提到的优先级规则，d.__get__(obj)将会被调用。&lt;/p&gt;

&lt;p&gt;调用的细节由obj是对象还是类来决定。&lt;/p&gt;

&lt;p&gt;对于对象，访问是调用object.__getattribute__()，其中将b.x转换成type(b).__dict__[&amp;lsquo;x&amp;rsquo;].__get__(b, type(b))。在实现中，数据描述符优先级最高，依次是实例变量，非数据描述符，最后是__getattr__()(如果定义了)。C实现能够在&lt;a href=&#34;https://hg.python.org/cpython/file/2.7/Objects/object.c&#34;&gt;Objects/object.c&lt;/a&gt;中的&lt;a href=&#34;https://docs.python.org/2.7/c-api/object.html#c.PyObject_GenericGetAttr&#34;&gt;PyObject_GenericGetAttr()&lt;/a&gt;找到。&lt;/p&gt;

&lt;p&gt;对于类，访问是调用type.__getattribute__()，其中将B.x转换成B.__[&amp;lsquo;x&amp;rsquo;].__get__(None, B)。如果用Python实现，它是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def __getattribute__(self, key):
    &amp;quot;Emulate type_getattro() in Objects/typeobject.c&amp;quot;
    v = object.__getattribute__(self, key)
    if hasattr(v, &#39;__get__&#39;):
       return v.__get__(None, self)
    return v
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要记住下面几个重要的点:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;描述符通过__getattribute__()被调用&lt;/li&gt;
&lt;li&gt;重写__getattribute__()能够改变自动的调用&lt;/li&gt;
&lt;li&gt;__getattribute__()只适用于新式类&lt;/li&gt;
&lt;li&gt;object.__getattribute__()和type.__getattribute__()调用__get__()的方式不同&lt;/li&gt;
&lt;li&gt;数据描述符总是覆盖实例字典&lt;/li&gt;
&lt;li&gt;非数据描述符可能被实例字典覆盖&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;super()返回的对象有一个自定义的__getattribute__()。调用super(B, obj).m()在obj.__class__.__mro__查找到紧跟在B后面的基类A，然后返回A.__dict__[&amp;rsquo;m&amp;rsquo;].__get__(obj, B)。如果不是一个描述符，m被原封不动的返回。如果不在字典中，m转而去调用object.__getattribute__()查找。&lt;/p&gt;

&lt;p&gt;注意，在Python2.2中，运行super(B, obj).m()时，如果m是一个数据描述符，将会只调用__get__()。在Python2.3中，除了是旧式类，非数据描述符也会得到调用。具体实现在&lt;a href=&#34;https://hg.python.org/cpython/file/2.7/Objects/typeobject.c&#34;&gt;Objects/typeobject.c&lt;/a&gt;的super_getattro()中。&lt;/p&gt;

&lt;p&gt;综上所述，描述符机制嵌入到了object、type和super()的__getattribute__()方法中。如果类需要这个机制，必须继承自object或者是有metaclass提供类似的功能。同样的，也可以通过重写__getattribute__()来改变属性描述符。&lt;/p&gt;

&lt;h2 id=&#34;属性描述符示例&#34;&gt;属性描述符示例&lt;/h2&gt;

&lt;p&gt;下面的代码创建了一个类，它的实例对象是数据描述符，get和set方法中都打印了一条信息。重写__getattribute__()方法也可以做到这个。但是，使用描述符对监控一些属性很有用：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class RevealAccess(object):
    &amp;quot;&amp;quot;&amp;quot;A data descriptor that sets and returns values
       normally and prints a message logging their access.
    &amp;quot;&amp;quot;&amp;quot;

    def __init__(self, initval=None, name=&#39;var&#39;):
        self.val = initval
        self.name = name

    def __get__(self, obj, objtype):
        print &#39;Retrieving&#39;, self.name
        return self.val

    def __set__(self, obj, val):
        print &#39;Updating&#39;, self.name
        self.val = val

&amp;gt;&amp;gt;&amp;gt; class MyClass(object):
    x = RevealAccess(10, &#39;var &amp;quot;x&amp;quot;&#39;)
    y = 5

&amp;gt;&amp;gt;&amp;gt; m = MyClass()
&amp;gt;&amp;gt;&amp;gt; m.x
Retrieving var &amp;quot;x&amp;quot;
10
&amp;gt;&amp;gt;&amp;gt; m.x = 20
Updating var &amp;quot;x&amp;quot;
&amp;gt;&amp;gt;&amp;gt; m.x
Retrieving var &amp;quot;x&amp;quot;
20
&amp;gt;&amp;gt;&amp;gt; m.y
5
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;properties&#34;&gt;Properties&lt;/h2&gt;

&lt;p&gt;使用property()能够把数据描述符变成属性调用。形式如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;property(fget=None, fset=None, fdel=None, doc=None) -&amp;gt; property attribute
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一个典型的用法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class C(object):
    def getx(self): return self.__x
    def setx(self, value): self.__x = value
    def delx(self): del self.__x
    x = property(getx, setx, delx, &amp;quot;I&#39;m the &#39;x&#39; property.&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以使用装饰器:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class C(object):
  @property
  def x(self):
    return self.__x

  @x.setter
  def setx(self, value):
    self.__x = value

  @x.deleter
  del delx(self):
    self.__x

&amp;gt;&amp;gt;&amp;gt; c = C()
&amp;gt;&amp;gt;&amp;gt; c.x = 2
&amp;gt;&amp;gt;&amp;gt; c.x
2
&amp;gt;&amp;gt;&amp;gt; del c.x
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;proptery()是C实现的，我们这里给出Python版本的等价实现：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Property(object):
    &amp;quot;Emulate PyProperty_Type() in Objects/descrobject.c&amp;quot;

    def __init__(self, fget=None, fset=None, fdel=None, doc=None):
        self.fget = fget
        self.fset = fset
        self.fdel = fdel
        if doc is None and fget is not None:
            doc = fget.__doc__
        self.__doc__ = doc

    def __get__(self, obj, objtype=None):
        if obj is None:
            return self
        if self.fget is None:
            raise AttributeError(&amp;quot;unreadable attribute&amp;quot;)
        return self.fget(obj)

    def __set__(self, obj, value):
        if self.fset is None:
            raise AttributeError(&amp;quot;can&#39;t set attribute&amp;quot;)
        self.fset(obj, value)

    def __delete__(self, obj):
        if self.fdel is None:
            raise AttributeError(&amp;quot;can&#39;t delete attribute&amp;quot;)
        self.fdel(obj)

    def getter(self, fget):
        return type(self)(fget, self.fset, self.fdel, self.__doc__)

    def setter(self, fset):
        return type(self)(self.fget, fset, self.fdel, self.__doc__)

    def deleter(self, fdel):
        return type(self)(self.fget, self.fset, fdel, self.__doc__)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一个电子表格类可能通过Cell(&amp;lsquo;b10&amp;rsquo;).value访问某个单元，后面希望改进成每次访问都重新计算。但是开发者不想直接改变现有的属性访问代码。那么便可以用proptery数据描述符封装属性访问。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Cell(object):
    . . .
    def getvalue(self, obj):
        &amp;quot;Recalculate cell before returning value&amp;quot;
        self.recalc()
        return obj._value
    value = property(getvalue)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;functions-and-methods&#34;&gt;Functions and methods&lt;/h2&gt;

&lt;p&gt;Python的面向对象特征是建立在基于函数的环境上。使用非数据描述符，两者能够无缝融合。&lt;/p&gt;

&lt;p&gt;类字典中用函数(function)形式存储方法(method)。在类的定义中，用def和lambda定义方法，这也是定义函数的方式。方法和普通函数唯一的区别是方法的第一个参数预留给了对象实例。按照Python的惯例，实例引用一般用self表示，当然也有可能用this或者其他变量表示。&lt;/p&gt;

&lt;p&gt;为了支持方法调用，函数中包含了__get__()属性。这意味着，所有的函数都是非数据描述符。对象和类的方法，__get__()返回值是不同的，分别绑定(bound)和非绑定(unbound)方法。如果用纯Python表示，可能是这样的:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Function(object):
    . . .
    def __get__(self, obj, objtype=None):
        &amp;quot;Simulate func_descr_get() in Objects/funcobject.c&amp;quot;
        return types.MethodType(self, obj, objtype)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; class D(object):
     def f(self, x):
          return x

&amp;gt;&amp;gt;&amp;gt; d = D()
&amp;gt;&amp;gt;&amp;gt; D.__dict__[&#39;f&#39;] # Stored internally as a function
&amp;lt;function f at 0x00C45070&amp;gt;
&amp;gt;&amp;gt;&amp;gt; D.f             # Get from a class becomes an unbound method
&amp;lt;unbound method D.f&amp;gt;
&amp;gt;&amp;gt;&amp;gt; d.f             # Get from an instance becomes a bound method
&amp;lt;bound method D.f of &amp;lt;__main__.D object at 0x00B18C90&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;bound和unbound方法是两个不同的类型。C实现中只是一个相同的对象的两种不同表现，区别就在于im_self被设置了或者是NULL值，具体实现位于&lt;a href=&#34;https://hg.python.org/cpython/file/2.7/Objects/classobject.c&#34;&gt;Objects/classobject.c&lt;/a&gt;中&lt;a href=&#34;https://docs.python.org/2.7/c-api/method.html#c.PyMethod_Type&#34;&gt;PyMethod_Type&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;同样地，调用方法时有没有im_self效果是不同的。如果被设置了，表明是bound方法，原始函数(存在im_func中)被调用，当然第一个参数被设置成对象实例。如果是unbound方法，所有参数原封不动地传给原始函数。C实现instancemethod_call()会更加复杂，因为有很多类型检测。&lt;/p&gt;

&lt;h2 id=&#34;static-methods-and-class-methods&#34;&gt;Static methods and class methods&lt;/h2&gt;

&lt;p&gt;函数有__get__()属性，所以当它们被当成属性访问时会被转变成方法。非数据描述符将obj.f(*args)转换成了f(obj, *args)。调用klass.f(*args)变成了f(*args)。&lt;/p&gt;

&lt;p&gt;下面这个表格总结了这转变方式，以及两个变种staticmethod和classmethod。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Transformation&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Called from an Object&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Called from a Class&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;function&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;f(obj, *args)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;f(*args)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;staticmethod&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;f(*args)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;f(*args)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;classmethod&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;f(type(obj), *args)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;f(klass, *args)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;静态方法没有对函数做任何改变。调用c.f等价于object.__getattribute__(c, &amp;ldquo;f&amp;rdquo;)，调C.f等于object.__getattribute__(C, &amp;ldquo;f&amp;rdquo;)。所以，对象和类对静态方法的调用方式是统一的。静态方法不需要self。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; class E(object):
     def f(x):
          print x
     f = staticmethod(f)

&amp;gt;&amp;gt;&amp;gt; print E.f(3)
3
&amp;gt;&amp;gt;&amp;gt; print E().f(3)
3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;纯Pythond的staticmethod()实现可能是这样的:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class StaticMethod(object):
 &amp;quot;Emulate PyStaticMethod_Type() in Objects/funcobject.c&amp;quot;

 def __init__(self, f):
      self.f = f

 def __get__(self, obj, objtype=None):
      return self.f
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而类方法的第一个参数是类的引用。也是分为对象调用和类调用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; class E(object):
     def f(klass, x):
          return klass.__name__, x
     f = classmethod(f)

&amp;gt;&amp;gt;&amp;gt; print E.f(3)
(&#39;E&#39;, 3)
&amp;gt;&amp;gt;&amp;gt; print E().f(3)
(&#39;E&#39;, 3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果函数只需要类引用而不关心底层的数据，那么类方法就会很有用。一个使用classmethod的例子是创建类构造器。在Python2.3中dict.fromkeys()从关键字列表中创建一个新的字典。纯Python可能是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Dict(object):
    . . .
    def fromkeys(klass, iterable, value=None):
        &amp;quot;Emulate dict_fromkeys() in Objects/dictobject.c&amp;quot;
        d = klass()
        for key in iterable:
            d[key] = value
        return d
    fromkeys = classmethod(fromkeys)

&amp;gt;&amp;gt;&amp;gt; Dict.fromkeys(&#39;abracadabra&#39;)
{&#39;a&#39;: None, &#39;r&#39;: None, &#39;b&#39;: None, &#39;c&#39;: None, &#39;d&#39;: None}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;classmethod的纯Python实现可能是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class ClassMethod(object):
     &amp;quot;Emulate PyClassMethod_Type() in Objects/funcobject.c&amp;quot;

     def __init__(self, f):
          self.f = f

     def __get__(self, obj, klass=None):
          if klass is None:
               klass = type(obj)
          def newfunc(*args):
               return self.f(klass, *args)
          return newfunc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;终于结束了，这篇断断续续的翻译了好几天，几次都想放弃了，但还是忍着翻译了下来，算是收获了许多。学习是没有捷径的。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Python装饰器的几种类型</title>
      <link>/post/python-decorate/</link>
      <pubDate>Mon, 27 Jul 2015 22:25:34 +0800</pubDate>
      
      <guid>/post/python-decorate/</guid>
      <description>&lt;p&gt;装饰器的原理就是闭包，这在&lt;a href=&#34;/post/python-bibao/&#34;&gt;前面&lt;/a&gt;已经提到过了。本篇主要记录一下装饰器的几种类型。&lt;/p&gt;

&lt;h2 id=&#34;无参数装饰器&#34;&gt;无参数装饰器&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def deco(func):
    def _deco(*args, **kwargs):
        print &#39;call deco&#39;
        func(*args, **kwargs)
    return _deco

@deco
def test():
    print &#39;call test&#39;

# 等同于
def test():
    print &#39;call test&#39;
test = deco(func)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;有参数装饰器&#34;&gt;有参数装饰器&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def deco(*args, **kwargs):
    def _deco(func):
        print args, kwargs
        def __deco(*args, **kwargs):
            print &#39;call deco&#39;
            func(*args, **kwargs)
        return __deco
    return _deco

@deco(&#39;hello&#39;, x=&#39;nihao&#39;)
def test():
    print &#39;call test&#39;

# 等同于
def test():
    print &#39;call test&#39;
test = deco(&#39;hello&#39;, x=&#39;nihao&#39;)(test)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;类装饰器&#34;&gt;类装饰器&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def deco(*args, **kwargs):
    def _deco(cls):
        cls.x = 12
        return cls
    return _deco

@deco(&#39;hello&#39;)
class A(object):
    pass

&amp;gt;&amp;gt;&amp;gt; A.x
12

# 等同于
class A(object):
    pass
A = deco(&#39;hello&#39;)(A)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;装饰器类&#34;&gt;装饰器类&lt;/h2&gt;

&lt;p&gt;类作为装饰器，分为有参数和无参数。同时，需要装饰的是类方法时，需要用到&lt;strong&gt;get&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&#34;无参数&#34;&gt;无参数&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Deco(object):
    def __init__(self, func):
        self.func = func

    def __call__(self, *args, **kwargs):
        print &#39;call Deco&#39;
        self.func(*args, **kwargs)

@Deco
def test():
    print &#39;call test&#39;

# 等同于
test = Deco(test)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;有参数&#34;&gt;有参数&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Deco(object):
    def __init__(self, *args, **kwargs):
        print args, kwargs

    def __call__(self, func):
        def _deco(*args, **kwargs):
            print &#39;call Deco&#39;
            func(*args, **kwargs)
        return _deco

@Deco(&#39;hello&#39;)
def test():
    print &#39;call test&#39;

# 等同于
test = Deco(&#39;hello&#39;)(func)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;装饰类方法&#34;&gt;装饰类方法&lt;/h3&gt;

&lt;h4 id=&#34;无参数-1&#34;&gt;无参数&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Deco(object):
    def __init__(self, func):
        self.func = func

    def __get__(self, instance, owner):
        def _deco(*args, **kwargs):
            print &#39;call Deco&#39;
            self.func(instance, *args, **kwargs)
        return _deco

class A(object):
    @Deco
    def test(self):
        print &#39;call test&#39;

# 等同于
class A(object):

    def test(self):
        print &#39;call test&#39;
    test = Deco(test)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;有参数-1&#34;&gt;有参数&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Deco(object):
    def __init__(self, *args, **kwargs):
        print args, kwargs

    def __get__(self, instance, owner):
        def _deco(*args, **kwargs):
            print &#39;call Deco&#39;
            self.func(instance, *args, **kwargs)
        return _deco

    def __call__(self, func):
        self.func = func
        return self

class A(object):

    @Deco(&#39;hello&#39;)
    def test(self):
        print &#39;call test&#39;

# 等同于
class A(object):

    def test(self):
        print &#39;call test&#39;
    test = Deco(&#39;hello&#39;)(test)
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Python闭包的作用域理解</title>
      <link>/post/python-bibao/</link>
      <pubDate>Wed, 22 Jul 2015 22:23:31 +0800</pubDate>
      
      <guid>/post/python-bibao/</guid>
      <description>&lt;h2 id=&#34;什么是闭包&#34;&gt;什么是闭包&lt;/h2&gt;

&lt;p&gt;在维基中，闭包的解释是这样的：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;在计算机科学中，闭包（Closure）是词法闭包（Lexical Closure）的简称，是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。所以，有另一种说法认为闭包是由函数和与其相关的引用环境组合而成的实体。闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;我们来看一个简单的实例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def outer(arg):
    def inner():
        print arg * arg
    return inner

&amp;gt;&amp;gt;&amp;gt; f = outer(2)
&amp;gt;&amp;gt;&amp;gt; f()
4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;内部函数inner调用外部函数outer的局部变量arg，它保存了outer的arg值。这就是闭包。&lt;/p&gt;

&lt;h2 id=&#34;从作用域的角度理解&#34;&gt;从作用域的角度理解&lt;/h2&gt;

&lt;p&gt;把上面的例子改一下，在函数内部输出局部命名空间:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def outer(arg):
    print locals()
    def inner():
        x = arg * arg
        print locals()
        print x
    return inner

&amp;gt;&amp;gt;&amp;gt; f = outer(2)
{&#39;arg&#39;: 2}
&amp;gt;&amp;gt;&amp;gt; f()
{&#39;x&#39;: 4, &#39;arg&#39;: 2}
4
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在outer中，局部命名空间只有一个键arg，而在inner内部也有arg。上面说的inner保存了outer的arg值，我们就可以理解为inner的局部命名空间保存了arg。&lt;/p&gt;

&lt;p&gt;这么一理解，就会发现闭包其实就这么简单。&lt;/p&gt;

&lt;p&gt;另外再瞎扯一句，python中的装饰器其实就是闭包。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Twisted源码分析系列01-reactor</title>
      <link>/post/python-twisted01/</link>
      <pubDate>Tue, 14 Jul 2015 22:22:03 +0800</pubDate>
      
      <guid>/post/python-twisted01/</guid>
      <description>&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;

&lt;p&gt;Twisted是用Python实现的事件驱动的网络框架。&lt;/p&gt;

&lt;p&gt;如果想看教程的话，我觉得写得最好的就是&lt;a href=&#34;http://krondo.com/?page_id=1327&#34;&gt;Twisted Introduction&lt;/a&gt;了，这是&lt;a href=&#34;https://github.com/syfun/twisted-intro-cn&#34;&gt;翻译&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;下面就直接进入主题了。&lt;/p&gt;

&lt;p&gt;我们通过一个示例开始分析源码，那么先看下面这个示例。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python
# coding=utf8

from twisted.internet.protocol import Protocol, ServerFactory


HOST = &#39;127.0.0.1&#39;
PORT = 8080


class EchoProtocol(Protocol):

    def dataReceived(self, data):
        self.transport.write(data)


if __name__ == &#39;__main__&#39;:
    factory = ServerFactory()
    factory.protocol = EchoProtocol

    from twisted.internet import reactor
    reactor.listenTCP(PORT, factory, interface=HOST)
    reactor.run()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是一个非常简单的Echo server，每当有数据发来，都会将数据往回发。&lt;/p&gt;

&lt;h2 id=&#34;reactor&#34;&gt;reactor&lt;/h2&gt;

&lt;p&gt;reactor是事件管理器，用于注册、注销事件，运行事件循环，当事件发生时调用回调函数处理。关于reactor有下面几个结论:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Twisted的reactor只有通过调用reactor.run()来启动。&lt;/li&gt;
&lt;li&gt;reactor循环是在其开始的进程中运行，也就是运行在主进程中。&lt;/li&gt;
&lt;li&gt;一旦启动，就会一直运行下去。reactor就会在程序的控制下（或者具体在一个启动它的线程的控制下）。&lt;/li&gt;
&lt;li&gt;reactor循环并不会消耗任何CPU的资源。&lt;/li&gt;
&lt;li&gt;并不需要显式的创建reactor，只需要引入就OK了。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最后一条需要解释清楚。在Twisted中，reactor是Singleton（也就是单例模式），即在一个程序中只能有一个reactor，并且只要你引入它就相应地创建一个。上面引入的方式这是twisted默认使用的方法，当然了，twisted还有其它可以引入reactor的方法。例如，可以使用twisted.internet.pollreactor中的系统调用来poll来代替select方法。
若使用其它的reactor，需要在引入twisted.internet.reactor前安装它。下面是安装pollreactor的方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from twisted.internet import pollreactor
pollreactor.install()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你没有安装其它特殊的reactor而引入了twisted.internet.reactor，那么Twisted会根据操作系统安装默认的reactor。正因为如此，习惯性做法不要在最顶层的模块内引入reactor以避免安装默认reactor，而是在你要使用reactor的区域内安装。
下面是使用 pollreactor重写上上面的程序:tho&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from twited.internet import pollreactor
pollreactor.install()
from twisted.internet import reactor
reactor.run()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么reactor是如何实现单例的？来看一下from twisted.internet import reactor做了哪些事情就并明白了。&lt;/p&gt;

&lt;p&gt;下面是twisted/internet/reactor.py的部分代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# twisted/internet/reactor.py
import sys
del sys.modules[&#39;twisted.internet.reactor&#39;]
from twisted.internet import default
default.install()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注：Python中所有加载到内存的模块都放在sys.modules，它是一个全局字典。当import一个模块时首先会在这个列表中查找是否已经加载了此模块，如果加载了则只是将模块的名字加入到正在调用import的模块的命名空间中。如果没有加载则从sys.path目录中按照模块名称查找模块文件，找到后将模块载入内存，并加入到sys.modules中，并将名称导入到当前的命名空间中。&lt;/p&gt;

&lt;p&gt;假如我们是第一次运行from twisted.internet import reactor，因为sys.modules中还没有twisted.internet.reactor，所以会运行reactory.py中的代码，安装默认的reactor。之后，如果导入的话，因为sys.modules中已存在该模块，所以会直接将sys.modules中的twisted.internet.reactor导入到当前命名空间。&lt;/p&gt;

&lt;p&gt;default中的install：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# twisted/internet/default.py
def _getInstallFunction(platform):
    &amp;quot;&amp;quot;&amp;quot;
    Return a function to install the reactor most suited for the given platform.

    @param platform: The platform for which to select a reactor.
    @type platform: L{twisted.python.runtime.Platform}

    @return: A zero-argument callable which will install the selected
        reactor.
    &amp;quot;&amp;quot;&amp;quot;
    try:
        if platform.isLinux():
            try:
                from twisted.internet.epollreactor import install
            except ImportError:
                from twisted.internet.pollreactor import install
        elif platform.getType() == &#39;posix&#39; and not platform.isMacOSX():
            from twisted.internet.pollreactor import install
        else:
            from twisted.internet.selectreactor import install
    except ImportError:
        from twisted.internet.selectreactor import install
    return install


install = _getInstallFunction(platform)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;很明显，default中会根据平台获取相应的install。Linux下会首先使用epollreactor，如果内核还不支持，就只能使用pollreactor。Mac平台使用pollreactor，windows使用selectreactor。每种install的实现差不多，这里我们抽取selectreactor中的install来看看。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# twisted/internet/selectreactor.py：
def install():
    &amp;quot;&amp;quot;&amp;quot;Configure the twisted mainloop to be run using the select() reactor.
    &amp;quot;&amp;quot;&amp;quot;
    # 单例
    reactor = SelectReactor()
    from twisted.internet.main import installReactor
    installReactor(reactor)

# twisted/internet/main.py：
def installReactor(reactor):
    &amp;quot;&amp;quot;&amp;quot;
    Install reactor C{reactor}.

    @param reactor: An object that provides one or more IReactor* interfaces.
    &amp;quot;&amp;quot;&amp;quot;
    # this stuff should be common to all reactors.
    import twisted.internet
    import sys
    if &#39;twisted.internet.reactor&#39; in sys.modules:
        raise error.ReactorAlreadyInstalledError(&amp;quot;reactor already installed&amp;quot;)
    twisted.internet.reactor = reactor
    sys.modules[&#39;twisted.internet.reactor&#39;] = reactor
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在installReactor中，向sys.modules添加twisted.internet.reactor键，值就是再install中创建的单例reactor。以后要使用reactor，就会导入这个单例了。&lt;/p&gt;

&lt;h2 id=&#34;selectreactor&#34;&gt;SelectReactor&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# twisted/internet/selectreactor.py
@implementer(IReactorFDSet)
class SelectReactor(posixbase.PosixReactorBase, _extraBase)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;implementer表示SelectReactor实现了IReactorFDSet接口的方法，这里用到了&lt;a href=&#34;http://docs.zope.org/zope.interface/&#34;&gt;zope.interface&lt;/a&gt;，它是python中的接口实现，有兴趣的同学可以去看下。&lt;/p&gt;

&lt;p&gt;IReactorFDSet接口主要对描述符的获取、添加、删除等操作的方法。这些方法看名字就能知道意思，所以我就没有加注释。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# twisted/internet/interfaces.py
class IReactorFDSet(Interface):

    def addReader(reader):

    def addWriter(writer):

    def removeReader(reader):

    def removeWriter(writer):

    def removeAll():

    def getReaders():

    def getWriters():

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;reactor-listentcp&#34;&gt;reactor.listenTCP()&lt;/h3&gt;

&lt;p&gt;示例中的reactor.listenTCP()注册了一个监听事件，它是父类PosixReactorBase中方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# twisted/internet/posixbase.py
@implementer(IReactorTCP, IReactorUDP, IReactorMulticast)
class PosixReactorBase(_SignalReactorMixin, _DisconnectSelectableMixin,
                       ReactorBase):

    def listenTCP(self, port, factory, backlog=50, interface=&#39;&#39;):
        p = tcp.Port(port, factory, backlog, interface, self)
        p.startListening()
        return p

# twisted/internet/tcp.py
@implementer(interfaces.IListeningPort)
class Port(base.BasePort, _SocketCloser):
    def __init__(self, port, factory, backlog=50, interface=&#39;&#39;, reactor=None):
       &amp;quot;&amp;quot;&amp;quot;Initialize with a numeric port to listen on.
       &amp;quot;&amp;quot;&amp;quot;
       base.BasePort.__init__(self, reactor=reactor)
       self.port = port
       self.factory = factory
       self.backlog = backlog
       if abstract.isIPv6Address(interface):
           self.addressFamily = socket.AF_INET6
           self._addressType = address.IPv6Address
       self.interface = interface
    ...

    def startListening(self):
       &amp;quot;&amp;quot;&amp;quot;Create and bind my socket, and begin listening on it.
          创建并绑定套接字，开始监听。

       This is called on unserialization, and must be called after creating a
       server to begin listening on the specified port.
       &amp;quot;&amp;quot;&amp;quot;
       if self._preexistingSocket is None:
           # Create a new socket and make it listen
           try:
               # 创建套接字
               skt = self.createInternetSocket()
               if self.addressFamily == socket.AF_INET6:
                   addr = _resolveIPv6(self.interface, self.port)
               else:
                   addr = (self.interface, self.port)
               # 绑定
               skt.bind(addr)
           except socket.error as le:
               raise CannotListenError(self.interface, self.port, le)
           # 监听
           skt.listen(self.backlog)
       else:
           # Re-use the externally specified socket
           skt = self._preexistingSocket
           self._preexistingSocket = None
           # Avoid shutting it down at the end.
           self._shouldShutdown = False

       # Make sure that if we listened on port 0, we update that to
       # reflect what the OS actually assigned us.
       self._realPortNumber = skt.getsockname()[1]

       log.msg(&amp;quot;%s starting on %s&amp;quot; % (
               self._getLogPrefix(self.factory), self._realPortNumber))

       # The order of the next 5 lines is kind of bizarre.  If no one
       # can explain it, perhaps we should re-arrange them.
       self.factory.doStart()
       self.connected = True
       self.socket = skt
       self.fileno = self.socket.fileno
       self.numberAccepts = 100

       # startReading调用reactor的addReader方法将Port加入读集合
       self.startReading()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;整个逻辑很简单，和正常的server端一样，创建套接字、绑定、监听。不同的是将套接字的描述符添加到了reactor的读集合。那么假如有了client连接过来的话，reactor会监控到，然后触发事件处理程序。&lt;/p&gt;

&lt;h2 id=&#34;reacotr-run-事件主循环&#34;&gt;reacotr.run()事件主循环&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# twisted/internet/posixbase.py
@implementer(IReactorTCP, IReactorUDP, IReactorMulticast)
class PosixReactorBase(_SignalReactorMixin, _DisconnectSelectableMixin,
                       ReactorBase)

# twisted/internet/base.py
class _SignalReactorMixin(object):

    def startRunning(self, installSignalHandlers=True):
        &amp;quot;&amp;quot;&amp;quot;
        PosixReactorBase的父类_SignalReactorMixin和ReactorBase都有该函数，但是
        _SignalReactorMixin在前，安装mro顺序的话，会先调用_SignalReactorMixin中的。
        &amp;quot;&amp;quot;&amp;quot;
        self._installSignalHandlers = installSignalHandlers
        ReactorBase.startRunning(self)

    def run(self, installSignalHandlers=True):
        self.startRunning(installSignalHandlers=installSignalHandlers)
        self.mainLoop()

    def mainLoop(self):
        while self._started:
            try:
                while self._started:
                    # Advance simulation time in delayed event
                    # processors.
                    self.runUntilCurrent()
                    t2 = self.timeout()
                    t = self.running and t2
                    # doIteration是关键，select,poll,epool实现各有不同
                    self.doIteration(t)
            except:
                log.msg(&amp;quot;Unexpected error in main loop.&amp;quot;)
                log.err()
            else:
                log.msg(&#39;Main loop terminated.&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mianLoop就是最终的主循环了，在循环中，调用doIteration方法监控读写描述符的集合，一旦发现有描述符准备好读写，就会调用相应的事件处理程序。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# twisted/internet/selectreactor.py
@implementer(IReactorFDSet)
class SelectReactor(posixbase.PosixReactorBase, _extraBase):

    def __init__(self):
        &amp;quot;&amp;quot;&amp;quot;
        Initialize file descriptor tracking dictionaries and the base class.
        &amp;quot;&amp;quot;&amp;quot;
        self._reads = set()
        self._writes = set()
        posixbase.PosixReactorBase.__init__(self)

    def doSelect(self, timeout):
        &amp;quot;&amp;quot;&amp;quot;
        Run one iteration of the I/O monitor loop.

        This will run all selectables who had input or output readiness
        waiting for them.
        &amp;quot;&amp;quot;&amp;quot;
        try:
            # 调用select方法监控读写集合，返回准备好读写的描述符
            r, w, ignored = _select(self._reads,
                                    self._writes,
                                    [], timeout)
        except ValueError:
            # Possibly a file descriptor has gone negative?
            self._preenDescriptors()
            return
        except TypeError:
            # Something *totally* invalid (object w/o fileno, non-integral
            # result) was passed
            log.err()
            self._preenDescriptors()
            return
        except (select.error, socket.error, IOError) as se:
            # select(2) encountered an error, perhaps while calling the fileno()
            # method of a socket.  (Python 2.6 socket.error is an IOError
            # subclass, but on Python 2.5 and earlier it is not.)
            if se.args[0] in (0, 2):
                # windows does this if it got an empty list
                if (not self._reads) and (not self._writes):
                    return
                else:
                    raise
            elif se.args[0] == EINTR:
                return
            elif se.args[0] == EBADF:
                self._preenDescriptors()
                return
            else:
                # OK, I really don&#39;t know what&#39;s going on.  Blow up.
                raise

        _drdw = self._doReadOrWrite
        _logrun = log.callWithLogger
        for selectables, method, fdset in ((r, &amp;quot;doRead&amp;quot;, self._reads),
                                           (w,&amp;quot;doWrite&amp;quot;, self._writes)):
            for selectable in selectables:
                # if this was disconnected in another thread, kill it.
                # ^^^^ --- what the !@#*?  serious!  -exarkun
                if selectable not in fdset:
                    continue
                # This for pausing input when we&#39;re not ready for more.

                # 调用_doReadOrWrite方法
                _logrun(selectable, _drdw, selectable, method)

    doIteration = doSelect

    def _doReadOrWrite(self, selectable, method):
        try:
            # 调用method，doRead或者是doWrite，
            # 这里的selectable可能是我们监听的tcp.Port
            why = getattr(selectable, method)()
        except:
            why = sys.exc_info()[1]
            log.err()
        if why:
            self._disconnectSelectable(selectable, why, method==&amp;quot;doRead&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么假如客户端有连接请求了，就会调用读集合中tcp.Port的doRead方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# twisted/internet/tcp.py

@implementer(interfaces.IListeningPort)
class Port(base.BasePort, _SocketCloser):

    def doRead(self):
        &amp;quot;&amp;quot;&amp;quot;Called when my socket is ready for reading.
        当套接字准备好读的时候调用

        This accepts a connection and calls self.protocol() to handle the
        wire-level protocol.
        &amp;quot;&amp;quot;&amp;quot;
        try:
            if platformType == &amp;quot;posix&amp;quot;:
                numAccepts = self.numberAccepts
            else:
                numAccepts = 1
            for i in range(numAccepts):
                if self.disconnecting:
                    return
                try:
                    # 调用accept
                    skt, addr = self.socket.accept()
                except socket.error as e:
                    if e.args[0] in (EWOULDBLOCK, EAGAIN):
                        self.numberAccepts = i
                        break
                    elif e.args[0] == EPERM:
                        continue
                    elif e.args[0] in (EMFILE, ENOBUFS, ENFILE, ENOMEM, ECONNABORTED):
                        log.msg(&amp;quot;Could not accept new connection (%s)&amp;quot; % (
                            errorcode[e.args[0]],))
                        break
                    raise

                fdesc._setCloseOnExec(skt.fileno())
                protocol = self.factory.buildProtocol(self._buildAddr(addr))
                if protocol is None:
                    skt.close()
                    continue
                s = self.sessionno
                self.sessionno = s+1
                # transport初始化的过程中，会将自身假如到reactor的读集合中，那么当它准备
                # 好读的时候，就可以调用它的doRead方法读取客户端发过来的数据了
                transport = self.transport(skt, protocol, addr, self, s, self.reactor)
                protocol.makeConnection(transport)
            else:
                self.numberAccepts = self.numberAccepts+20
        except:
            log.deferr()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;doRead方法中，调用accept产生了用于接收客户端数据的套接字，将套接字与transport绑定，然后把transport加入到reactor的读集合。当客户端有数据到来时，就会调用transport的doRead方法进行数据读取了。&lt;/p&gt;

&lt;p&gt;Connection是Server（transport实例的类）的父类，它实现了doRead方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# twisted/internet/tcp.py
@implementer(interfaces.ITCPTransport, interfaces.ISystemHandle)
class Connection(_TLSConnectionMixin, abstract.FileDescriptor, _SocketCloser,
                 _AbortingMixin):

    def doRead(self):
        try:
            # 接收数据
            data = self.socket.recv(self.bufferSize)
        except socket.error as se:
            if se.args[0] == EWOULDBLOCK:
                return
            else:
                return main.CONNECTION_LOST

        return self._dataReceived(data)

    def _dataReceived(self, data):
        if not data:
            return main.CONNECTION_DONE
        # 调用我们自定义protocol的dataReceived方法处理数据
        rval = self.protocol.dataReceived(data)
        if rval is not None:
            offender = self.protocol.dataReceived
            warningFormat = (
                &#39;Returning a value other than None from %(fqpn)s is &#39;
                &#39;deprecated since %(version)s.&#39;)
            warningString = deprecate.getDeprecationWarningString(
                offender, versions.Version(&#39;Twisted&#39;, 11, 0, 0),
                format=warningFormat)
            deprecate.warnAboutFunction(offender, warningString)
        return rval
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;_dataReceived中调用了示例中我们自定义的EchoProtocol的dataReceived方法处理数据。&lt;/p&gt;

&lt;p&gt;至此，一个简单的流程，从创建监听事件，到接收客户端数据就此结束了。&lt;/p&gt;

&lt;p&gt;一些细节的地方我并未说明，这里只是说明一个大概的流程，想看的细一点的，可以直接跟着这个流程去看源码。&lt;/p&gt;

&lt;p&gt;这个系列应该会不定时更新，如果有人感兴趣的，也可以和我直接交流。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>浅谈Python的with语句(转载)</title>
      <link>/post/python-with/</link>
      <pubDate>Tue, 07 Jul 2015 22:20:10 +0800</pubDate>
      
      <guid>/post/python-with/</guid>
      <description>&lt;p&gt;本文转自&lt;a href=&#34;http://www.ibm.com/developerworks/cn/opensource/os-cn-pythonwith/&#34;&gt;浅谈Python的with语句&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;引言&#34;&gt;引言&lt;/h2&gt;

&lt;p&gt;with 语句是从 Python 2.5 开始引入的一种与异常处理相关的功能（2.5 版本中要通过 from __future__ import with_statement 导入后才可以使用），从 2.6 版本开始缺省可用（参考 &lt;a href=&#34;https://docs.python.org/release/2.6/whatsnew/2.6.html#pep-343-the-with-statement&#34;&gt;What&amp;rsquo;s new in Python 2.6?&lt;/a&gt; 中 with 语句相关部分介绍）。with 语句适用于对资源进行访问的场合，确保不管使用过程中是否发生异常都会执行必要的“清理”操作，释放资源，比如文件使用后自动关闭、线程中锁的自动获取和释放等。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;术语&#34;&gt;术语&lt;/h2&gt;

&lt;p&gt;要使用 with 语句，首先要明白上下文管理器这一概念。有了上下文管理器，with 语句才能工作。
下面是一组与上下文管理器和with 语句有关的概念。&lt;/p&gt;

&lt;p&gt;上下文管理协议（Context Management Protocol）：包含方法 __enter__() 和 __exit__()，支持
该协议的对象要实现这两个方法。&lt;/p&gt;

&lt;p&gt;上下文管理器（Context Manager）：支持上下文管理协议的对象，这种对象实现了
__enter__() 和 __exit__() 方法。上下文管理器定义执行 with 语句时要建立的运行时上下文，
负责执行 with 语句块上下文中的进入与退出操作。通常使用 with 语句调用上下文管理器，
也可以通过直接调用其方法来使用。&lt;/p&gt;

&lt;p&gt;运行时上下文（runtime context）：由上下文管理器创建，通过上下文管理器的 __enter__() 和
__exit__() 方法实现，__enter__() 方法在语句体执行之前进入运行时上下文，__exit__() 在
语句体执行完后从运行时上下文退出。with 语句支持运行时上下文这一概念。&lt;/p&gt;

&lt;p&gt;上下文表达式（Context Expression）：with 语句中跟在关键字 with 之后的表达式，该表达式
要返回一个上下文管理器对象。&lt;/p&gt;

&lt;p&gt;语句体（with-body）：with 语句包裹起来的代码块，在执行语句体之前会调用上下文管
理器的 __enter__() 方法，执行完语句体之后会执行 __exit__() 方法。&lt;/p&gt;

&lt;h2 id=&#34;基本语法和工作原理&#34;&gt;基本语法和工作原理&lt;/h2&gt;

&lt;p&gt;with 语句的语法格式如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 清单 1. with 语句的语法格式
with context_expression [as target(s)]:
    with-body
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里 context_expression 要返回一个上下文管理器对象，该对象并不赋值给 as 子句中的 target(s) ，如果指定了 as 子句的话，会将上下文管理器的__enter__() 方法的返回值赋值给 target(s)。target(s) 可以是单个变量，或者由“()”括起来的元组（不能是仅仅由“,”分隔的变量列表，必须加“()”）。&lt;/p&gt;

&lt;p&gt;Python 对一些内建对象进行改进，加入了对上下文管理器的支持，可以用于 with 语句中，比如可以自动关闭文件、线程锁的自动获取和释放等。假设要对一个文件进行操作，使用 with 语句可以有如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 清单 2. 使用 with 语句操作文件对象
with open(r&#39;somefileName&#39;) as somefile:
    for line in somefile:
        print line
        # ...more code
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里使用了 with 语句，不管在处理文件过程中是否发生异常，都能保证 with 语句执行完毕后已经关闭了打开的文件句柄。如果使用传统的 try/finally 范式，则要使用类似如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 清单 3. try/finally 方式操作文件对象
somefile = open(r&#39;somefileName&#39;)
try:
    for line in somefile:
        print line
        # ...more code
finally:
    somefile.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;比较起来，使用 with 语句可以减少编码量。已经加入对上下文管理协议支持的还有模块 threading、decimal 等。&lt;/p&gt;

&lt;p&gt;PEP 0343 对 with 语句的实现进行了描述。with 语句的执行过程类似如下代码块：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 清单 4. with 语句执行过程
context_manager = context_expression
exit = type(context_manager).__exit__
value = type(context_manager).__enter__(context_manager)
exc = True   # True 表示正常执行，即便有异常也忽略；False 表示重新抛出异常，需要对异常进行处理
try:
    try:
        target = value  # 如果使用了 as 子句
        with-body     # 执行 with-body
    except:
        # 执行过程中有异常发生
        exc = False
        # 如果 __exit__ 返回 True，则异常被忽略；如果返回 False，则重新抛出异常
        # 由外层代码对异常进行处理
        if not exit(context_manager, *sys.exc_info()):
            raise
finally:
    # 正常退出，或者通过 statement-body 中的 break/continue/return 语句退出
    # 或者忽略异常退出
    if exc:
        exit(context_manager, None, None, None)
    # 缺省返回 None，None 在布尔上下文中看做是 False
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;执行 context_expression，生成上下文管理器 context_manager&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;调用上下文管理器的 __enter__() 方法；如果使用了 as 子句，则将 __enter__() 方法的返回值赋值给 as 子句中的 target(s)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;执行语句体 with-body&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;不管是否执行过程中是否发生了异常，执行上下文管理器的 __exit__() 方法，__exit__() 方法负责执行“清理”工作，如释放资源等。如果执行过程中没有出现异常，或者语句体中执行了语句 break/continue/return，则以 None 作为参数调用 __exit__(None, None, None) ；如果执行过程中出现异常，则使用 sys.exc_info 得到的异常信息为参数调用__exit__(exc_type, exc_value, exc_traceback)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;出现异常时，如果 __exit__(type, value, traceback) 返回 False，则会重新抛出异常，让with 之外的语句逻辑来处理异常，这也是通用做法；如果返回 True，则忽略异常，不再对异常进行处理&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;自定义上下文管理器&#34;&gt;自定义上下文管理器&lt;/h2&gt;

&lt;p&gt;开发人员可以自定义支持上下文管理协议的类。自定义的上下文管理器要实现上下文管理协议所需要的 __enter__() 和 __exit__() 两个方法：&lt;/p&gt;

&lt;p&gt;context_manager.__enter__()：进入上下文管理器的运行时上下文，在语句体执行前调用。with 语句将该方法的返回值赋值给 as 子句中的 target，如果指定了 as 子句的话&lt;/p&gt;

&lt;p&gt;context_manager.__exit__(exc_type, exc_value, exc_traceback)： 退出与上下文管理器相关的运行时上下文，返回一个布尔值表示是否对发生的异常进行处理。参数表示引起退出操作的异常，如果退出时没有发生异常，则3个参数都为None。如果发生异常，返回True 表示不处理异常，否则会在退出该方法后重新抛出异常以由 with 语句之外的代码逻辑进行处理。如果该方法内部产生异常，则会取代由 statement-body 中语句产生的异常。要处理异常时，不要显示重新抛出异常，即不能重新抛出通过参数传递进来的异常，只需要将返回值设置为 False 就可以了。之后，上下文管理代码会检测是否__exit__() 失败来处理异常&lt;/p&gt;

&lt;p&gt;下面通过一个简单的示例来演示如何构建自定义的上下文管理器。注意，上下文管理器必须同时提供 __enter__() 和 __exit__() 方法的定义，缺少任何一个都会导致 AttributeError；with 语句会先检查是否提供了 __exit__() 方法，然后检查是否定义了 __enter__() 方法。&lt;/p&gt;

&lt;p&gt;假设有一个资源 DummyResource，这种资源需要在访问前先分配，使用完后再释放掉；分配操作可以放到 __enter__() 方法中，释放操作可以放到 __exit__() 方法中。简单起见，这里只通过打印语句来表明当前的操作，并没有实际的资源分配与释放。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 清单 5. 自定义支持 with 语句的对象
class DummyResource:
    def __init__(self, tag):
            self.tag = tag
            print &#39;Resource [%s]&#39; % tag
        def __enter__(self):
            print &#39;[Enter %s]: Allocate resource.&#39; % self.tag
            return self	  # 可以返回不同的对象
        def __exit__(self, exc_type, exc_value, exc_tb):
            print &#39;[Exit %s]: Free resource.&#39; % self.tag
            if exc_tb is None:
                print &#39;[Exit %s]: Exited without exception.&#39; % self.tag
            else:
                print &#39;[Exit %s]: Exited with exception raised.&#39; % self.tag
                return False   # 可以省略，缺省的None也是被看做是False
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;DummyResource 中的 __enter__() 返回的是自身的引用，这个引用可以赋值给 as 子句中的 target 变量；返回值的类型可以根据实际需要设置为不同的类型，不必是上下文管理器对象本身。&lt;/p&gt;

&lt;p&gt;__exit__() 方法中对变量 exc_tb 进行检测，如果不为 None，表示发生了异常，返回 False 表示需要由外部代码逻辑对异常进行处理；注意到如果没有发生异常，缺省的返回值为 None，在布尔环境中也是被看做 False，但是由于没有异常发生，__exit__() 的三个参数都为 None，上下文管理代码可以检测这种情况，做正常处理。&lt;/p&gt;

&lt;p&gt;下面在 with 语句中访问 DummyResource ：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 清单 6. 使用自定义的支持 with 语句的对象
with DummyResource(&#39;Normal&#39;):
    print &#39;[with-body] Run without exceptions.&#39;

with DummyResource(&#39;With-Exception&#39;):
    print &#39;[with-body] Run with exception.&#39;
    raise Exception
    print &#39;[with-body] Run with exception. Failed to finish statement-body!&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第1个 with 语句的执行结果如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 清单 7. with 语句1执行结果
Resource [Normal]
[Enter Normal]: Allocate resource.
[with-body] Run without exceptions.
[Exit Normal]: Free resource.
[Exit Normal]: Exited without exception.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，正常执行时会先执行完语句体 with-body，然后执行 __exit__() 方法释放资源。&lt;/p&gt;

&lt;p&gt;第2个 with 语句的执行结果如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 清单 8. with 语句2执行结果
Resource [With-Exception]
[Enter With-Exception]: Allocate resource.
[with-body] Run with exception.
[Exit With-Exception]: Free resource.
[Exit With-Exception]: Exited with exception raised.

Traceback (most recent call last):
  File &amp;quot;G:/demo&amp;quot;, line 20, in &amp;lt;module&amp;gt;
    raise Exception
Exception
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，with-body 中发生异常时with-body 并没有执行完，但资源会保证被释放掉，同时产生的异常由 with 语句之外的代码逻辑来捕获处理。&lt;/p&gt;

&lt;p&gt;可以自定义上下文管理器来对软件系统中的资源进行管理，比如数据库连接、共享资源的访问控制等。Python 在线文档 Writing Context Managers 提供了一个针对数据库连接进行管理的上下文管理器的简单范例。&lt;/p&gt;

&lt;h2 id=&#34;contextlib-模块&#34;&gt;contextlib 模块&lt;/h2&gt;

&lt;p&gt;contextlib 模块提供了3个对象：装饰器 contextmanager、函数 nested 和上下文管理器 closing。使用这些对象，可以对已有的生成器函数或者对象进行包装，加入对上下文管理协议的支持，避免了专门编写上下文管理器来支持 with 语句。&lt;/p&gt;

&lt;h3 id=&#34;装饰器-contextmanager&#34;&gt;装饰器 contextmanager&lt;/h3&gt;

&lt;p&gt;contextmanager 用于对生成器函数进行装饰，生成器函数被装饰以后，返回的是一个上下文管理器，其 __enter__() 和 __exit__() 方法由 contextmanager 负责提供，而不再是之前的迭代子。被装饰的生成器函数只能产生一个值，否则会导致异常 RuntimeError；产生的值会赋值给 as 子句中的 target，如果使用了 as 子句的话。下面看一个简单的例子。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 清单 9. 装饰器 contextmanager 使用示例
from contextlib import contextmanager

@contextmanager
def demo():
    print &#39;[Allocate resources]&#39;
    print &#39;Code before yield-statement executes in \_\_enter\_\_&#39;
    yield &#39;*** contextmanager demo ***&#39;
    print &#39;Code after yield-statement executes in \_\_exit\_\_&#39;
    print &#39;[Free resources]&#39;

with demo() as value:
    print &#39;Assigned Value: %s&#39; % value

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果输出如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 清单 10. contextmanager 使用示例执行结果
[Allocate resources]
Code before yield-statement executes in __enter__
Assigned Value: *** contextmanager demo ***
Code after yield-statement executes in __exit__
[Free resources]
``
可以看到，生成器函数中 yield 之前的语句在 \_\_enter\_\_() 方法中执行，yield 之后的语句在 \_\_exit\_\_() 中执行，而 yield 产生的值赋给了 as 子句中的 value 变量。

需要注意的是，contextmanager 只是省略了 \_\_enter\_\_() / \_\_exit\_\_() 的编写，但并不负责实现资源的“获取”和“清理”工作；“获取”操作需要定义在 yield 语句之前，“清理”操作需要定义 yield 语句之后，这样 with 语句在执行 \_\_enter\_\_() / \_\_exit\_\_() 方法时会执行这些语句以获取/释放资源，即生成器函数中需要实现必要的逻辑控制，包括资源访问出现错误时抛出适当的异常。

### 函数 nested

nested 可以将多个上下文管理器组织在一起，避免使用嵌套 with 语句。

```python
# 清单 11. nested 语法
with nested(A(), B(), C()) as (X, Y, Z):
      # with-body code here
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;类似于：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 清单 12. nested 执行过程
with A() as X:
    with B() as Y:
        with C() as Z:
              # with-body code here
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要注意的是，发生异常后，如果某个上下文管理器的 __exit__() 方法对异常处理返回 False，则更外层的上下文管理器不会监测到异常。&lt;/p&gt;

&lt;h3 id=&#34;上下文管理器-closing&#34;&gt;上下文管理器 closing&lt;/h3&gt;

&lt;p&gt;closing 的实现如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 清单 13. 上下文管理 closing 实现
class closing(object):
    # help doc here
    def __init__(self, thing):
        self.thing = thing
    def __enter__(self):
        return self.thing
    def __exit__(self, *exc_info):
        self.thing.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上下文管理器会将包装的对象赋值给 as 子句的 target 变量，同时保证打开的对象在 with-body 执行完后会关闭掉。closing 上下文管理器包装起来的对象必须提供 close() 方法的定义，否则执行时会报 AttributeError 错误。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 清单 14. 自定义支持 closing 的对象
class ClosingDemo(object):
    def __init__(self):
        self.acquire()
    def acquire(self):
        print &#39;Acquire resources.&#39;
    def free(self):
        print &#39;Clean up any resources acquired.&#39;
    def close(self):
        self.free()

with closing(ClosingDemo()):
    print &#39;Using resources&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果输出如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 清单 15. 自定义 closing 对象的输出结果
Acquire resources.
Using resources
Clean up any resources acquired.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;closing 适用于提供了 close() 实现的对象，比如网络连接、数据库连接等，也可以在自定义类时通过接口 close() 来执行所需要的资源“清理”工作。&lt;/p&gt;

&lt;h2 id=&#34;小结&#34;&gt;小结&lt;/h2&gt;

&lt;p&gt;本文对 with 语句的语法和工作机理进行了介绍，并通过示例介绍了如何实现自定义的上下文管理器，最后介绍了如何使用 contextlib 模块来简化上下文管理器的编写。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Python __future__ 模块</title>
      <link>/post/python-future/</link>
      <pubDate>Fri, 03 Jul 2015 22:18:29 +0800</pubDate>
      
      <guid>/post/python-future/</guid>
      <description>&lt;p&gt;在Python2.7代码中经常能看到使用__future__模块。那么__future__到底是做什么的呢？&lt;/p&gt;

&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;

&lt;p&gt;从单词含义上猜应该是“未来”的模块。它有下面几个&lt;a href=&#34;https://docs.python.org/2.7/library/__future__.html&#34;&gt;目的&lt;/a&gt;：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;避免和现有分析import工具混淆，并得到你期望的模块&lt;/li&gt;
&lt;li&gt;确保2.1之前的版本导入__future__产生运行时异常，因为2.1之前没有这个模块&lt;/li&gt;
&lt;li&gt;文档化不兼容的改变，通常这些改变会在新版中强制执行。这类文档以可执行的形式组织，通过导入__future__进行可编程式的检查。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;以上是对官方解释的粗略翻译，翻译起来感觉有些拗口。我是这么理解的，某个版本中出现了某个新的功能特性，而且这个特性和当前版本中使用的不兼容，也就是它在该版本中不是语言标准，那么我如果想要使用的话就需要从__future__模块导入。在2.1版本之前并没有__future__，所以使用它会引发异常。当然，在以后的某个版本中，比如说3中，某个特性已经成为标准的一部分，那么使用该特性就不用从__future__导入了。&lt;/p&gt;

&lt;p&gt;下面说一下__future__是如何实现新特性的。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;feature类&#34;&gt;_Feature类&lt;/h2&gt;

&lt;p&gt;__future__.py中有形如下面的语句：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;FeatureName = _Feature(OptionalRelease, MandatoryRelease, CompilerFlag)

class _Feature:
    def __init__(self, optionalRelease, mandatoryRelease, compiler_flag):
        self.optional = optionalRelease    # 某个特性被认可的初始版本
        self.mandatory = mandatoryRelease  # 某个特性成为标准的版本
        self.compiler_flag = compiler_flag

    def getOptionalRelease(self):
        &amp;quot;&amp;quot;&amp;quot;Return first release in which this feature was recognized.

        This is a 5-tuple, of the same form as sys.version_info.
        &amp;quot;&amp;quot;&amp;quot;

        return self.optional

    def getMandatoryRelease(self):
        &amp;quot;&amp;quot;&amp;quot;Return release in which this feature will become mandatory.

        This is a 5-tuple, of the same form as sys.version_info, or, if
        the feature was dropped, is None.
        &amp;quot;&amp;quot;&amp;quot;

        return self.mandatory

    def __repr__(self):
        return &amp;quot;_Feature&amp;quot; + repr((self.optional,
                                  self.mandatory,
                                  self.compiler_flag))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;optionalrelease参数&#34;&gt;OptionalRelease参数&lt;/h2&gt;

&lt;p&gt;通常OptionalRelease版本小于MandatoryRelease，每个都是5个元素的元组，类似sys.version_info。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;(PY_MAJOR_VERSION, # the 2 in 2.1.0a3; an int
PY_MINOR_VERSION, # the 1; an int
PY_MICRO_VERSION, # the 0; an int
PY_RELEASE_LEVEL, # &amp;quot;alpha&amp;quot;, &amp;quot;beta&amp;quot;, &amp;quot;candidate&amp;quot; or &amp;quot;final&amp;quot;; string
PY_RELEASE_SERIAL # the 3; an int
)

# 例如: (2, 1, 0, &amp;quot;alpha&amp;quot;, 3)表示2.1.0a3版
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OptionalRelease版本中开始通过下列方式使用某个特性：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from __future__ import FeatureName
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;mandatoryrelease参数&#34;&gt;MandatoryRelease参数&lt;/h2&gt;

&lt;p&gt;在MandatoryRelease版本中该特性变成Python标准的一部分。此外MandatoryRelease版本后不需要上面的导入语句就能使用该特性。MandatoryRelease可能是None，表示一个计划中的特性被放弃了。&lt;/p&gt;

&lt;h2 id=&#34;compilerflag参数&#34;&gt;CompilerFlag参数&lt;/h2&gt;

&lt;p&gt;CompilerFlag编译器标志，它是一个位域标志，传给内建函数compile()做第四个参数，用来在动态编译代码的时候允许新的特性。&lt;/p&gt;

&lt;p&gt;CompilerFlag值等价于Include/compile.h的预定义的CO_xxx标志。&lt;/p&gt;

&lt;h2 id=&#34;python2-future-模块的features&#34;&gt;Python2 __future__模块的features&lt;/h2&gt;

&lt;p&gt;一共是以下7种，其对应的CompilerFlag:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;all_feature_names = [
    &amp;quot;nested_scopes&amp;quot;,
    &amp;quot;generators&amp;quot;,
    &amp;quot;division&amp;quot;,
    &amp;quot;absolute_import&amp;quot;,
    &amp;quot;with_statement&amp;quot;,
    &amp;quot;print_function&amp;quot;,
    &amp;quot;unicode_literals&amp;quot;,
]

CO_NESTED            = 0x0010   # nested_scopes
CO_GENERATOR_ALLOWED = 0        # generators (obsolete, was 0x1000)
CO_FUTURE_DIVISION   = 0x2000   # division
CO_FUTURE_ABSOLUTE_IMPORT = 0x4000 # perform absolute imports by default
CO_FUTURE_WITH_STATEMENT  = 0x8000   # with statement
CO_FUTURE_PRINT_FUNCTION  = 0x10000   # print function
CO_FUTURE_UNICODE_LITERALS = 0x20000 # unicode string literals
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;nested-scopes&#34;&gt;nested_scopes&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;nested_scopes = _Feature((2, 1, 0, &amp;quot;beta&amp;quot;,  1),
                         (2, 2, 0, &amp;quot;alpha&amp;quot;, 0),
                         CO_NESTED)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;nested_scopes指的是嵌套作用域，2.1.0b1中出现，2.2.0a0中成为标准。&lt;/p&gt;

&lt;p&gt;提到作用域，那么就不得不说命名空间。&lt;/p&gt;

&lt;h4 id=&#34;命名空间的定义&#34;&gt;命名空间的定义&lt;/h4&gt;

&lt;p&gt;Python命名空间是名称到对象的映射，目前是用字典实现，键名是变量名，值是变量的值。比如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; x = 3
&amp;gt;&amp;gt;&amp;gt; globals()
{&#39;__builtins__&#39;: &amp;lt;module &#39;__builtin__&#39; (built-in)&amp;gt;, &#39;__name__&#39;: &#39;__main__&#39;, &#39;__doc__&#39;: None, &#39;x&#39;: 3, &#39;__package__&#39;: None}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到变量x，3以字典的形式存放在globals空间内。以之对应的名称空间还有：locals()。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; locals()
{&#39;__builtins__&#39;: &amp;lt;module &#39;__builtin__&#39; (built-in)&amp;gt;, &#39;__name__&#39;: &#39;__main__&#39;, &#39;__doc__&#39;: None, &#39;x&#39;: 3, &#39;__package__&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实际上，你可以通过向名字添加键名和值，然后就可以直接使用名称了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; globals()[&#39;y&#39;] = 5
&amp;gt;&amp;gt;&amp;gt; y
5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通常，我们用属性来称呼&amp;rsquo;.&amp;lsquo;点号之后的名称为属性。比如，在z.real中，real是z的一个属性。严格来说，模块中的名称引用就是属性引用。modname.funcname中，modname是一个模块对象，而funcname是它的一个属性。模块属性和全局名称有映射关系，它们共享全局命名空间。上面代码中的x和y都是模块&lt;strong&gt;main&lt;/strong&gt;的属性。&lt;/p&gt;

&lt;p&gt;属性可能是只读的，也可能是可写的。模块属性是可写的，你可以这么做，modname.the_answer = 42。可写的属性能够用del语句来删除。比如，del modname.the_answer将会从模块modname中删除the_answer属性。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; x = 3
&amp;gt;&amp;gt;&amp;gt; globals()
{&#39;__builtins__&#39;: &amp;lt;module &#39;__builtin__&#39; (built-in)&amp;gt;, &#39;__package__&#39;: None, &#39;func&#39;: &amp;lt;function func at 0x029FA270&amp;gt;, &#39;x&#39;: 3, &#39;__name__&#39;: &#39;__main__&#39;, &#39;__doc__&#39;: None}
&amp;gt;&amp;gt;&amp;gt; del x
&amp;gt;&amp;gt;&amp;gt; globals()
{&#39;__builtins__&#39;: &amp;lt;module &#39;__builtin__&#39; (built-in)&amp;gt;, &#39;__package__&#39;: None, &#39;func&#39;: &amp;lt;function func at 0x029FA270&amp;gt;, &#39;__name__&#39;: &#39;__main__&#39;, &#39;__doc__&#39;: None}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;del做的事实际上是删除了全局名称字典中的x键值。&lt;/p&gt;

&lt;h4 id=&#34;命名空间的种类&#34;&gt;命名空间的种类&lt;/h4&gt;

&lt;p&gt;Python中有三种命名空间：&lt;/p&gt;

&lt;p&gt;a) 局部，函数内的命名空间就是局部的，它记录了函数的变量，包括函数的参数和局部定义的变量。&lt;/p&gt;

&lt;p&gt;b) 全局，模块内的命名空间就是全局的，它记录了模块的变量，包括函数、类、其它导入的模块、模块级的变量和常量。&lt;/p&gt;

&lt;p&gt;c) 内置，包括异常类型、内建函数和特殊方法，可以代码中任意地方调用；&lt;/p&gt;

&lt;p&gt;上面提到的globals是全局命名空间，locals是局部命名空间。&lt;/p&gt;

&lt;p&gt;命名空间会在不同的时间创建，并有不同的生命周期。包含内置名称的命名空间是在python解释器启动的时候创建的，并且不会被删除。一个模块的全局命名空间是在模块定义代码被读入的时候创建的，一般情况下，模块命名空间会持续到解释器结束。在解释器最上层调用的代码，不管是从脚本中读入的还是在交互式界面中，都会被认为是属于一个叫做&lt;strong&gt;main&lt;/strong&gt;模块的,所以它们有自己的全局命名空间。（内置名称实际上也放置在一个模块中，称为builtins）。&lt;/p&gt;

&lt;p&gt;一个函数的局部命名空间在函数被调用的时候创建，在函数返回或者引发一个不在函数内部处理的异常时被删除。（实际上用遗忘来描述这个删除比较好。）当然了，递归调用的函数每个都有它们自己的命名空间。&lt;/p&gt;

&lt;h4 id=&#34;命名空间的可见性-作用域&#34;&gt;命名空间的可见性（作用域）&lt;/h4&gt;

&lt;p&gt;作用域是一个Python程序中命名空间直接可见的代码区域，也就是说这个区域内可以直接使用命名空间内的名称。&lt;/p&gt;

&lt;p&gt;a) 内置命名空间在代码所有位置都是可见的，所以可以随时被调用；&lt;/p&gt;

&lt;p&gt;b) 全局命名空间和局部命名空间中， 如果有同名变量，在全局命名空间处，局部命名空间内的同名变量是不可见的；&lt;/p&gt;

&lt;p&gt;c) 在局部命名空间处，全局命名空间的同名变量是不可见的（只有变量不同名的情况下，可使用 global关键字让其可见）。&lt;/p&gt;

&lt;h4 id=&#34;命名空间的查找顺序&#34;&gt;命名空间的查找顺序&lt;/h4&gt;

&lt;p&gt;a) 如果在函数内调用一个变量，先在函数内（局部命名空间）查找，如果找到则停止查找。否则在函数外部（全局命名空间）查找，如果还是没找到，则查找内置命名空间。如果以上三个命名都未找到，则抛出NameError 的异常错误。&lt;/p&gt;

&lt;p&gt;b) 如果在函数外调用一个变量，则在函数外查找（全局命名空间，局部命名空间此时不可见），如果找到则停止查找，否则到内置命名空间中查找。如果两者都找不到，则抛出异常。只有当局部命名空间内，使用global 关键字声明了一个变量时，查找顺序则是 a) 的查找顺序。&lt;/p&gt;

&lt;h4 id=&#34;nested-scopes说明&#34;&gt;nested_scopes说明&lt;/h4&gt;

&lt;p&gt;Python2.2引入了一种略有不同但重要的改变，它会影响命名空间的搜索顺序：嵌套的作用域。在2.0中，当你在一个嵌套函数或 lambda 函数中引用一个变量时，Python会在当前（嵌套的或 lambda）函数的名称空间中搜索，然后在模块的名称空间。2.2将支在当前（嵌套的或 lambda）函数的名称空间中搜索，然后是在父函数的名称空间，接着是模块的名称空间。2.1可以两种方式工作，缺省地，按n2.0的方式工作，如果想像2.2中那样工作，使用下面的导入语句：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from __future__ import nested_scopes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然现在一般都用2.7或者3了，所以已经是嵌套作用域了。&lt;/p&gt;

&lt;p&gt;来看下面一段代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; x = 3
&amp;gt;&amp;gt;&amp;gt; globals()
{&#39;__builtins__&#39;: &amp;lt;module &#39;__builtin__&#39; (built-in)&amp;gt;, &#39;__package__&#39;: None, &#39;func&#39;: &amp;lt;function func at 0x028BA2B0&amp;gt;, &#39;x&#39;: 3, &#39;__name__&#39;: &#39;__main__&#39;, &#39;__doc__&#39;: None}
&amp;gt;&amp;gt;&amp;gt; def func():
        x = 2
	      print locals()

&amp;gt;&amp;gt;&amp;gt; func()
{&#39;x&#39;: 2}
&amp;gt;&amp;gt;&amp;gt; globals()
{&#39;__builtins__&#39;: &amp;lt;module &#39;__builtin__&#39; (built-in)&amp;gt;, &#39;__package__&#39;: None, &#39;func&#39;: &amp;lt;function func at 0x028BA2B0&amp;gt;, &#39;x&#39;: 3, &#39;__name__&#39;: &#39;__main__&#39;, &#39;__doc__&#39;: None}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;全局命名空间中x的值前后并没有改变，反而在func函数的局部命名空间中产生了一个新的名称x。由此可以看出，外层作用域的命名空间对于内层来说是只读的，当写一个同名的名称时，只会在内层生成一个新的名称。但是如果一个名称被声明为global，对其引用和复制都会直接作用域全局名称。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; x = 2
&amp;gt;&amp;gt;&amp;gt; def func():
        global x
	      x = 3
	      print locals()

&amp;gt;&amp;gt;&amp;gt; globals()
{&#39;__builtins__&#39;: &amp;lt;module &#39;__builtin__&#39; (built-in)&amp;gt;, &#39;__package__&#39;: None, &#39;func&#39;: &amp;lt;function func at 0x029FA270&amp;gt;, &#39;x&#39;: 2, &#39;__name__&#39;: &#39;__main__&#39;, &#39;__doc__&#39;: None
&amp;gt;&amp;gt;&amp;gt; func()
{}
&amp;gt;&amp;gt;&amp;gt; globals()
{&#39;__builtins__&#39;: &amp;lt;module &#39;__builtin__&#39; (built-in)&amp;gt;, &#39;__package__&#39;: None, &#39;func&#39;: &amp;lt;function func at 0x029FA270&amp;gt;, &#39;x&#39;: 3, &#39;__name__&#39;: &#39;__main__&#39;, &#39;__doc__&#39;: None}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;x的值前后改变了，而且func函数中也没用增加x。&lt;/p&gt;

&lt;h4 id=&#34;import-module和from-module-import-func&#34;&gt;import module和from module import func&lt;/h4&gt;

&lt;p&gt;import module将模块自身导入到当前命名空间，所以如果要使用module的某个函数或属性，只能module.func这么用。&lt;/p&gt;

&lt;p&gt;而使用from module import func，则是将函数func导入当前的名称空间，这时候使用这个函数就不需要模块名称而是直接使用func。&lt;/p&gt;

&lt;p&gt;我们通过一段代码来描述：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; globals()
{&#39;__builtins__&#39;: &amp;lt;module &#39;__builtin__&#39; (built-in)&amp;gt;, &#39;__package__&#39;: None, &#39;__name__&#39;: &#39;__main__&#39;, &#39;__doc__&#39;: None}
&amp;gt;&amp;gt;&amp;gt; import os
&amp;gt;&amp;gt;&amp;gt; globals()
{&#39;__builtins__&#39;: &amp;lt;module &#39;__builtin__&#39; (built-in)&amp;gt;, &#39;__package__&#39;: None, &#39;__name__&#39;: &#39;__main__&#39;, &#39;os&#39;: &amp;lt;module &#39;os&#39; from &#39;C:\Python27\lib\os.pyc&#39;&amp;gt;, &#39;__doc__&#39;: None}
&amp;gt;&amp;gt;&amp;gt; del os
&amp;gt;&amp;gt;&amp;gt; from os import sys
&amp;gt;&amp;gt;&amp;gt; globals()
{&#39;__builtins__&#39;: &amp;lt;module &#39;__builtin__&#39; (built-in)&amp;gt;, &#39;__package__&#39;: None, &#39;sys&#39;: &amp;lt;module &#39;sys&#39; (built-in)&amp;gt;, &#39;__name__&#39;: &#39;__main__&#39;, &#39;__doc__&#39;: None}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;是不是很清晰，担任sys也是一个模块，如果要使用sys模块的属性，也必须要使用sys模块名了。这也是嵌套作用域的一个例子。&lt;/p&gt;

&lt;p&gt;额。。。貌似本文的正题是__future__，哈哈，扯远了，我们继续来看下面一个feauture。&lt;/p&gt;

&lt;h3 id=&#34;generators&#34;&gt;generators&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;generators = _Feature((2, 2, 0, &amp;quot;alpha&amp;quot;, 1),
                      (2, 3, 0, &amp;quot;final&amp;quot;, 0),
                      CO_GENERATOR_ALLOWED)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;generators生成器起于2.2.0a1版，在2.3.0f0中成为标准。&lt;/p&gt;

&lt;h4 id=&#34;简介-1&#34;&gt;简介&lt;/h4&gt;

&lt;p&gt;生成器是这样一个函数，它记住上一次返回时在函数体中的位置。对生成器函数的第二次（或第 n 次）调用跳转至该函数中间，而上次调用的所有局部变量都保持不变。Python中yeild就是一个生成器。&lt;/p&gt;

&lt;h4 id=&#34;yield-生成器的运行机制&#34;&gt;yield 生成器的运行机制&lt;/h4&gt;

&lt;p&gt;当你问生成器要一个数时，生成器会执行，直至出现 yield 语句，生成器把 yield 的参数给你，之后生成器就不会往下继续运行。 当你问他要下一个数时，他会从上次的状态。开始运行，直至出现yield语句，把参数给你，之后停下。如此反复直至退出函数。&lt;/p&gt;

&lt;h4 id=&#34;示例&#34;&gt;示例&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; def my_generator():
	      yield 1
	      yield 2
	      yield 3

&amp;gt;&amp;gt;&amp;gt; gen = my_generator()
&amp;gt;&amp;gt;&amp;gt; gen.next()
1
&amp;gt;&amp;gt;&amp;gt; gen.next()
2
&amp;gt;&amp;gt;&amp;gt; gen.next()
3
&amp;gt;&amp;gt;&amp;gt; gen.next()

Traceback (most recent call last):
  File &amp;quot;&amp;lt;pyshell#92&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt;
    gen.next()
StopIteration
&amp;gt;&amp;gt;&amp;gt; for n in my_generator:
        print n
1
2
3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;yield在被next调用之前并没有执行（for循环内部也是使用next），在执行完最后一个yield之后再继续调用next，那么就好遇到StopIteration异常了。这里涉及到迭代器了，不再进行详细的描述了，后面会单开一章来讲Python的三大器：迭代器、生成器、装饰器。&lt;/p&gt;

&lt;h3 id=&#34;division&#34;&gt;division&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;division = _Feature((2, 2, 0, &amp;quot;alpha&amp;quot;, 2),
                    (3, 0, 0, &amp;quot;alpha&amp;quot;, 0),
                    CO_FUTURE_DIVISION)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个很简单，举例说明一下大家就懂了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# python2.7中，不导入__future__
&amp;gt;&amp;gt;&amp;gt; 10/3
3

# 导入__future__
&amp;gt;&amp;gt;&amp;gt; from __future__ import division
&amp;gt;&amp;gt;&amp;gt; 10/3
3.3333333333333335
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;很容易看出来，2.7中默认的整数除法是结果向下取整，而导入了__future__之后除法就是真正的除法了。这也是python2和python3的一个重要区别。&lt;/p&gt;

&lt;h3 id=&#34;absolute-import&#34;&gt;absolute_import&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;absolute_import = _Feature((2, 5, 0, &amp;quot;alpha&amp;quot;, 1),
                           (3, 0, 0, &amp;quot;alpha&amp;quot;, 0),
                           CO_FUTURE_ABSOLUTE_IMPORT)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;python2.7中，在默认情况下，导入模块是相对导入的（relative import），比如说&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from . import json
from .json import json_dump
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这些以&amp;rsquo;.&amp;lsquo;点导入的是相对导入，而绝对导入（absolute import）则是指从系统路径sys.path最底层的模块导入。比如:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import os
from os import sys
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;with-statement&#34;&gt;with_statement&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;with_statement = _Feature((2, 5, 0, &amp;quot;alpha&amp;quot;, 1),
                          (2, 6, 0, &amp;quot;alpha&amp;quot;, 0),
                          CO_FUTURE_WITH_STATEMENT)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;with语句也不详细讲了，看这篇&lt;a href=&#34;http://blog.syfun.net/2015/07/07/python-with-statement&#34;&gt;浅谈Python的with语句&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;print-function&#34;&gt;print_function&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;print_function = _Feature((2, 6, 0, &amp;quot;alpha&amp;quot;, 2),
                          (3, 0, 0, &amp;quot;alpha&amp;quot;, 0),
                          CO_FUTURE_PRINT_FUNCTION)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个就是最经典的python2和python3的区别了，python2中print不需要括号，而在python3中则需要。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# python2.7
print &amp;quot;Hello world&amp;quot;

# python3
print(&amp;quot;Hello world&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;unicode-literals&#34;&gt;unicode_literals&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;unicode_literals = _Feature((2, 6, 0, &amp;quot;alpha&amp;quot;, 2),
                            (3, 0, 0, &amp;quot;alpha&amp;quot;, 0),
                            CO_FUTURE_UNICODE_LITERALS)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是unicode的问题，讲起来又是长篇大论了，容我偷个懒，后面再讲吧。&lt;/p&gt;

&lt;p&gt;至此，__future__模块的几个特性，算是说完了。好多内容都是参照官方文档，所以大家还是多看文档吧。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>PaaS以及开源PaaS平台</title>
      <link>/post/pass/</link>
      <pubDate>Fri, 26 Jun 2015 22:12:41 +0800</pubDate>
      
      <guid>/post/pass/</guid>
      <description>&lt;h2 id=&#34;一-什么是iaas-paas和saas及其区别&#34;&gt;一、什么是IaaS, PaaS和SaaS及其区别&lt;/h2&gt;

&lt;p&gt;任何一个在互联网上提供其服务的公司都可以叫做云计算公司。其实云计算分几层的，
 分别是Infrastructure（基础设施）-as-a- Service，Platform（平台）-as-a-Service，
 Software（软件）-as-a-Service。基础设施在最下端，平台在 中间，软件在顶端。
 别的一些“软”的层可以在这些层上面添加。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/iaas-paas-saas.jpg&#34; alt=&#34;IaaS-PaaS-SaaS&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;iaas-infrastructure-as-a-service-基础设施即服务&#34;&gt;IaaS: Infrastructure-as-a-Service（基础设施即服务）&lt;/h3&gt;

&lt;p&gt;第一层叫做IaaS，有时候也叫做Hardware-as-a-Service，几年前如果你想在办公室或
 者公司的网站上运行一些企业应用，你需要去买服务器，或者别的高昂的硬件来控制本地应用，
 让你的业务运行起来。&lt;/p&gt;

&lt;p&gt;但是现在有IaaS，你可以将硬件外包到别的地方去。IaaS公司会提供场外服务器，存储和网络硬件，
你可以租用。节省了维护成本和办公场地，公司可以在任何时候利用这些硬件来运行其应用。&lt;/p&gt;

&lt;p&gt;一些大的IaaS公司包括Amazon, Microsoft, VMWare, Rackspace和Red Hat.不过这些公司又都有自
己的专长，比如Amazon和微软给你提供的不只是IaaS，他们还会将其计算能力出租给你来host你的网站。&lt;/p&gt;

&lt;h3 id=&#34;paas-platform-as-a-service-平台即服务&#34;&gt;PaaS: Platform-as-a-Service（平台即服务）&lt;/h3&gt;

&lt;p&gt;第二层就是所谓的PaaS，某些时候也叫做中间件。你公司所有的开发都可以在这一层进行，节省了时间和资源。&lt;/p&gt;

&lt;p&gt;PaaS公司在网上提供各种开发和分发应用的解决方案，比如虚拟服务器和操作系统。这节省了你在硬件上的费用，
也让分散的工作室之间的合作变得更加容易。网页应用管理，应用设计，应用虚拟主机，存储，安全以及应用开发协作工具等。&lt;/p&gt;

&lt;h3 id=&#34;saas-software-as-a-service-软件即服务&#34;&gt;SaaS: Software-as-a-Service（软件即服务）&lt;/h3&gt;

&lt;p&gt;第三层也就是所谓SaaS。这一层是和你的生活每天接触的一层，大多是通过网页浏览器来接入。任何一个远程服务器
上的应用都可以通过网络来运行，就是SaaS了。&lt;/p&gt;

&lt;p&gt;你消费的服务完全是从网页如Netflix, MOG, Google Apps, Box.net, Dropbox或者苹果的iCloud那里进入这些分类。
尽管这些网页服务是用作商务和娱乐或者两者都有，但这也算是云技术的一部分。&lt;/p&gt;

&lt;h2 id=&#34;二-paas&#34;&gt;二、PaaS&lt;/h2&gt;

&lt;p&gt;PaaS是Platform-as-a-Service的缩写，意思是平台即服务。把服务器平台作为一种服务提供的商业模式。
通过网络进行程序提供的服务称之为SaaS，而云计算时代相应的服务器平台或者开发环
境作为服务进行提供就成为了PaaS。&lt;/p&gt;

&lt;p&gt;所谓PaaS实际上是指将软件研发的平台作为一种服务，以SaaS的模式提交给用户。因此，PaaS也是SaaS模式的一种应用。但是，PaaS的出现可以加快SaaS的发展，尤其是加快SaaS应用的开发速度。
在2007年国内外SaaS厂商先后推出自己的PAAS平台。&lt;/p&gt;

&lt;h3 id=&#34;作用&#34;&gt;作用&lt;/h3&gt;

&lt;p&gt;PaaS之所以能够推进SaaS的发展，主要在于它能够提供企业进行定制化研发的中间件平台，同时涵盖数据库和应用服务器等。PaaS可以提高在Web平台上利用的资源数量。例如，可通过远程Web服务使用数据即服务（Data-as-a-Service：数据即服务），还可以使用可视化的API，甚至像800app的PaaS平台还允许你混合并匹配适合你应用的其他平台。用户或者厂商基于PaaS平台可以快速开发自己所需要的应用和产品。同时，PaaS平台开发的应用能更好地搭建基于SOA架构的企业应用。&lt;/p&gt;

&lt;p&gt;此外，PaaS对于SaaS运营商来说，可以帮助他进行产品多元化和产品定制化。例如Salesforce的PaaS平台让更多的ISV成为其平台的客户，从而开发出基于他们平台的多种SaaS应用，使其成为多元化软件服务供货商（Multi Application Vendor），而不再只是一家CRM随选服务提供商。而国内的SaaS厂商800app通过PaaS平台，改变了仅是CRM供应商的市场定位，实现了 BTO(Built to order:按订单生产)，和在线交付流程。使用800app的PAAS开发平台，用户不再需要任何编程即可开发包括CRM、OA、HR、SCM、进销存管理等任何企业管理软件，而且不需要使用其他软件开发工具并立即在线运行。
面向个人的EC站点(electronic commerce site)的巨头公司Amazon，把最初为了自己公司的运营用的构筑起来的系统平台，进行出租，用户可以自由选择操作系统和中间软件，以这样的方式提供硬件以及软件平台作为服务，最初被海外以一些冒险事业的企业所使用。从2006年开始 Amazon EC Amazon S3开始作为服务推向市场。&lt;/p&gt;

&lt;p&gt;还有现代软件业霸主同时又是次时代计算的先驱的Google,大家都知道在世界上构筑以及运行了非常多的数据中心。以搜索引擎以及新的广告模式而闻名。他们使用便宜的计算机和强有力的中间件，以及自己的技术装备出了世界上最强大的数据中心，以及超高性能的并行计算群。2008年4月发表的PaaS服务Google App Engine和Amazon 的 EC2,S3,SimpleDB等服务拥有相似的功能。这些稳定的平台上同样搜索引擎，GMail等服务也在运行。同样以ASP~SaaS成功的Salesforce，2007年开始用于提供SaaS的系统基盘对外公开，用Force这个名称开始进入PaaS业务。他所提供的PaaS服务里采用Java类似的语言Apex以及Eclipse开发平台，整合的开发环境也作为服务进行提供(Development as a Service)。Google/Amazon/Salesforce这三个软件巨头非常的重视PaaS这种新的商业模式，Amazon的PaaS服务为了用户可以自由的组合服务提供了更多的自由度，Google的话提供了更多的服务使用户能够方便的使用，去掉了一些繁琐的作业。Google/Salesforce的PaaS不仅是基础硬件的提供开发环境的同样被提供属于真正的平台作为一种服务(PaaS)&lt;/p&gt;

&lt;h3 id=&#34;特点&#34;&gt;特点&lt;/h3&gt;

&lt;p&gt;PaaS能将现有各种业务能力进行整合，具体可以归类为应用服务器、业务能力接入、业务引擎、业务开放平台，向下根据业务能力需要测算基础服务能力，通过IaaS提供的API调用硬件资源，向上提供业务调度中心服务，实时监控平台的各种资源，并将这些资源通过API开放给SaaS用户。PaaS主要具备以下三个特点:&lt;/p&gt;

&lt;p&gt;(1)平台即服务：PaaS所提供的服务与其他的服务最根本的区别是PaaS提供的是一个基础平台，而不是某种应用。在传统的观念中，平台是向外提供服务的基础。一般来说，平台作为应用系统部署的基础，是由应用服务提供商搭建和维护的，而PaaS颠覆了这种概念，由专门的平台服务提供商搭建和运营该基础平台，并将该平台以服务的方式提供给应用系统运营商；&lt;/p&gt;

&lt;p&gt;(2)平台及服务：PaaS运营商所需提供的服务，不仅仅是单纯的基础平台，而且包括针对该平台的技术支持服务，甚至针对该平台而进行的应用系统开发、优化等服务。PaaS的运营商最了解他们所运营的基础平台，所以由PaaS运营商所提出的对应用系统优化和改进的建议也非常重要。而在新应用系统的开发过程中，PaaS运营商的技术咨询和支持团队的介入，也是保证应用系统在以后的运营中得以长期、稳定运行的重要因素;&lt;/p&gt;

&lt;p&gt;(3)平台及服务：PaaS运营商对外提供的服务不同于其他的服务，这种服务的背后是强大而稳定的基础运营平台，以及专业的技术支持队伍。这种“平台级”服务能够保证支撑SaaS或其他软件服务提供商各种应用系统长时间、稳定的运行。PaaS的实质是将互联网的资源服务化为可编程接口，为第三方开发者提供有商业价值的资源和服务平台。有了PaaS平台的支撑，云计算[2] 的开发者就获得了大量的可编程元素，这些可编程元素有具体的业务逻辑，这就为开发带来了极大的方便，不但提高了开发效率，还节约了开发成本。有了PaaS平台的支持，WEB应用的开发变得更加敏捷，能够快速响应用户需求的开发能力，也为最终用户带来了实实在在的利益。&lt;/p&gt;

&lt;h2 id=&#34;三-开源paas平台&#34;&gt;三、开源PaaS平台&lt;/h2&gt;

&lt;p&gt;开源平台即服务（PaaS）让广大开发人员和用户可以贡献及共享源代码和扩展件。有的PaaS由厂商驱动，有的则基于标准。&lt;/p&gt;

&lt;p&gt;厂商驱动的开源PaaS让广大开发人员和用户被某家厂商牢牢锁定。说到将应用程序从厂商驱动的开源平台传送到另一个平台，开发人员在这方面的控制权很有限。&lt;/p&gt;

&lt;p&gt;基于标准的开放平台则与厂商无关，比较灵活；它旨在对生命周期管理的自动化过程的编排实现标准化。开发人员可以跨云传送应用程序。&lt;/p&gt;

&lt;p&gt;下面不妨看一下五种流行的开源平台。请注意：并非所有这些平台都与OpenStack协同运行。&lt;/p&gt;

&lt;h3 id=&#34;厂商驱动的开源paas&#34;&gt;厂商驱动的开源PaaS&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Cloud Foundry&lt;/strong&gt;（原先由VMware开发）从广大Ruby开发人员和用户处获得源代码。这个开源PaaS允许人们将信息系统部署到OpenStack、亚马逊网络服务（AWS）、vSphere、vCloud Air和vCloud Director。Cloud Foundry提供的主机托管服务包括：MySQL（可用于开发SaaS应用程序）、MongoDB（一种NoSQL数据库）和RabbitMQ（以异步方式连接应用程序的消息代理）。为了简化任务，PaaS开发人员获得诸多工具，比如命令行工具、Eclipse插件、构建整合工具以及应用程序扩展工具。与Cloud Foundry竞争的平台还有AppScale、Heroku、OpenShift和谷歌应用引擎（Google App Engine）。注意：2014年12月9日，Cloud Foundry基金会宣布，它将作为一个Linux基金会协作项目来加以管理。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;OpenShift&lt;/strong&gt;（红帽）在私有云（OpenShift Enterprise）、公有云（OpenShift Online）和上游社区（通过OpenShift Origin项目）中运行。OpenShift托管运行MySQL和MongoDB；OpenShift支持的其他数据库包括PostgreSQL和微软SQL。这个开源PaaS在红帽企业级Linux上运行，为你提供了一套客户（命令）工具集。你可以使用JavaScript、Ruby、Python、PHP、Perl和Java。OpenShift在OpenStack上运行。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Stackato&lt;/strong&gt;（ActiveState）是基于Cloud Foundry的PaaS。你可以从Stackato的应用程序商店选择开源项目，而不是贡献源代码。你可以浏览用各种语言和框架编写而成的众多开源项目。为了快速部署，你只要点击某个项目。&lt;/p&gt;

&lt;p&gt;如果你很好奇，可以查看某个项目的源代码，看看它是如何构建的。你可以决定是定制项目，还是使用自己的应用程序。&lt;/p&gt;

&lt;p&gt;Stackato有三个版本可用：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Stackato Micro Cloud&lt;/strong&gt;：假设你想把应用程序部署到桌面虚拟机上，或者在亚马逊EC2沙盒上试一试Micro Cloud。你仅限于4 GB内存、单一节点和基于社区的支持。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Stackato Cluster&lt;/strong&gt;：假设你是小型团队的负责人，想构建小型集群，把应用程序部署到自己的基础设施上或公有云上。你仅限于20 GB内存和基于社区的支持。你想要多少个节点，就可以有多少个节点。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Stackato Enterprise&lt;/strong&gt;：假设贵企业想把应用程序部署到虚拟机管理程序或基础设施即服务（IaaS）上，同时可充分利用自动扩展的优点。它提供了配置和生产支持，有服务级别协议（SLA）作为保障。&lt;/p&gt;

&lt;p&gt;你可以将Stackato与OpenStack、vSphere、CloudStack、XenServer、KVM、HP Cloud Services和AWS结合使用。&lt;/p&gt;

&lt;p&gt;2013年6月，Apache Stratos（由WSO2捐献）作为一种开源PaaS捐献给了Apache。它可以与许多应用服务器、数据库、语言、甚至遗留系统协同运行。你可以设置分区来控制IaaS资源。WSO2 App Factory可以帮助你加快PaaS上的生命周期迭代。&lt;/p&gt;

&lt;p&gt;这个平台的贡献者包括来自SUSE、思科、思杰、美国宇航局喷气推进实验室（JPL）、Sungard和Engine Yard的开发人员。你可以将Stratos与AWS、OpenStack和vCloud结合使用。、&lt;/p&gt;

&lt;h3 id=&#34;基于标准的开源paas&#34;&gt;基于标准的开源PaaS&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Cloudify&lt;/strong&gt;（GigaSpaces）基于OASIS TOSCA（云应用程序的拓扑结构和编排规范）的草案版本。这项与厂商无关的标准的技术委员会成立于2012年。标准的发起者包括冠群、华为、IBM、NetApp、红帽和SAP。&lt;/p&gt;

&lt;p&gt;这项标准并不依赖任何一家厂商的技术（比如虚拟机管理程序虚拟化）就可以运行开源PaaS；它描述应用程序的拓扑结构是工作流程的基础，工作流程反过来充当策略的基本构建模块。&lt;/p&gt;

&lt;p&gt;该标准可以处理开发人员手动执行下列任务时所犯的严重错误：&lt;/p&gt;

&lt;p&gt;设置监控警报；&lt;/p&gt;

&lt;p&gt;执行部署策略；&lt;/p&gt;

&lt;p&gt;收集并分析日志；以及对照SLA中的服务可用性保障，衡量性能。&lt;/p&gt;

&lt;p&gt;为了消除人员的干预工作，该标准旨在帮助PaaS开发人员将生命周期实现自动化，包括跨云的部署、扩展、补丁、监控和补救。构建并使用开发人员可以使用的云服务模块库，就能实现自动化。&lt;/p&gt;

&lt;p&gt;你可以使用PaaS来测试自动化和编排流程执行起来多顺畅。Cloudify可以在OpenStack、AWS、CloudStack、微软Azure和VMware上实现自动部署。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>深入CloudFoundry一周年（转载）</title>
      <link>/post/cloudfoundry/</link>
      <pubDate>Wed, 24 Jun 2015 22:05:33 +0800</pubDate>
      
      <guid>/post/cloudfoundry/</guid>
      <description>&lt;p&gt;本文转自&lt;a href=&#34;http://ju.outofmemory.cn/entry/22259&#34;&gt;深入CloudFoundry一周年（原版）&lt;/a&gt;，有些地方稍微做些修改，毕竟是几年前的文章了。&lt;/p&gt;

&lt;h2 id=&#34;篇前语&#34;&gt;篇前语&lt;/h2&gt;

&lt;p&gt;本文在《程序员》杂志2013年1月刊刊登过，但由于篇幅排版等原因，部份内容被删除。研究院博客这次发表的版本是原稿版。可能文笔措辞有些许粗糙，但希望能给大家带来更详尽的信息。&lt;/p&gt;

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;2012年4月份，VMware突然发布了业内第一个开源的PaaS，Cloud Foundry；紧接着5月，Redhat发布了另外一个开源的PaaS，OpenShift。从此PaaS不再神秘，开始成为技术圈内的热议话题。我们研究院在CloudFoundry发布时就开始投入研究，在实验室内部署了基于Cloud Foundry私有的PaaS。到了10月份，我们总结部份研究成果，整理成博客发表在研究院的轻微博上。&lt;/p&gt;

&lt;p&gt;Cloud Foundry经过一年多的发展，文章内很多内容都已经不合时宜，这篇一周年特别版的结构重新整理，文章内容部份借鉴我的同事颜开所写的《新版CloudFoundry揭秘》以及一些同行的文章、演讲进行改写；加入部份笔者在OpenStack APAC会议上所作报告《ElasticArchitecture in Cloud Foundry and Deploy with OpenStack》内容，而CloudFoundry的安装配置、扩展运行时、自定义服务等内容，本专栏会有后续专文介绍，这里就不再重复。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;正文&#34;&gt;正文&lt;/h2&gt;

&lt;h3 id=&#34;一-什么是paas&#34;&gt;一、什么是PaaS？&lt;/h3&gt;

&lt;p&gt;PaaS这个话题已经不再新鲜，但是与云计算的其他概念一样，让人感觉云里雾里的。在所有让人摸不着头脑的定义里面，笔者最喜欢下面这张EMC World 2012展示的图，它从使用角度介绍了PaaS的含义。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/iaas-paas.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;从开发者的角度来看，如果我们开发了一个应用程序，需要部署。传统的IT需要为你准备网络、存储、服务器、虚拟化、操作系统、中间件、应用运行环境等一系列设施；而如果你的企业上了IaaS，例如OpenStack，那这些IaaS套件就会帮你把网络到操作系统全包办了，你可以避免走冗长的流程去申请机器，公网IP的这些活；但是这时还没完，因为IaaS只能帮你到给你若干台装好Linux或者Windows，但是你不能按需得到运行环境，也不可以在资源不够的时候把你的应用进行横向扩展，而PaaS就接管剩下的工作，为你提供中间件和运行环境。在企业上了PaaS后，开发者只需要管理自己的应用及应用数据即可，所有设施相关的都可以包办给PaaS平台。这里可以看到三点：&lt;/p&gt;

&lt;p&gt;1、PaaS基于IaaS之上的；&lt;/p&gt;

&lt;p&gt;2、PaaS为应用开发者提供中间件及运行环境；&lt;/p&gt;

&lt;p&gt;3、PaaS管理应用的部署，扩展等生命周期。&lt;/p&gt;

&lt;p&gt;其实上面第三点很重要，如果没有第三点，IaaS也可以通过一些技巧提供中间件和运行环境。譬如我有一个Ruby on Rails的应用，需要用到Mysql，那系统管理员完全可以把Ruby环境和Mysql集成到IaaS的模板里面。但是这样的设计无法满足下面的场景：我目前应用有10个节点，由于访问压力增加，应用资源不够了，现需要动态增加为20个节点，但我提供的服务不可以接受中断。&lt;/p&gt;

&lt;p&gt;当然，一定要较真的话，结合一些DevOp的知识也可以做到，但开发这些DevOp的脚本可以认为是一个最小化的PaaS了。&lt;/p&gt;

&lt;h3 id=&#34;二-paas的基本架构&#34;&gt;二、PaaS的基本架构&lt;/h3&gt;

&lt;p&gt;为了抽象出，PaaS的架构，我们先来看看下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/cloudfoundry.png&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;/img/heroku.jpg&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;/img/openshift.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这是三个非常著名的PaaS平台的高层架构图，从上到下分别是：CloudFoundry，Heroku和OpenShift。每个个架构图，笔者都加了两条分隔线，我们可以看到它们拥有相似的三层架构：&lt;/p&gt;

&lt;p&gt;a)  Router，主要负责找到相对硬的App访问点。在Heroku中叫做Routing Mesh，在OpenShift中叫做HA Proxy；&lt;/p&gt;

&lt;p&gt;b)  App的运行容器，它必须是同构可互相替代的。在CloudFounry中叫作App Exec Engine，也就是下文所说的DEA，在Heroku中叫Dyna Grid，在OpenShift中就是上图画有”PHP”的gear；&lt;/p&gt;

&lt;p&gt;c)  系统服务节点。&lt;/p&gt;

&lt;p&gt;PaaS主要为了大规模访问而设计，所以要求每一层都支持Failover，也就是说任何一个部份都有多节点运行，任何一个节点都可以挂掉，但要求其他的同组件节点可以替代已挂节点的工作；每一个层都可以扩展，以满足大并发需求；资源非独占性，如果某一组件资源有富裕，可以回收资源供给其他组件使用。后面两点就是我们常说的弹性。后文我们将可以看到CloudFoundry是如何做到以上几点的。&lt;/p&gt;

&lt;h3 id=&#34;三-cloudfoundry的架构及模块&#34;&gt;三、CloudFoundry的架构及模块&lt;/h3&gt;

&lt;p&gt;从总体地看，CloudFoundry的架构如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/cloudfoundry2.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如果看过《深入CloudFoundry》原文，我们可以发现CloudFoundry的组件增加了很多。但是它的核心组件并没有变化，增加的组件可以认为是原架构基础上的细化和专门化。譬如Stager组件是为了解决打包（Stage）过程需要操作大量文件，操作时间长的问题。所以Stager模块作为独立进程，接受这些工作逐个运行，而不阻塞作为核心组件的CloudController。&lt;/p&gt;

&lt;p&gt;CloudFoundry的核心组件有：&lt;/p&gt;

&lt;p&gt;1、Router：顾名思义，Router组件在CloudFoundry中是对所有进来的Request进行路由。进入Router的request主要有两类：首先是来自VMC Client或者STS的，由CloudFoundry使用者发出的，管理型指令。例如：列出你所有apps的vmc apps，提交一个apps等等。这类request会被路由到App Life Management组件，又叫Cloud Controller组件去；第二类是外界对你所部署的apps访问的request。这部份requests会被路由到App execution，又或者叫做DEAs的组件去。所有进入CloudFoundry系统的requests都会经过Router组件，看到这里可能会有朋友会担心Router成为单点，从而成为整个云的瓶颈。但是CloudFoundry作为云系统，其设计的核心就是去单点依赖，组件平行扩充，且可替代的以保证扩展性，这是CloudFoundry，甚至所有云计算系统的设计原则，后文会讨论CloudFoundry如何做到这点，目前只要知道，系统可以部署多个Routers共同处理进来的requests，但是Router上层的Load Balance不在CloudFoundry的实现范围，CloudFoundry只保证所有的request是无状态的，这样就使上层均衡附载选择面非常非常大了，例如可以通过DNS做，也可以部署硬件的Load Balancer，或者简单点，弄台ngnix作负载均衡器，都是可行的。&lt;/p&gt;

&lt;p&gt;在第一个版本中，Router作为一个nginx脚本存在。所以的请求都必须经过Ruby代码，然后加以转发。这个设计干净利落，不过Ruby也因此转发了大量的数据，容易引起性能问题，所以在新版本中做了如下的改进（左边为第一版本，右边为新版）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/cloudfoundry3.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;a)  使用Nginx的Lua扩展，在Lua中加入URL查询逻辑和统计逻辑；&lt;/p&gt;

&lt;p&gt;b)  如果Lua不知道当前的URL应该对应到底下哪一个DEA，则会发一个Request到router_uls_server.rb（也就是上图的”Upstream LocatorSVC”）；&lt;/p&gt;

&lt;p&gt;c)  router_uls_server.rb是一个简单的Sinatra应用，它存储了所有URL与DEA IP:Port对应数据。另外它也管理了访问Session数据（这个后面会说）。&lt;/p&gt;

&lt;p&gt;这样一来，大量的业务请求在Lua查询过一次位置后，变成了nginx直连下属业务，而不再经过router。逻辑和数据完美分离。性能和稳定性都大幅提高了。&lt;/p&gt;

&lt;p&gt;另外一个大改进在于在前版设计中，当Router接收到请求后，会随机分配一个Droplet来处理这个请求，这种方式使得用户没有办法使用Session，因为连续的HTTP请求会被分发到不同的应用实例上处理。新版本设计中增加了对SESSION的支持，当Router发现用户的请求中带了cookie信息，它会在Cookie里暗藏一个Droplet的host, port地址。当有新的请求进来，Router通过解析Cookie得到上次的应用实例，然后尽量转发到同一台Droplet上。而这部份信息与上面的查询类似，会先存在于router_uls_server.rb，当Lua知道后会保存在Nginx内部提高效率。&lt;/p&gt;

&lt;p&gt;还有一点可以利用的是，router_uls_server.rb作为一个基于Sinatra的服务，并且知道PaaS内所有映射、会话关系，是我们二次开发一个很有用的切入点。&lt;/p&gt;

&lt;p&gt;2、DEA (Droplet ExecutionAgent): 首先要解析下什么叫做Droplet。Droplet在CloudFoundry的概念里面是指一个把你提交的源代码，以及CloudFoundry配套好的运行环境，再加上一些管理脚本，例如Start/Stop这些小脚本全部压缩好在一起的tar包。还有一个概念，叫做Staging app，就是指制作上面描述这个包，然后把它存储好的过程。CloudFoundry会自动保存这个Droplet，直到你start一个app的时候，一台部署了DEA模块的服务器会来拿一个Droplet的copy去运行。所以如果你扩展你的app到10个instances，那这个Droplet就被会复制十份，让10个DEA服务器拿去运行。&lt;/p&gt;

&lt;p&gt;下图是DEA模块的新架构图（左编为原版，右边为新版）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/cloudfoundry4.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;当CloudFoundry刚刚推出的时候， Droplet包含了应用运行时启动，停止等简单命令。用户应用可以随意访问文件系统，也可以在内网畅通无阻，跑满CPU，占尽内存，写满磁盘。你一切可以想到的破坏性操作都可以做到，太可怕了。CloudFoundry显然不会放任这样的情况太久，现在他们开发出了Warden，一个程序运行容器。这个容器提供了一个孤立的环境，Droplet只可以获得受限的CPU,内存，磁盘访问权限，网络权限，再没有办法搞破坏了。&lt;/p&gt;

&lt;p&gt;Warden在Linux上的实现是将Linux 内核的资源分成若干个namespace加以区分，底层的机制是CGROUP。这样的设计比虚拟机性能好，启动快，也能够获得足够的安全性。在网络方面，每一个Warden实例有一个虚拟网络接口，每个接口有一个IP，而DEA内有一个子网，这些网络接口就连在这个子网上。安全可以通过iptables来保证。在磁盘方面，每个warden实例有一个自己的filesystem。这些filesystem使用aufs实现的。Aufs可以共享warden之间的只读内容，区分只写的内容，提高了磁盘空间的利用率。因为aufs只能在固定大小的文件上读写，所以磁盘也没有出现写满的可能性。&lt;/p&gt;

&lt;p&gt;LXC是另一个LinuxContainer。那为什么不使用它，而开发了Warden呢。因为LXC的实现是和Linux绑死的，CloudFoundry希望warden能运转在各个不同的平台，而不只是Linux。另外Warden提供了一个Daemon和若干Api来操作，LXC提供的是系统工具。还有最重要的一点是LXC过于庞大，Warden只需要其中的一点点功能就可以了，更少的代码便于调试。&lt;/p&gt;

&lt;p&gt;除了增加隔绝性外，DEA的基本运行原理并没有发生根本改变：Cloud Controller模块（下面会介绍）会发送start/stop等基本的apps管理请求给DEA，dea.rb接收这些请求，然后从NFS里面找到合适的Droplet。前面说到Droplet其实是一个带有运行脚本的，带运行环境的tar包，DEA只需要把它拿过来解压，并即行里面的start脚本，就可以让这个app跑起来。到此，app算是可以访问，并start起来了，换句话说就是有这台服务器的某一个端口已经在待命，只要有request从这个端口进来，这个app就可以接收并返回正确的信息。接着dea.rb要做些善后的工作：1、把这个信息告诉Router模块。我们前面说到，所有进入CloudFoundry的requests都是由Router模块处理并转发的，包括用户对app的访问request，一个app起来后，需要告诉router，让它根据load balance等原则，把合适的request转进来，使这个app的instance能够干起活；2、一些统计性的工作，例如要把这个用户又新部署了一个app告诉Cloud Controller，以作quota控制等；3、把运行信息告诉Health Manager模块，实时报告该app的instance运行情况。另外DEA还要负责部份对Droplet的查询工作，譬如，如果用户通过Cloud Controller想查询一个app的log信息，那DEA需要从该Droplet里面取到log返回等等。&lt;/p&gt;

&lt;p&gt;3、CloudController:  Cloud Controller是CloudFoundry的管理模块。主要工作包括：&lt;/p&gt;

&lt;p&gt;a)  对apps的增删改读；&lt;/p&gt;

&lt;p&gt;b)  启动、停止应用程序（通过DEA）；&lt;/p&gt;

&lt;p&gt;c)  Stagingapps（把apps打包成一个droplet，通过Stager）；&lt;/p&gt;

&lt;p&gt;d)  修改应用程序运行环境，包括instance、mem等等；&lt;/p&gt;

&lt;p&gt;e)  管理service，包括service与app的绑定等；&lt;/p&gt;

&lt;p&gt;f)  Cloud环境的管理；&lt;/p&gt;

&lt;p&gt;g)  修改Cloud的用户信息（通过UAA，ACM）；&lt;/p&gt;

&lt;p&gt;h)  查看CloudFoundry，以及每一个app的log信息。&lt;/p&gt;

&lt;p&gt;这似乎有点复杂，但简单的说，可以很简单：就是与VMC和STS交互的服务器端。VMC和STS与CloudFoundry通信采用的是restful接口，另一方面Cloud Controller是一个典型的Ruby on Rails项目，从VMC或者STS接到JSON格式的协议，然后写入Cloud ControllerDatabase，并发消息到各模快去控制管理整个云。&lt;/p&gt;

&lt;p&gt;我们以部署一个App到CloudFoundry为例，在我们在敲完那条简单的push命令后，VMC开始工作，在做完一轮的用户鉴权、查看所部署的apps数量是否超过预定数额，问了一堆相关app的问题后，需要发4个指令：&lt;/p&gt;

&lt;p&gt;a)  发一个POST到“apps”，创建一个app;&lt;/p&gt;

&lt;p&gt;b)  发一个PUT到“apps/:name/application”，上传app;&lt;/p&gt;

&lt;p&gt;c)  发一个GET到“apps/:name/”，取得app状态，看看是否已经启动；&lt;/p&gt;

&lt;p&gt;d)  如果没有启动，发一个PUT到“apps/:name/”，使其启动。&lt;/p&gt;

&lt;p&gt;第一版的CloudController是基于Ruby On Rails的，在新版中，为了与CloudFoundry其他模块一致，并且让架构更加简单，CloudController用Sinatra进行了重写，并且加入了更多的模块去细化CloudController的工作。&lt;/p&gt;

&lt;p&gt;另外一个重要的改进是，第一个版本的Droplet是通过NFS共享的，但这样会带来安全、性能等问题，而新版中进行了两大改进：&lt;/p&gt;

&lt;p&gt;a)  移除NFS，采用自己开发的，简单的blobstore来存放Droplet;&lt;/p&gt;

&lt;p&gt;b)  为Ruby项目进行了优化，把常用的Gem保存在package cache里面。所以在打包Ruby项目的时候不需要到公网上下载Gem文件，而是从CloudFoundry内部的Cache获得，大大加速了Stage过程。&lt;/p&gt;

&lt;p&gt;随着CloudFoundry的逐渐成熟，权限管理功能在新的版本进行了很大的加强，在原有的用户模型基础上，加入了组织、用户空间的概念。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/cloudfoundry5.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;用户模型的认证是由UAA模块实现的，它可以与企业已有的认证系统进行整合，例如LDAP，CAS等；鉴权是由ACM模块实现的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/cloudfoundry6.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;上图示例了一个用户访问CloudController的API的过程。我们可以分别看到UAA与ACM模块在一套鉴权流程各自扮演的角色。&lt;/p&gt;

&lt;p&gt;UAA与ACM需要展开的内容很多，碍于篇幅原因，这里就不展开介绍了，有兴趣的朋友可以参考：&lt;a href=&#34;/img/https://github.com/cloudfoundry/uaa/tree/master/docs&#34;&gt;UAA&lt;/a&gt;可能研究院后续会有专门的博客介绍相关技术。&lt;/p&gt;

&lt;p&gt;4、Health Manager: 做的事情不复杂，简单的说是从各个DEA里面拿到运行信息，然后进行统计分析，报告等。统计数据会与CloudController的设定指标进行比对，并提供Alert等。Health Manager模块目前还不是十分完善，但是Cloud Manage栈里面，自动化health管理、分析是一个很重要的领域，而这方面可以扩展的地方也很多，结合Orchestration Engine可以使云自管理、自预警；而与BI方面技术结合，可以统计运营情况，合理分配资源等。这方面CloudFoundry还在发展之中。&lt;/p&gt;

&lt;p&gt;5、Services: 服务从上文的PaaS三层模型来看属于第三层，Cloud Foundry把Service模块设计成一个独立的、插件式的模块，第三方可以方便把自己的服务整合成Cloud Foundry服务。在Github上与服务相关，主要关注两个子项目：&lt;/p&gt;

&lt;p&gt;a) vcap-services-base：顾名思义，包括Cloud Foundry服务的框架及核心类库。如果开发自定义的服务，我们需要引用到里面的类；&lt;/p&gt;

&lt;p&gt;b) vcap-services：目前Cloud Foundry支持的，包括官方及大部份第三方贡献的服务。这个项目的根文件目录是以服务名称分的，我们可以选择感兴趣的去分别研究。&lt;/p&gt;

&lt;p&gt;由此可见，Service模块的设计十分方便第三方提供自定义服务。从架构来说， Cloud Foundry服务部份使用了模板方法设计模式，我们通过重写钩子方法来实现自己的服务，如果不需要特别逻辑可以使用默认方法。从客户输入VMC命令开始，一个完整的服务访问流程如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/cloudfoundry7.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;a)  开发人员通过VMC创建一个Service;&lt;/p&gt;

&lt;p&gt;b)  VMC把其转为Restful接口到CloudController；&lt;/p&gt;

&lt;p&gt;c)  CloudController通过Restful接口发送创建命令到Service Gateway；&lt;/p&gt;

&lt;p&gt;d)  ServiceGateway通过NAT（下文会提到）发送provision命令道Service Node；&lt;/p&gt;

&lt;p&gt;e)  ServiceNode创建Service；&lt;/p&gt;

&lt;p&gt;f)  Service Node把返回创建的Service访问方法回Service Gateway；&lt;/p&gt;

&lt;p&gt;g)  ServiceGateway返回访问方法到CloudController；&lt;/p&gt;

&lt;p&gt;h)  CloudController把创建的Service访问放法注入到应用运行环境；&lt;/p&gt;

&lt;p&gt;i)  最终用户可以直接访问其服务。&lt;/p&gt;

&lt;p&gt;现实情况中，种种原因使有些系统服务难以，或者不愿意迁移到云端，为此Cloud Foundry 引入了Service Broker模块。&lt;/p&gt;

&lt;p&gt;Service Broker可以使部署在Cloud Foundry上的应用可以访问本地的服务。ServiceBroker的使用方法如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/cloudfoundry8.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;a)  我们必须准备好系统,例如postgress。我们配置好程序和防火墙，让CloudFoundry能通过类似postgres://xyzhr:secret@db.xyzcorp.com:5432/xyz_hr_db 的URL来访问到服务。&lt;/p&gt;

&lt;p&gt;b)  调用create service，系统会在ServiceBroker中记录你的配置信息。这样就算大功告成了。Bind和其他的过程都有ServiceBroker完成，其实仅仅就是记录信息，没有实际操作。使用这个新的Service的时候和使用CloudFoundry的内部Service没有两样，配置参数都会通过环境变量传入。所以当App访问Service的时候，就与ServiceBroker无关了。&lt;/p&gt;

&lt;p&gt;对应上面的Service流程，Service Broker的访问流程如下，这里就不重复叙述了：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/cloudfoundry9.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;6、NATS (Message bus)：&lt;/p&gt;

&lt;p&gt;CloudFoundry的架构是基于消息发布与订阅的，联系各模块的是一个叫nats的组件。NATS是由CloudFoundry的架构师Derek开发的一个基于事件驱动的轻量级支持发布、订阅机制的消息系统。它基于EventMachine开发，以事件驱动。第一版本CloudFoundry被人诟病的一个问题就是NATS服务器是单节点，性能方面从实际应用情况看，是让人满意的；但HA方面的问题难以避免，成为整套系统HA的软肋。但新版NATS终于支持多服务器节点，NATS服务器间通过THIN来做通信。NATS的Github开源地址是：&lt;a href=&#34;https://github.com/derekcollison/nats&#34;&gt;NATS&lt;/a&gt;。代码量不多但设计很精妙，推荐下载来慢慢研究。&lt;/p&gt;

&lt;p&gt;CloudFoundry作为一个弹性设计的，多模块的分布式系统，且支持模块自发现，错误自检，保证模块间低耦合。其根本原理就是基于消息发布订阅机制构建。每台服务器上的每个模块会根据自己的消息类别，向Message Bus发布多个消息主题；而同时也向自己需要交互的模块，按照需要的信息内容的消息主题订阅消息。&lt;/p&gt;

&lt;p&gt;如前所说，CloudFoundry的核心是一套消息系统，如果想了解CloudFoundry的来龙去脉，去跟踪它里面复杂的消息机制是非常好的方法。譬如：一个DEA被加入CloudFoundry集群中，它需要向大家吼一下，以表明它已经准备好服务了，它会发布一个主题是”dea.start”的消息：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;NATS.publish(&#39;dea.start&#39;,@hello_message_json)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;@ hello_message_json中包括DEA的UUID, ip, port, 版本信息等内容。&lt;/p&gt;

&lt;p&gt;再例如，Cloud Controller需要启动一个Droplet的instance：&lt;/p&gt;

&lt;p&gt;a)  首先一个DEA在启动的时候，会首先会对自己UUID的消息主题进行订阅。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;NATS.subscribe(&amp;quot;dea.#{uuid}.start&amp;quot;){ |msg| process_dea_start(msg) }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其他模块需要通过&amp;rdquo;dea.#{uuid}.start&amp;rdquo;这个主题发送消息来使它启动，一旦这个DEA接收到消息，就会触发process_dea_start(msg)这个方法来处理启动所需要的工作；&lt;/p&gt;

&lt;p&gt;b)  Cloud Controller或者其他模块发送消息，让UUID为xxx的DEA启动。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;NATS.publish(&amp;quot;dea.#{dea_id}.start&amp;quot;,json)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;c)  DEA模块接收到消息后，就会触发process_dea_start(msg)方法。msg是由其他模块发送过来的消息内容，包括：droplet_id, instance_index, service, runtime等内容，process_dea_start会取得这些启动DEA必须的信息，然后进行一系列操作，例如从NFS中取得Droplet，解压，修改必要环境配置，运行启动脚本等等。等一切都准备好后，然后需要给Router发个消息，告诉它这个Droplet已经随时准备好报效国家，以后有相应的request记得让它来处理。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;NATS.publish(&#39;router.register&#39;,{

:dea =&amp;gt; VCAP::Component.uuid,

:host =&amp;gt; @local_ip,

:port =&amp;gt; instance[:port],

:uris =&amp;gt; options[:uris] ||instance[:uris],

:tags =&amp;gt; {:framework =&amp;gt;instance[:framework], :runtime =&amp;gt; instance[:runtime]}

                        }.to_json)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;d)  Router模块在启动时就已经订阅”router.register”消息主题，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;NATS.subscribe(&#39;router.register&#39;){ |msg|

msg_hash = Yajl::Parser.parse(msg,:symbolize_keys =&amp;gt; true)

return unless uris = msg_hash[:uris]

uris.each{|uri|register_droplet(uri,msg_hash[:host],msg_hash[:port],msg_hash[:tag 

s]) }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;收到前面DEA发出的信息后，会触发register_droplet方法，去绑定Droplet。到此启动一个Droplet的instance工作完成。&lt;/p&gt;

&lt;p&gt;CloudFoundry的架构简单介绍至此，其实作为第一款开源的PaaS，CloudFoundry架构有很多可以学习借鉴的地方，很多细节上的处理是很精妙的，本文题虽为深入CloudFoundry，其实也只是浅尝即止，如果真要做到深入恐怕上面提到的每个模块都需要立篇详谈。一年后的今天重新审视CloudFoundry的学习资料，已经很丰富，网上有很多牛人已经写了很多东西探讨CloudFoundry的架构，文章最后笔者会给大家推荐个人觉得比较好的一些中文资料。总结一下，笔者从CloudFoundry的结构中学到的东西：&lt;/p&gt;

&lt;p&gt;1、基于消息的多组件架构是实现集群的简单、且有效方法。消息可以使集群节点间解耦，使自注册，自发现这些在大规模数据中心中很重要的功能得到实现；&lt;/p&gt;

&lt;p&gt;2、适当的抽象层，模板模式的使用，方便第三方可以方便在CloudFoundry开发扩展功能。CloudFoundry在DEA及Service层都做了抽象层处理，相对应地使开发者可以容易地为CloudFoundry开发Runtime和Service。例如，在CloudFoundry刚推出的时候，只支持Node.js, Java, Ruby，但第三方提供商、开源社区快速跟进，为CloudFoundry添加了PHP, Python的支持。这得益于CloudFoundry精巧的DEA架构设计。&lt;/p&gt;

&lt;h3 id=&#34;四-安装配置cloudfoundry&#34;&gt;四、安装配置CloudFoundry&lt;/h3&gt;

&lt;p&gt;写《深入CloudFoundry》的时间比较早，那时候连dev_setup都没有，更不用说更为先进的、适合大规模部署CloudFoundry使用的BOSH。原文介绍的是如何通过理解CloudFoundry各模块的关系，通过手工配置安装CloudFoundry的，笔者认为那依然是让我们理解CloudFoundry工作原理的最好方法，而且过程很有乐趣，就如我们在习惯了使用自动相机“咔嚓”一下的时候，如果有机会把玩一些老相机，躲进暗房尝试自己冲洗银盐底片，那种感受是难以言表的。&lt;/p&gt;

&lt;p&gt;CloudFoundry是一个PaaS，前面讨论到PaaS是基于IaaS之上的，上面CloudFoundry的部署指南是以vSphere作为IaaS。但是无论是CloudFoundry本身，还是部署工具BOSH的设计都是以IaaS不相关的。正如一年前那篇《深入CloudFoundry》所说，我们可以用OpenStack作为CloudFoundry的PaaS层。而CloudFoundry后来出现的部署系统BOSH也和我们想得不谋而合，它对IaaS层做了一层抽象，叫做CPI（Cloud Provider Interface）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/cloudfoundry10.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;而CPI里面就有专门为OpenStack准备的，叫做Piston，开源地址在：&lt;a href=&#34;https://github.com/piston/openstack-bosh-cpi&#34;&gt;Piston&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;如果从整体角度去理解BOSH ，其实可以发现这里面很简单。我们需要部署CloudFoundry，BOSH要做几件事情？&lt;/p&gt;

&lt;p&gt;a)  向IaaS要一台虚拟机，导入image文件；&lt;/p&gt;

&lt;p&gt;b)  向IaaS要存储空间，并attach到虚拟机上；&lt;/p&gt;

&lt;p&gt;c)  配置这台虚拟机的网络，使它可以和其他CloudFoundry服务器相通；&lt;/p&gt;

&lt;p&gt;d)  在这台虚拟机里面下载安装CloudFoundry的代码；&lt;/p&gt;

&lt;p&gt;e)  配置CloudFoundry组件间的消息机制。&lt;/p&gt;

&lt;p&gt;这里与IaaS相关的，就是a), b), c)三点，如果我们回到第一章什么是PaaS那张图来看，提供网络、存储、服务器，以及image中带有的OS就是IaaS所给我们提供的内容。而如果看过《深入CloudFoundry》原文说过，由于由于CloudFoundry是完全模块化设计的，基于消息机制的分布式系统，所以安装配置CloudFoundry就是把每个模块单独跑起来，然后配置其消息机制，也就是上面的d),e)两点。&lt;/p&gt;

&lt;p&gt;我们回到BOSH，显而易见，CPI作为IaaS的facade，需要提供相对应的接口。任何一个IaaS，只需要实现以下接口即可以支持BOSH，并用来部署CloudFoundry：&lt;/p&gt;

&lt;p&gt;a)  create_stemcell&lt;/p&gt;

&lt;p&gt;b)  delete_stemcell&lt;/p&gt;

&lt;p&gt;c)  create_vm&lt;/p&gt;

&lt;p&gt;d)  delete_vm&lt;/p&gt;

&lt;p&gt;e)  reboot_vm&lt;/p&gt;

&lt;p&gt;f)  configure_network&lt;/p&gt;

&lt;p&gt;g)  create_disk&lt;/p&gt;

&lt;p&gt;h)  delete_disk&lt;/p&gt;

&lt;p&gt;i)  attach_disk&lt;/p&gt;

&lt;p&gt;j)  detach_disk&lt;/p&gt;

&lt;p&gt;stemcell可以认为是我们常说的image，或者说是模板，。根据函数名，我们基本能知道每个接口的作用了吧？我们可以看到是和我们上面说的a), b), c)相对应的。&lt;/p&gt;

&lt;p&gt;不少公司，都已经搭了自己的虚拟化平台，如这次笔者参加QCon，国内某著名电子商务公司内部就用LXC构建了一套虚拟化平台。如果他们再写个接口，暴露出上面10个接口，同样可以用来部署CloudFoundry。&lt;/p&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;开篇的时候，笔者原本只想对原文进行适当的修改，没想到一年过去了，CloudFoundry发生了太多改变，全文基本都已经重写，可见这一年来CloudFoundry社区的活跃。这篇文章属于新旧参半，如篇前所述，更多的是希望能把CloudFoundry的原理讲明白，讲得简单，请不要把本文作为参考手册使用。&lt;/p&gt;

&lt;p&gt;其实一年多来，CloudFoundry在国内已经很火，下面推荐一些自己觉得好，在写本文时参考过的资料：&lt;/p&gt;

&lt;p&gt;1、&lt;a href=&#34;http://cndocs.cloudfoundry.com/getting-started.html&#34;&gt;CloudFoundry中文技术文档&lt;/a&gt; （该网站好像已经打不开了）。现在CloudFoundry的文档化做得相当不错，尤其是部署云平台部份，本文多次引用提及；&lt;/p&gt;

&lt;p&gt;2、@柳烟堆雪 的&lt;a href=&#34;http://blog.csdn.net/resouer/article/details/8065795&#34;&gt;《以NATS为主线的CloudFoundry原理》&lt;/a&gt;。很好的一篇文章，可惜他发表时，本文已经写完，否则本文一定会有汲取不少养分；&lt;/p&gt;

&lt;p&gt;3、&lt;a href=&#34;http://www.54chen.com/?s=cloud+foundry&#34;&gt;著名博客五四科学院的CloudFoundry代码解读系列&lt;/a&gt;；&lt;/p&gt;

&lt;p&gt;4、EMC中国研究院研究员颜开的&lt;a href=&#34;http://www.chinacloud.cn/show.aspx?id=9966&amp;amp;cid=11&#34;&gt;《新版CloudFoundry揭秘》&lt;/a&gt;。因为是同事，本文大段大段地拷他的这篇文章；&lt;/p&gt;

&lt;p&gt;5、Cloudfoundry.org博客。另外要推荐的是Cloudfoundry.org的博客，我们知道Cloudfoundry的博客分.COM上的与.ORG上的，.COM上的大多是偏商业及应用，而.ORG的博客才是个牛人的园地；&lt;/p&gt;

&lt;p&gt;代码还是代码。不用多说，作为一个开源项目，有什么比代码更直观？！&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C语言可变参数</title>
      <link>/post/c-args/</link>
      <pubDate>Wed, 17 Jun 2015 22:01:25 +0800</pubDate>
      
      <guid>/post/c-args/</guid>
      <description>&lt;p&gt;在python中写一个有可变参数的函数或者方法是很容易的，比如下面这个例子:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def print_args(*args, **kwargs):
	print type(args), args
	print type(kwargs), kwargs
	for arg in args:
		print arg
	for arg, value in kwargs.items():
		print &#39;%s = %s&#39; % (arg, value)

&amp;gt;&amp;gt;&amp;gt; print_args(1, 2, 3, x=4, y=5)
&amp;lt;type &#39;tuple&#39;&amp;gt; (1, 2, 3)
&amp;lt;type &#39;dict&#39;&amp;gt; {&#39;y&#39;: 5, &#39;x&#39;: 4}
1
2
3
y = 5
x = 4

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;从打印的信息中可以看出，args是一个元组，而kwargs是一个字典。&lt;/p&gt;

&lt;p&gt;可以说在python中操作可变参数是非常简单的，那么C语言中是否同样有类似的功能？&lt;/p&gt;

&lt;p&gt;答案是肯定的。我们都该知道printf函数的参数的个数是可变的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
int printf(const char *format, ...);


printf(&amp;quot;Hello,world!&amp;quot;);  //其参数个数为1个。
printf(&amp;quot;a=%d,b=%s,c=%c&amp;quot;, a, b, c);  //其参数个数为4个。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;printf原型中&amp;hellip;表示参数个数是不定的。那么我们该怎么实现这个可变参数函数呢？&lt;/p&gt;

&lt;p&gt;为了编写可变参数函数，我们通常需要用到&lt;stdarg.h&gt;头文件中定义的以下函数:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void va_start(va_list ap, last);
type va_arg(va_list ap, type);
void va_end(va_list ap);
void va_copy(va_list dest, va_list src);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中：
va_list是用于存放参数列表的数据结构。&lt;/p&gt;

&lt;p&gt;va_start函数根据初始化last来初始化参数列表。&lt;/p&gt;

&lt;p&gt;va_arg函数用于从参数列表中取出一个参数，参数类型由type指定。&lt;/p&gt;

&lt;p&gt;va_copy函数用于复制参数列表。&lt;/p&gt;

&lt;p&gt;va_end函数执行清理参数列表的工作。&lt;/p&gt;

&lt;p&gt;上述函数通常用宏来实现，例如标准ANSI形式下，这些宏的定义是：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;typedef char * va_list; //字符串指针
//字节对齐
#define _INTSIZEOF(n) ( (sizeof(n) + sizeof(int) - 1) &amp;amp; ~(sizeof(int) - 1) )
#define va_start(ap,v) ( ap = (va_list)&amp;amp;v + _INTSIZEOF(v) )
#define va_arg(ap,t) ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )
#define va_end(ap) ( ap = (va_list)0 )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以参考一下:
&lt;a href=&#34;http://www.cnblogs.com/wangyonghui/archive/2010/07/12/1776068.html&#34;&gt;http://www.cnblogs.com/wangyonghui/archive/2010/07/12/1776068.html&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>使用pgpool&#43;流复制搭建Postgresql高可用环境</title>
      <link>/post/pgpool/</link>
      <pubDate>Sun, 10 May 2015 19:18:40 +0800</pubDate>
      
      <guid>/post/pgpool/</guid>
      <description>&lt;p&gt;研究了2周的pgpool搭建终于有点了成果，在这里总结下整个过程。&lt;/p&gt;

&lt;h2 id=&#34;一-环境&#34;&gt;一.环境&lt;/h2&gt;

&lt;p&gt;db1 10.0.0.2  ubuntu 14.04 server&lt;/p&gt;

&lt;p&gt;db2 10.0.0.3  ubuntu 14.04 server&lt;/p&gt;

&lt;p&gt;watchdog VIP： 10.0.0.4&lt;/p&gt;

&lt;p&gt;pg版本：    9.4.0&lt;/p&gt;

&lt;p&gt;pgpool版本：3.4.1&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 创建postgres用户，并创建用于安装pg的目录
root@ubuntu:~# groupadd postgres
root@ubuntu:~# useradd -g postgres -d /home/postgres -m -s /bin/bash postgres
root@ubuntu:~# passwd postgres
root@ubuntu:~# su - postgres
postgres@ubuntu:~ mkdir -p /home/postgres/db/data
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改两个节点的hosts文件，设置postgres用户之间无密码连接，使用ssh-keygen和ssh-copy-id两个命令。&lt;/p&gt;

&lt;p&gt;依赖包，源码在两个节点上都需要安装。&lt;/p&gt;

&lt;h2 id=&#34;二-依赖包的安装&#34;&gt;二.依赖包的安装&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 编译postgresql源码需要zlib1g-dev libreadline-dev flex bison make
root@ubuntu:~# apt-get install --yes --force-yes zlib1g-dev libreadline-dev flex bison make

# pgpool watchdog需要arping
root@ubuntu:~# apt-get install --yes --force-yes arping
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;三-源码安装&#34;&gt;三.源码安装&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 编译pg源码并安装
root@ubuntu:~# tar xvf postgresql-9.4.0.tar.bz2 -C /tmp
root@ubuntu:~# cd /tmp/postgresql-9.4.0
root@ubuntu:/tmp/postgresql-9.4.0~# ./configure --prefix &amp;amp;&amp;amp; make &amp;amp;&amp;amp; make install

# 将pg加入环境变量
root@ubuntu:~# sed -i &#39;1i\PATH=\$PATH:/home/postgres/db/bin \nexport PGDATA=/home/postgres/db/data&#39; /home/postgres/.bashrc
root@ubuntu:~# sed -i &#39;1i\PATH=\$PATH:/home/postgres/db/bin \nexport PGDATA=/home/postgres/db/data&#39; /root/.bashrc
root@ubuntu:~# source ~/.bashrc

# 编译pgpool源码并安装
root@ubuntu:~# tar xvf pgpool-II-3.4.1.tar.gz -C /tmp
root@ubuntu:~# cd /tmp/pgpool-II-3.4.1
root@ubuntu:/tmp/pgpool-II-3.4.1~# ./configure --prefix &amp;amp;&amp;amp; make &amp;amp;&amp;amp; make install
# 安装pgpool-recovery，用于在线恢复
# pg9.4版本中已经含有pgpool-regclass，所以这里不用安装
root@ubuntu:/tmp/pgpool-II-3.4.1~# cd src/sql/pgpool-recovery &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;拷贝pcp.conf，pgpool.conf和pool_hba.conf，默认在/usr/local/etc下&lt;/p&gt;

&lt;p&gt;创建/var/run/pgpool，/var/log/pgpool，修改目录权限&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@ubuntu:~# mkdir /var/run/pgpool /var/log/pgpool
root@ubuntu:~# chown -R postgres:postgres /var/run/pgpool /var/log/pgpool /usr/local/etc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在/home/postgres/db/bin下添加failover_stream.sh脚本（注意执行权限），该脚本用于
故障切换。&lt;/p&gt;

&lt;p&gt;failover_stream.sh&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#!/usr/bin/env bash
# Execute command by failover.
# special values:
# 特殊字符	描述
# %d	断开连接的节点的后台 ID。
# %h	断开连接的节点的主机名。
# %p	断开连接的节点的端口号。
# %D	断开连接的节点的数据库实例所在目录。
# %M	旧的主节点 ID。
# %m	新的主节点 ID。
# %H	新的主节点主机名。
# %P	旧的第一节点 ID。
# %r    新的主节点端口
# %R    新的主节点数据库实例目录
# %%	&#39;%&#39; 字符

# ---------------------------------------------------------------------
# prepare
# ---------------------------------------------------------------------

SCRIPT_LOG=&amp;quot;/var/log/pgpool/failover.log&amp;quot;

FAILED_NODE_ID=${1}
FAILED_NODE_HOST=${2}
FAILED_NODE_PORT=${3}
FAILED_NODE_PGDATA=${4}
NEW_MASTER_NODE_ID=${5}
OLD_MASTER_NODE_ID=${6}
NEW_MASTER_NODE_HOST=${7}
OLD_PRIMARY_NODE_ID=${8}
NEW_MASTER_NODE_PORT=${9}
NEW_MASTER_NODE_PGDATA=${10}

echo &amp;quot;----------------------------------------------------------------------&amp;quot; &amp;gt;&amp;gt; ${SCRIPT_LOG}
date &amp;gt;&amp;gt; ${SCRIPT_LOG}
echo &amp;quot;----------------------------------------------------------------------&amp;quot; &amp;gt;&amp;gt; ${SCRIPT_LOG}
echo &amp;quot;&amp;quot; &amp;gt;&amp;gt; ${SCRIPT_LOG}

echo &amp;quot;
[ node which failed ]
FAILED_NODE_ID           ${FAILED_NODE_ID}
FAILED_NODE_HOST         ${FAILED_NODE_HOST}
FAILED_NODE_PORT         ${FAILED_NODE_PORT}
FAILED_NODE_PGDATA       ${FAILED_NODE_PGDATA}

[ before failover ]
OLD_PRIMARY_NODE_ID      ${OLD_PRIMARY_NODE_ID}
OLD_MASTER_NODE_ID       ${OLD_MASTER_NODE_ID}

[ after faiover ]
NEW_MASTER_NODE_ID       ${NEW_MASTER_NODE_ID}
NEW_MASTER_NODE_HOST     ${NEW_MASTER_NODE_HOST}
NEW_MASTER_NODE_PORT     ${NEW_MASTER_NODE_PORT}
NEW_MASTER_NODE_PGDATA   ${NEW_MASTER_NODE_PGDATA}
&amp;quot; &amp;gt;&amp;gt; ${SCRIPT_LOG}

# ---------------------------------------------------------------------
# Do promote only when the primary node failes
# ---------------------------------------------------------------------

if [ &amp;quot;${FAILED_NODE_ID}&amp;quot; == &amp;quot;${OLD_PRIMARY_NODE_ID}&amp;quot; ]; then
    PROMOTE_COMMAND=&amp;quot;pg_ctl -D ${NEW_MASTER_NODE_PGDATA} promote&amp;quot;

    echo &amp;quot;The primary node (node ${OLD_PRIMARY_NODE_ID}) dies.&amp;quot; &amp;gt;&amp;gt; ${SCRIPT_LOG}
    echo &amp;quot;Node ${NEW_MASTER_NODE_ID} takes over the primary.&amp;quot; &amp;gt;&amp;gt; ${SCRIPT_LOG}

    echo &amp;quot;Execute: ${PROMOTE_COMMAND}&amp;quot; &amp;gt;&amp;gt; ${SCRIPT_LOG}
    ssh postgres@${NEW_MASTER_NODE_HOST} -T &amp;quot;${PROMOTE_COMMAND}&amp;quot; &amp;gt;&amp;gt; ${SCRIPT_LOG}

else
    echo &amp;quot;Node ${FAILED_NODE_ID} dies, but it&#39;s not the primary node. This script doesn&#39;t anything.&amp;quot; &amp;gt;&amp;gt; ${SCRIPT_LOG}
fi

echo &amp;quot;&amp;quot; &amp;gt;&amp;gt; ${SCRIPT_LOG}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在/home/postgres/db/data下添加basebackup.sh和pgpool_remote_start，用于在线恢复。&lt;/p&gt;

&lt;p&gt;basebackup.sh，db1上$host修改成db1，db2上同理。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#!/usr/bin/env bash
# Recovery script for streaming replication.
# This script assumes that DB node 0 is primary, and 1 is standby.
#
datadir=$1
desthost=$2
destdir=$3

psql -c &amp;quot;SELECT pg_start_backup(&#39;Streaming Replication&#39;, true)&amp;quot; postgres

ssh -T postgres@$desthost mv $destdir/basebackup.sh $destdir/../
ssh -T postgres@$desthost rm -rf $destdir/*
ssh -T postgres@$desthost pg_basebackup -D $destdir -Fp -Xs -v -P -h $host -U repl
ssh -T postgres@$desthost mv $destdir/../basebackup.sh $destdir/

ssh -T postgres@$desthost mv $destdir/recovery.done $destdir/recovery.conf
ssh -T postgres@$desthost &amp;quot;sed -i \&amp;quot;s/[# ]*primary_conninfo[ ]*=.*/primary_conninfo = &#39;host=$host port=5432 user=$PG_REPL_USER&#39;/g\&amp;quot; $destdir/recovery.conf&amp;quot;

psql -c &amp;quot;SELECT pg_stop_backup()&amp;quot; postgres
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;pgpool_remote_start&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#!/usr/bin/env bash
# start postmaster on the recoveried node

if [ $# -ne 2 ]
then
    echo &amp;quot;pgpool_remote_start remote_host remote_datadir&amp;quot;
    exit 1
fi

SCRIPT_LOG=&amp;quot;/var/log/pgpool/remote_start.log&amp;quot;

DEST_HOST=$1

echo &amp;quot;----------------------------------------------------------------------&amp;quot; &amp;gt;&amp;gt; ${SCRIPT_LOG}
date &amp;gt;&amp;gt; ${SCRIPT_LOG}
echo &amp;quot;----------------------------------------------------------------------&amp;quot; &amp;gt;&amp;gt; ${SCRIPT_LOG}
echo &amp;quot;&amp;quot; &amp;gt;&amp;gt; ${SCRIPT_LOG}

COMMAND=&amp;quot;pg_ctl -w  start &amp;gt; /dev/null 2&amp;gt;&amp;amp;1&amp;quot;

echo &amp;quot;
DEST_HOST         ${DEST_HOST}
COMMAND           ${COMMAND}
&amp;quot; &amp;gt;&amp;gt; ${SCRIPT_LOG}

echo &amp;quot;remote start&amp;quot; &amp;gt;&amp;gt; ${SCRIPT_LOG}
ssh postgres@${DEST_HOST} -T &amp;quot;${COMMAND}&amp;quot;

ps auwx | grep postgres &amp;gt;&amp;gt; ${SCRIPT_LOG}
echo &amp;quot;&amp;quot; &amp;gt;&amp;gt; ${SCRIPT_LOG}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;四-配置db1&#34;&gt;四.配置db1&lt;/h2&gt;

&lt;p&gt;初始化并启动&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;root@ubuntu~# su - postgres
postgres@ubuntu:~$ initdb -U postgres
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改postgresql.conf配置文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;log_destination = &#39;csvlog&#39; # 使用csv格式的log,因为一般会按大小和时间自动切割
logging_collector = on # 如果使用csvlog，那么要开启日志收集
listen_addresses = &#39;*&#39;
wal_level = hot_standby # 日志级别使用hot_standby
archive_mode = on
archive_command = &#39;cp %p /home/postgres/db/archive/%f&#39;
max_wal_senders = 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动pg，添加pgpool_recovery扩展&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;postgres@ubuntu:~$ pg_ctl start &amp;gt; /dev/null 2&amp;gt;&amp;amp;1
postgres@ubuntu:~$ psql template1 -c &#39;create extension pgpool_recovery;&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建用于备份的用户&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;postgres@ubuntu:~$ createuser rep -l --replication -E -P
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改pg_hba.conf，加入&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;host  all      rep      10.0.0.0/24    trust
host  all      postgres 10.0.0.0/24    trust
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;五-配置db2&#34;&gt;五.配置db2&lt;/h2&gt;

&lt;p&gt;通过pg_basebackup和db1同步&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;postgres@ubuntu:~$ pg_basebackup -D /home/postgres/db/data -Fp -Xs -v -P -h db1 -U rep
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从/home/postgres/db/share下拷贝recovery.conf文件到data目录下，并修改&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;standby_mode = on
primary_conninfo = &#39;host=db1 port=5432 user=rep&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改postgresql.conf配置：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;hot_standby = on # 开启热备模式
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动pg&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;postgres@ubuntu:~$ pg_ctl start &amp;gt; /dev/null 2&amp;gt;&amp;amp;1
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;六-配置pgpool&#34;&gt;六.配置pgpool&lt;/h2&gt;

&lt;p&gt;修改db1上pgpool.conf：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;listen_addresses = &#39;*&#39;
pcp_listen_addresses = &#39;*&#39;
enable_pool_hba = on
pool_passwd = &#39;pool_passwd&#39;
replication_mode = off # 关闭复制模式
load_balance_mode = on # 打开负载均衡
master_slave_mode = on # 打开主备
log_destination = &#39;syslog&#39; # 日志使用syslog
master_slave_sub_mode=&#39;stream&#39; # 使用流复制
sr_check_user = &#39;rep&#39;
sr_check_password = &#39;rep&#39; # 创建rep用户的时候指定
health_check_user = &#39;rep&#39;
health_check_password = &#39;rep&#39;
failover_command = &#39;/home/postgres/db/failover_stream.sh %d %h %p %D %m %M %H %P %r %R&#39;
backend_hostname0 = &#39;db1&#39;
backend_port0 = 5432
backend_weight0 = 1
backend_data_directory0 = &#39;/home/postgres/db/data&#39;
backend_flag0 = &#39;ALLOW_TO_FAILOVER&#39;
backend_hostname1 = &#39;db2&#39;
backend_port1 = 5432
backend_weight1 = 1
backend_data_directory1 = &#39;/home/postgres/db/data&#39;
backend_flag1 = &#39;ALLOW_TO_FAILOVER&#39;
use_watchdog = on # 开启watchdog
wd_hostname = &#39;db1&#39;
delegate_IP = &#39;10.0.0.4&#39;
heartbeat_destination0 = &#39;db2&#39;
other_pgpool_hostname0 = &#39;db2&#39;
other_pgpool_port0 = 9999
other_wd_port0 = 9000
recovery_user = &#39;postgres&#39;
recovery_password = &#39;&#39;
recovery_1st_stage_command = &#39;basebackup.sh&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改db2上pgpool.conf（和db1中有区别的）:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;wd_hostname = &#39;db2&#39;
heartbeat_destination0 = &#39;db1&#39;
other_pgpool_hostname0 = &#39;db1&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;db1和db2上的pool_hba.conf中添加&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;host all postgres 10.0.0.0/24 trust
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;db1和db2上的/etc/rsyslog.conf添加，并重启rsyslog&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;local0.*    /var/log/pgpool.log
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用pg_md5生成密钥，db1和db2上的密钥可能不同:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;postgres@ubuntu:~$ pg_md5 postgres
21232f297a57a5a743894a0e4a801fc3

# 在pcp.conf中添加postgres:21232f297a57a5a743894a0e4a801fc3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在db1和db2上启动pgpool&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;postgres@ubuntu:~$ pgpool
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;至此，安装完成，下面进行简单的测试。&lt;/p&gt;

&lt;h2 id=&#34;七-测试&#34;&gt;七.测试&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 使用VIP登录pg，发现db1主，db2备
postgres@ubuntu:~$ psql -h 10.0.0.4 -p 9999
psql (9.4.0)
Type &amp;quot;help&amp;quot; for help.

postgres=# show pool_nodes;
 node_id | hostname | port | status | lb_weight |  role
---------+----------+------+--------+-----------+---------
 0       | db1      | 5432 | 2      | 0.500000  | primary
 1       | db2      | 5432 | 2      | 0.500000  | standby
(2 rows)

# 关闭db1上的pg服务，再次查看nodes，故障切换完成，db1变成备，db2变成主

postgres=# show pool_nodes;
 node_id | hostname | port | status | lb_weight |  role
---------+----------+------+--------+-----------+---------
 0       | db1      | 5432 | 3      | 0.500000  | standby
 1       | db2      | 5432 | 2      | 0.500000  | primary
(2 rows)

# 恢复db1，注意要进行恢复操作，必须使用主节点上的pgpool服务
# 这里db2目前是主节点，所以pgpool的hostname使用db2
postgres@ubuntu:~$ pcp_recovery_node -d 5 db2 9898 postgres postgres 0

postgres=# show pool_nodes;
 node_id | hostname | port | status | lb_weight |  role
---------+----------+------+--------+-----------+---------
 0       | db1      | 5432 | 2      | 0.500000  | standby
 1       | db2      | 5432 | 2      | 0.500000  | primary
(2 rows)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中status的值如下：&lt;/p&gt;

&lt;p&gt;0：从未使用，直接忽略&lt;/p&gt;

&lt;p&gt;1：server已经启动，但是连接池中没有连接&lt;/p&gt;

&lt;p&gt;2：server已经启动，并且在连接池中存在连接&lt;/p&gt;

&lt;p&gt;3：server没有启动或者联系不上&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Python routes</title>
      <link>/post/python-routes/</link>
      <pubDate>Wed, 08 Apr 2015 19:21:51 +0800</pubDate>
      
      <guid>/post/python-routes/</guid>
      <description>&lt;h2 id=&#34;ruotes简介&#34;&gt;Ruotes简介&lt;/h2&gt;

&lt;p&gt;Routes解决了一个Web开发中经常遇到的问题，那就是怎么将url请求map到app，也就是，你怎么能说&amp;rsquo;/blog/2008/01/08&amp;rsquo;做这件事，而&amp;rsquo;/login&amp;rsquo;却做另外一个。许多Web框架都有一个内置的调度系统。比如，&amp;rsquo;/A/B/C&amp;rsquo;表示在目录B中读文件C，或者在&amp;rsquo;A.B&amp;rsquo;模块中调用B类的C方法。这样看，毫无问题。但是，当你要重新组织urls的时候，改动就会很大。&lt;/p&gt;

&lt;p&gt;Routes却另辟蹊径。它将url层次和action分离，你可以按照你想要的方式去连接它们。如果你要改变一个特定的url，只要改变route map的一行代码，而不用改变action的逻辑。甚至你可以将多个url指向相同的action。Routes最早起源于Ruby on Rails，到现在已经有很大的不同了。&lt;/p&gt;

&lt;p&gt;Ruotes是Pylons框架最初的调度系统，也是CherrPy的一种调度。所有的Web框架都能用它来处理整个url架构或者是url的subtree。它也可以将subtree指向其他的调度，TurboGear 2在Pylons就是这么实现的。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;搭建routes&#34;&gt;搭建Routes&lt;/h2&gt;

&lt;p&gt;Routes安装可以用pip或者easy_insatll，也可以下载源码用python setup.py install安装。&lt;/p&gt;

&lt;p&gt;Pylons中，在myapp/config/routing.py模块的make_map函数中定义routes，下面是一个典型的配置：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from routes import Mapper
map = Mapper()
map.connect(None, &amp;quot;/error/{action}/{id}&amp;quot;, controller=&amp;quot;error&amp;quot;)
map.connect(&amp;quot;home&amp;quot;, &amp;quot;/&amp;quot;, controller=&amp;quot;main&amp;quot;, action=&amp;quot;index&amp;quot;)
# ADD CUSTOM ROUTES HERE
map.connect(None, &amp;quot;/{controller}/{action}&amp;quot;)
map.connect(None, &amp;quot;/{controller}/{action}/{id}&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第1行和第2行创建一个mapper。&lt;/p&gt;

&lt;p&gt;第3行匹配以&amp;rsquo;/error&amp;rsquo;开头的三层url，将controller参数设置成常量。url请求&amp;rsquo;/error/images/arrow.jpg&amp;rsquo;会产生：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;{&amp;quot;controller&amp;quot;: &amp;quot;error&amp;quot;, &amp;quot;action&amp;quot;: &amp;quot;images&amp;quot;, &amp;quot;id&amp;quot;: &amp;quot;arrow.jpg&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第4行匹配&amp;rsquo;/&amp;lsquo;, controller和action参数都设置成了常量，还有route名称&amp;rsquo;home&amp;rsquo;，它可以用来生成url。（其他route用None代替name。建议生成url的route都命名，其他route没有必要。）&lt;/p&gt;

&lt;p&gt;第6行匹配任意的两层url，第7行匹配任意三层url。当我们不想为每个action都定义不同的route时，这么做是很有用的。当然，如果你为每个action都定义了route，就可以删掉这两行了。&lt;/p&gt;

&lt;p&gt;注意，&amp;rsquo;/error/images/arrow.jpg&amp;rsquo;可以匹配第3行和第7行。mapper是按顺序匹配，所以这个url匹配第3行。&lt;/p&gt;

&lt;p&gt;如果没有route能匹配url，mapper会返回&amp;rsquo;matach failed&amp;rsquo;，在Pylons就是&amp;rsquo;404 Not Found&amp;rsquo;。&lt;/p&gt;

&lt;p&gt;Route path必须以&amp;rsquo;/&amp;lsquo;开头。&lt;/p&gt;

&lt;h3 id=&#34;requirements&#34;&gt;Requirements&lt;/h3&gt;

&lt;p&gt;Route path可以使用正则表达式。有两种方式：一是行内，二是使用requirements参数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;map.connect(R&amp;quot;/blog/{id:\d+}&amp;quot;)
map.connect(R&amp;quot;/download/{platform:windows|mac}/{filename}&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;等同于：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;map.connect(&amp;quot;/blog/{id}&amp;quot;, requirements={&amp;quot;id&amp;quot;: R&amp;quot;\d+&amp;quot;}
map.connect(&amp;quot;/download/{platform}/{filename}&amp;quot;,
    requirements={&amp;quot;platform&amp;quot;: R&amp;quot;windows|mac&amp;quot;})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了包含&amp;rsquo;\&amp;lsquo;，正则表达式使用了R&amp;rdquo;&amp;ldquo;。如果不用R，就要使用&amp;rsquo;\&amp;lsquo;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;m.connect(&amp;quot;archives/{year}/{month}/{day}&amp;quot;, controller=&amp;quot;archives&amp;quot;,
          action=&amp;quot;view&amp;quot;, year=2004,
          requirements=dict(year=R&amp;quot;\d{2,4}&amp;quot;, month=R&amp;quot;\d{1,2}&amp;quot;))

NUMERIC = R&amp;quot;\d+&amp;quot;
map.connect(..., requirements={&amp;quot;id&amp;quot;: NUMERIC})

ARTICLE_REQS = {&amp;quot;year&amp;quot;: R&amp;quot;\d\d\d\d&amp;quot;, &amp;quot;month&amp;quot;: R&amp;quot;\d\d&amp;quot;, &amp;quot;day&amp;quot;: R&amp;quot;\d\d&amp;quot;}
map.connect(..., requirements=ARTICLE_REQS)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;conditions&#34;&gt;Conditions&lt;/h3&gt;

&lt;p&gt;Conditions决定匹配何种请求。conditions参数是一个字典，有三个key：&lt;/p&gt;

&lt;p&gt;method&lt;/p&gt;

&lt;p&gt;大写的HTTP方法列表，请求的方法必须是其中某一种。&lt;/p&gt;

&lt;p&gt;sub_domain&lt;/p&gt;

&lt;p&gt;可以是subdomain列表，True，False或者None。如果是列表，请求必须调用列表中的subdomain。如果是True，请求必须包括任意一个subdomain。如果是False或者None，不匹配subdomain。&lt;/p&gt;

&lt;p&gt;function&lt;/p&gt;

&lt;p&gt;验证request的函数。它必须是func(envirion, match_dict) =&amp;gt; bool这种类型。如果匹配成功返回True，否则返回False。第一个参数是WSGI环境变量，第二个参数是匹配成功后返回的变量。函数还可以改变mtach。&lt;/p&gt;

&lt;p&gt;例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Match only if the HTTP method is &amp;quot;GET&amp;quot; or &amp;quot;HEAD&amp;quot;.
m.connect(&amp;quot;/user/list&amp;quot;, controller=&amp;quot;user&amp;quot;, action=&amp;quot;list&amp;quot;,
          conditions=dict(method=[&amp;quot;GET&amp;quot;, &amp;quot;HEAD&amp;quot;]))

# A sub-domain should be present.
m.connect(&amp;quot;/&amp;quot;, controller=&amp;quot;user&amp;quot;, action=&amp;quot;home&amp;quot;,
          conditions=dict(sub_domain=True))

# Sub-domain should be either &amp;quot;fred&amp;quot; or &amp;quot;george&amp;quot;.
m.connect(&amp;quot;/&amp;quot;, controller=&amp;quot;user&amp;quot;, action=&amp;quot;home&amp;quot;,
          conditions=dict(sub_domain=[&amp;quot;fred&amp;quot;, &amp;quot;george&amp;quot;]))

# Put the referrer into the resulting match dictionary.
# This function always returns true, so it never prevents the match
# from succeeding.
def referals(environ, result):
    result[&amp;quot;referer&amp;quot;] = environ.get(&amp;quot;HTTP_REFERER&amp;quot;)
    return True
m.connect(&amp;quot;/{controller}/{action}/{id}&amp;quot;,
    conditions=dict(function=referals))
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;wildcard-routes&#34;&gt;Wildcard routes&lt;/h3&gt;

&lt;p&gt;path变量默认情况不匹配&amp;rsquo;/&amp;lsquo;。这是为了保证每个path精确匹配某一层url。你可以用requirements去覆盖：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;map.connect(&amp;quot;/static/{filename:.*?}&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;匹配&amp;rsquo;/static/foo.jpg&amp;rsquo;，&amp;rsquo;/static/bar/foo.jpg&amp;rsquo;等url。&lt;/p&gt;

&lt;h3 id=&#34;format-extensions&#34;&gt;Format extensions&lt;/h3&gt;

&lt;p&gt;path中包含&amp;rsquo;{.format}&amp;lsquo;会匹配可选的扩展名（如.html或者.json），在&amp;rsquo;.&amp;lsquo;之后设置format变量。例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;map.connect(&#39;/entries/{id}{.format}&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;匹配&amp;rsquo;/entries/1&amp;rsquo;和&amp;rsquo;/entires/1.mp3&amp;rsquo;。你可以用requirements去限制匹配的扩展名：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;map.connect(&#39;/entries/{id:\d+}{.format:json}&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;匹配&amp;rsquo;/entries/1&amp;rsquo;和&amp;rsquo;/entires/1.json&amp;rsquo;，但是不匹配&amp;rsquo;/entires/1.mp3&amp;rsquo;。&lt;/p&gt;

&lt;h3 id=&#34;submappers&#34;&gt;Submappers&lt;/h3&gt;

&lt;p&gt;如果有相同的Key-value参数，可以用Submapper来添加route。有两种语法，一个使用&lt;code&gt;with&lt;/code&gt;，一个不用：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Using &#39;with&#39;
with map.submapper(controller=&amp;quot;home&amp;quot;) as m:
    m.connect(&amp;quot;home&amp;quot;, &amp;quot;/&amp;quot;, action=&amp;quot;splash&amp;quot;)
    m.connect(&amp;quot;index&amp;quot;, &amp;quot;/index&amp;quot;, action=&amp;quot;index&amp;quot;)

# Not using &#39;with&#39;
m = map.submapper(controller=&amp;quot;home&amp;quot;)
m.connect(&amp;quot;home&amp;quot;, &amp;quot;/&amp;quot;, action=&amp;quot;splash&amp;quot;)
m.connect(&amp;quot;index&amp;quot;, &amp;quot;/index&amp;quot;, action=&amp;quot;index&amp;quot;)

# Both of these syntaxes create the following routes::
# &amp;quot;/&amp;quot;      =&amp;gt; {&amp;quot;controller&amp;quot;: &amp;quot;home&amp;quot;, action=&amp;quot;splash&amp;quot;}
# &amp;quot;/index&amp;quot; =&amp;gt; {&amp;quot;controller&amp;quot;: &amp;quot;home&amp;quot;, action=&amp;quot;index&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以使用&lt;code&gt;path_prefix&lt;/code&gt;参数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;with map.submapper(path_prefix=&amp;quot;/admin&amp;quot;, controller=&amp;quot;admin&amp;quot;) as m:
    m.connect(&amp;quot;admin_users&amp;quot;, &amp;quot;/users&amp;quot;, action=&amp;quot;users&amp;quot;)
    m.connect(&amp;quot;admin_databases&amp;quot;, &amp;quot;/databases&amp;quot;, action=&amp;quot;databases&amp;quot;)

# /admin/users     =&amp;gt; {&amp;quot;controller&amp;quot;: &amp;quot;admin&amp;quot;, &amp;quot;action&amp;quot;: &amp;quot;users&amp;quot;}
# /admin/databases =&amp;gt; {&amp;quot;controller&amp;quot;: &amp;quot;admin&amp;quot;, &amp;quot;action&amp;quot;: &amp;quot;databases&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;.submapper&lt;/code&gt;的参数必须是key-value。&lt;/p&gt;

&lt;h3 id=&#34;submapper-helpers&#34;&gt;Submapper helpers&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;with map.submapper(controller=&amp;quot;home&amp;quot;) as m:
    m.connect(&amp;quot;home&amp;quot;, &amp;quot;/&amp;quot;, action=&amp;quot;splash&amp;quot;)
    m.connect(&amp;quot;index&amp;quot;, &amp;quot;/index&amp;quot;, action=&amp;quot;index&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以写成：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;with map.submapper(controller=&amp;quot;home&amp;quot;, path_prefix=&amp;quot;/&amp;quot;) as m:
    m.action(&amp;quot;home&amp;quot;, action=&amp;quot;splash&amp;quot;)
    m.link(&amp;quot;index&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;action&lt;/code&gt;在submapper的path（上例中是&amp;rsquo;/&amp;lsquo;）上生成route。而&lt;code&gt;link&lt;/code&gt;根据相关的path生成route。&lt;/p&gt;

&lt;p&gt;还有一些其他的action，&lt;code&gt;index&lt;/code&gt;，&lt;code&gt;new&lt;/code&gt;，&lt;code&gt;create&lt;/code&gt;，&lt;code&gt;show&lt;/code&gt;，&lt;code&gt;edit&lt;/code&gt;，&lt;code&gt;update&lt;/code&gt;和&lt;code&gt;delete&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;with map.submapper(controller=&amp;quot;entries&amp;quot;, path_prefix=&amp;quot;/entries&amp;quot;) as entries:
    entries.index()
    with entries.submapper(path_prefix=&amp;quot;/{id}&amp;quot;) as entry:
        entry.show()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;with map.submapper(controller=&amp;quot;entries&amp;quot;, path_prefix=&amp;quot;/entries&amp;quot;,
                   actions=[&amp;quot;index&amp;quot;]) as entries:
    entries.submapper(path_prefix=&amp;quot;/{id}&amp;quot;, actions=[&amp;quot;show&amp;quot;])
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;map.collection(collection_name=&amp;quot;entries&amp;quot;, member_name=&amp;quot;entry&amp;quot;,
               controller=&amp;quot;entries&amp;quot;,
               collection_actions=[&amp;quot;index&amp;quot;], member_actions[&amp;quot;show&amp;quot;])
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;restful-services&#34;&gt;RESTful services&lt;/h2&gt;

&lt;p&gt;map.resource使Restful风格的url更加容易，它创建了一个&amp;rsquo;add/modify/delete&amp;rsquo;route集。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;map.resource(&amp;quot;message&amp;quot;, &amp;quot;messages&amp;quot;)

# The above command sets up several routes as if you had typed the
# following commands:
map.connect(&amp;quot;messages&amp;quot;, &amp;quot;/messages&amp;quot;,
    controller=&amp;quot;messages&amp;quot;, action=&amp;quot;create&amp;quot;,
    conditions=dict(method=[&amp;quot;POST&amp;quot;]))
map.connect(&amp;quot;messages&amp;quot;, &amp;quot;/messages&amp;quot;,
    controller=&amp;quot;messages&amp;quot;, action=&amp;quot;index&amp;quot;,
    conditions=dict(method=[&amp;quot;GET&amp;quot;]))
map.connect(&amp;quot;formatted_messages&amp;quot;, &amp;quot;/messages.{format}&amp;quot;,
    controller=&amp;quot;messages&amp;quot;, action=&amp;quot;index&amp;quot;,
    conditions=dict(method=[&amp;quot;GET&amp;quot;]))
map.connect(&amp;quot;new_message&amp;quot;, &amp;quot;/messages/new&amp;quot;,
    controller=&amp;quot;messages&amp;quot;, action=&amp;quot;new&amp;quot;,
    conditions=dict(method=[&amp;quot;GET&amp;quot;]))
map.connect(&amp;quot;formatted_new_message&amp;quot;, &amp;quot;/messages/new.{format}&amp;quot;,
    controller=&amp;quot;messages&amp;quot;, action=&amp;quot;new&amp;quot;,
    conditions=dict(method=[&amp;quot;GET&amp;quot;]))
map.connect(&amp;quot;/messages/{id}&amp;quot;,
    controller=&amp;quot;messages&amp;quot;, action=&amp;quot;update&amp;quot;,
    conditions=dict(method=[&amp;quot;PUT&amp;quot;]))
map.connect(&amp;quot;/messages/{id}&amp;quot;,
    controller=&amp;quot;messages&amp;quot;, action=&amp;quot;delete&amp;quot;,
    conditions=dict(method=[&amp;quot;DELETE&amp;quot;]))
map.connect(&amp;quot;edit_message&amp;quot;, &amp;quot;/messages/{id}/edit&amp;quot;,
    controller=&amp;quot;messages&amp;quot;, action=&amp;quot;edit&amp;quot;,
    conditions=dict(method=[&amp;quot;GET&amp;quot;]))
map.connect(&amp;quot;formatted_edit_message&amp;quot;, &amp;quot;/messages/{id}.{format}/edit&amp;quot;,
    controller=&amp;quot;messages&amp;quot;, action=&amp;quot;edit&amp;quot;,
    conditions=dict(method=[&amp;quot;GET&amp;quot;]))
map.connect(&amp;quot;message&amp;quot;, &amp;quot;/messages/{id}&amp;quot;,
    controller=&amp;quot;messages&amp;quot;, action=&amp;quot;show&amp;quot;,
    conditions=dict(method=[&amp;quot;GET&amp;quot;]))
map.connect(&amp;quot;formatted_message&amp;quot;, &amp;quot;/messages/{id}.{format}&amp;quot;,
    controller=&amp;quot;messages&amp;quot;, action=&amp;quot;show&amp;quot;,
    conditions=dict(method=[&amp;quot;GET&amp;quot;]))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;GET    /messages        =&amp;gt; messages.index()    =&amp;gt; url(&amp;quot;messages&amp;quot;)
POST   /messages        =&amp;gt; messages.create()   =&amp;gt; url(&amp;quot;messages&amp;quot;)
GET    /messages/new    =&amp;gt; messages.new()      =&amp;gt; url(&amp;quot;new_message&amp;quot;)
PUT    /messages/1      =&amp;gt; messages.update(id) =&amp;gt; url(&amp;quot;message&amp;quot;, id=1)
DELETE /messages/1      =&amp;gt; messages.delete(id) =&amp;gt; url(&amp;quot;message&amp;quot;, id=1)
GET    /messages/1      =&amp;gt; messages.show(id)   =&amp;gt; url(&amp;quot;message&amp;quot;, id=1)
GET    /messages/1/edit =&amp;gt; messages.edit(id)   =&amp;gt; url(&amp;quot;edit_message&amp;quot;, id=1)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;resource-options&#34;&gt;Resource options&lt;/h3&gt;

&lt;p&gt;controller&lt;/p&gt;

&lt;p&gt;collection&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;map.resource(&amp;quot;message&amp;quot;, &amp;quot;messages&amp;quot;, collection={&amp;quot;rss&amp;quot;: &amp;quot;GET&amp;quot;})
# &amp;quot;GET /messages/rss&amp;quot;  =&amp;gt;  ``Messages.rss()``.
# Defines a named route &amp;quot;rss_messages&amp;quot;.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;member&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;map.resource(&#39;message&#39;, &#39;messages&#39;, member={&#39;mark&#39;:&#39;POST&#39;})
# &amp;quot;POST /message/1/mark&amp;quot;  =&amp;gt;  ``Messages.mark(1)``
# also adds named route &amp;quot;mark_message&amp;quot;

map.resource(&amp;quot;message&amp;quot;, &amp;quot;messages&amp;quot;, member={&amp;quot;ask_delete&amp;quot;: &amp;quot;GET&amp;quot;}
# &amp;quot;GET /message/1/ask_delete&amp;quot;   =&amp;gt;   ``Messages.ask_delete(1)``.
# Also adds a named route &amp;quot;ask_delete_message&amp;quot;.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;new&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;map.resource(&amp;quot;message&amp;quot;, &amp;quot;messages&amp;quot;, new={&amp;quot;preview&amp;quot;: &amp;quot;POST&amp;quot;})
# &amp;quot;POST /messages/new/preview&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;path_prefix&lt;/p&gt;

&lt;p&gt;所有url的前置。&lt;/p&gt;

&lt;p&gt;name_prefix&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;map.resource(&amp;quot;message&amp;quot;, &amp;quot;messages&amp;quot;, controller=&amp;quot;categories&amp;quot;,
    path_prefix=&amp;quot;/category/{category_id}&amp;quot;,
    name_prefix=&amp;quot;category_&amp;quot;)
# GET /category/7/message/1
# Adds named route &amp;quot;category_message&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;parent_resource&lt;/p&gt;

&lt;p&gt;一个包含父resource信息的字典，在创建嵌套resource使用。它应该包含member_name和collection_name。&lt;/p&gt;

&lt;p&gt;如果指定parent_resource而没有path_prefix，path_prefix将用&amp;rsquo;&amp;lt;parent collection name&amp;gt;/:&amp;lt;parent member name&amp;gt;_id&amp;rsquo;生成。&lt;/p&gt;

&lt;p&gt;如果指定parent_resource而没有name_prefix，name_prefix将用&amp;rsquo;&amp;lt;parent member name&amp;gt;_&amp;lsquo;生成。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; m = Mapper()
&amp;gt;&amp;gt;&amp;gt; m.resource(&#39;location&#39;, &#39;locations&#39;,
...            parent_resource=dict(member_name=&#39;region&#39;,
...                                 collection_name=&#39;regions&#39;))
&amp;gt;&amp;gt;&amp;gt; # path_prefix is &amp;quot;regions/:region_id&amp;quot;
&amp;gt;&amp;gt;&amp;gt; # name prefix is &amp;quot;region_&amp;quot;
&amp;gt;&amp;gt;&amp;gt; url(&#39;region_locations&#39;, region_id=13)
&#39;/regions/13/locations&#39;
&amp;gt;&amp;gt;&amp;gt; url(&#39;region_new_location&#39;, region_id=13)
&#39;/regions/13/locations/new&#39;
&amp;gt;&amp;gt;&amp;gt; url(&#39;region_location&#39;, region_id=13, id=60)
&#39;/regions/13/locations/60&#39;
&amp;gt;&amp;gt;&amp;gt; url(&#39;region_edit_location&#39;, region_id=13, id=60)
&#39;/regions/13/locations/60/edit&#39;

Overriding generated path_prefix:

&amp;gt;&amp;gt;&amp;gt; m = Mapper()
&amp;gt;&amp;gt;&amp;gt; m.resource(&#39;location&#39;, &#39;locations&#39;,
...            parent_resource=dict(member_name=&#39;region&#39;,
...                                 collection_name=&#39;regions&#39;),
...            path_prefix=&#39;areas/:area_id&#39;)
&amp;gt;&amp;gt;&amp;gt; # name prefix is &amp;quot;region_&amp;quot;
&amp;gt;&amp;gt;&amp;gt; url(&#39;region_locations&#39;, area_id=51)
&#39;/areas/51/locations&#39;

Overriding generated name_prefix:

&amp;gt;&amp;gt;&amp;gt; m = Mapper()
&amp;gt;&amp;gt;&amp;gt; m.resource(&#39;location&#39;, &#39;locations&#39;,
...            parent_resource=dict(member_name=&#39;region&#39;,
...                                 collection_name=&#39;regions&#39;),
...            name_prefix=&#39;&#39;)
&amp;gt;&amp;gt;&amp;gt; # path_prefix is &amp;quot;regions/:region_id&amp;quot;
&amp;gt;&amp;gt;&amp;gt; url(&#39;locations&#39;, region_id=51)
&#39;/regions/51/locations&#39;
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Postgresql子进程启动</title>
      <link>/post/pg-subprocess/</link>
      <pubDate>Sun, 05 Apr 2015 19:19:35 +0800</pubDate>
      
      <guid>/post/pg-subprocess/</guid>
      <description>&lt;p&gt;PG是多进程的运行模式，除了Postmaster主进程外，还有以下子进程：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;SysLogger process&lt;/li&gt;
&lt;li&gt;Startup process&lt;/li&gt;
&lt;li&gt;Bgwriter process&lt;/li&gt;
&lt;li&gt;Checkpointer process&lt;/li&gt;
&lt;li&gt;Walwriter process&lt;/li&gt;
&lt;li&gt;Walreceiver process&lt;/li&gt;
&lt;li&gt;Pgstat process&lt;/li&gt;
&lt;li&gt;Pgarchive process&lt;/li&gt;
&lt;li&gt;Auto Vacuum process&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;那么子进程到底是在何时启动的？&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;通过代码，我们很容易就能发现子进程启动的位置是在PostmasterMain中。&lt;/p&gt;

&lt;p&gt;第一个启动的进程是SysLogger：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// postmaster.c:1146
SysLoggerPID = SysLogger_Start();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SysLogger_Start中前面的一些处理不做分析了，直接到&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// syslogger.c:601
switch ((sysloggerPid = fork_process()))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;fork_process对linux的fork()函数做了一层简单的封装，返回值是一样的。
如果返回-1表示创建子进程出错；返回0表示创建成功，并且当前是在子进程中；
返回其他值就表明创建成功，并且当前在父进程中，返回值是子进程的PID。&lt;/p&gt;

&lt;p&gt;fork_process返回值是0时，进入子进程，接着走到SysLoggerMain。在这个函数中，
做了一些初始化后，进入for(;;)循环。&lt;/p&gt;

&lt;p&gt;第二个启动的进程是Startup process:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// postmaster.c:1217
StartupPID = StartupDataBase();

// postmaster.c:503
#define StartupDataBase()  StartChildProcess(StartupProcess)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在StartChildProcess中同样是调用fork_process创建子进程，返回0进入子进程，调用
AuxiliaryProcessMain。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// postmaster.c:5103
AuxiliaryProcessMain(ac, av);

// bootstrap.c:414
case StartupProcess:
    /* don&#39;t set signals, startup process has its own agenda */
    StartupProcessMain();
    proc_exit(1);

// startup.c:224
StartupXLOG();

/*
* Exit normally. Exit code 0 tells postmaster that we completed recovery
* successfully.
*/
proc_exit(0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;starup process实际的入口是StartupProcessMain。但是我们看到，在这个函数中，做完
预写日志恢复后，就正常退出了，在官方给的注释中说明，正常退出告诉postmaster，我们已经
成功恢复。那么这边退出到底是为了什么？&lt;/p&gt;

&lt;p&gt;我们先不考虑这个，如果接着跟踪代码，进入到PostmasterMain的ServerLoop中。在for(;;)循环中，
判断其他进程的PID是否为0，如果为0就创建该子进程。&lt;/p&gt;

&lt;p&gt;那么其他进程是在这个时候创建的么？&lt;/p&gt;

&lt;p&gt;答案是否。如果调试代码到这个地方，会发现，这些进程PID不为0，说明在这之前就已经创建完成了。我们不禁会问，
到底是什么时候创建的，在流程里根本没发现啊。嘿嘿，这里就要说到start process的退出了。&lt;/p&gt;

&lt;p&gt;子进程退出会像父进程也就是postmaster进程发送一个SIGCHLD信号。而在PostmasterMain的开始处，就给SIGCHLD注册
了一个信号处理函数reaper。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// postmaster.c:587
pqsignal(SIGCHLD, reaper);	/* handle child termination */

// postmaster.c:2608
if (CheckpointerPID == 0)
	CheckpointerPID = StartCheckpointer();
if (BgWriterPID == 0)
	BgWriterPID = StartBackgroundWriter();
if (WalWriterPID == 0)
	WalWriterPID = StartWalWriter();

/*
* Likewise, start other special children as needed.  In a restart
* situation, some of them may be alive already.
*/
if (!IsBinaryUpgrade &amp;amp;&amp;amp; AutoVacuumingActive() &amp;amp;&amp;amp; AutoVacPID == 0)
    AutoVacPID = StartAutoVacLauncher();
if (XLogArchivingActive() &amp;amp;&amp;amp; PgArchPID == 0)
	PgArchPID = pgarch_start();
if (PgStatPID == 0)
	PgStatPID = pgstat_start();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在reaper函数里，我们也发现了这里也有启动进程的方法，一调试代码发现其他子进程就是在这里启动的。&lt;/p&gt;

&lt;p&gt;总结一下就是，先启动SysLogger，然后是Startup，Startup退出后触发主进程启动其他进程。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Python argparse</title>
      <link>/post/python-argparse/</link>
      <pubDate>Thu, 02 Apr 2015 19:21:04 +0800</pubDate>
      
      <guid>/post/python-argparse/</guid>
      <description>&lt;p&gt;最近在看openstack cinderclient代码，就顺带着看了下argparse。argparse是Python官方推荐的命令行解析工具库。&lt;/p&gt;

&lt;p&gt;学习Python库首先要去看&lt;a href=&#34;https://docs.python.org/2.7/library/argparse.html&#34;&gt;官方文档&lt;/a&gt;，这里有个简单的&lt;a href=&#34;https://docs.python.org/2.7/howto/argparse.html#id1&#34;&gt;Tutorial&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;让我们看下Linux中常见的ls命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls
cpython  devguide  prog.py  pypy  rm-unused-function.patch
$ ls pypy
ctypes_configure  demo  dotviewer  include  lib_pypy  lib-python ...
$ ls -l
total 20
drwxr-xr-x 19 wena wena 4096 Feb 18 18:51 cpython
drwxr-xr-x  4 wena wena 4096 Feb  8 12:04 devguide
-rwxr-xr-x  1 wena wena  535 Feb 19 00:05 prog.py
drwxr-xr-x 14 wena wena 4096 Feb  7 00:59 pypy
-rw-r--r--  1 wena wena  741 Feb 18 01:01 rm-unused-function.patch
$ ls --help
Usage: ls [OPTION]... [FILE]...
List information about the FILEs (the current directory by default).
Sort entries alphabetically if none of -cftuvSUX nor --sort is specified.
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上面的四条命令我们可以学到一些概念：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;ls命令在没有参数时，默认显示当前目录下所有的内容&lt;/li&gt;
&lt;li&gt;加了pypy这个位置参数（positional argument），就会得到了pypy目录下的内容&lt;/li&gt;
&lt;li&gt;加了-l这个可选参数（optional argument）后，显示文件更多信息&lt;/li&gt;
&lt;li&gt;帮助文档&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下面我们来看argparse如何使用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;prog.py

import argparse
parser = argparse.ArgumentParser()
parser.add_argument(&amp;quot;echo&amp;quot;)
args = parser.parse_args()
print args.echo


$ python prog.py
usage: prog.py [-h] echo
prog.py: error: the following arguments are required: echo
$ python prog.py --help
usage: prog.py [-h] echo

positional arguments:
  echo

optional arguments:
  -h, --help  show this help message and exit
$ python prog.py foo
foo
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;add_argument()方法为程序添加命令行参数，而在加了参数之后，运行程序就需要额外的参数&lt;/li&gt;
&lt;li&gt;parse_args()方法返回接受到的参数，存放在args中，而且它有一个&amp;rsquo;echo&amp;rsquo;属性，值便是我们传进去的参数值，是不是很神奇？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上面的程序中，echo参数没有帮助说明，因此我们并不知道它是用来做什么的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;prog.py

import argparse
parser = argparse.ArgumentParser()
parser.add_argument(&amp;quot;echo&amp;quot;, help=&amp;quot;echo the string you use here&amp;quot;)
args = parser.parse_args()
print args.echo


$ python prog.py -h
usage: prog.py [-h] echo

positional arguments:
  echo        echo the string you use here

optional arguments:
  -h, --help  show this help message and exit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;来看一个更有意义的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;prog.py

import argparse
parser = argparse.ArgumentParser()
parser.add_argument(&amp;quot;square&amp;quot;, help=&amp;quot;display a square of a given number&amp;quot;)
args = parser.parse_args()
print args.square**2


$ python prog.py 4
Traceback (most recent call last):
  File &amp;quot;prog.py&amp;quot;, line 5, in &amp;lt;module&amp;gt;
    print args.square**2
TypeError: unsupported operand type(s) for ** or pow(): &#39;str&#39; and &#39;int&#39;


pyog.py
import argparse
parser = argparse.ArgumentParser()
parser.add_argument(&amp;quot;square&amp;quot;, help=&amp;quot;display a square of a given number&amp;quot;,
                    type=int)
args = parser.parse_args()
print args.square**2


$ python prog.py 4
16
$ python prog.py four
usage: prog.py [-h] square
prog.py: error: argument square: invalid int value: &#39;four&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上加的参数都是位置参数，下面我们试下可选参数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;prog.py

import argparse
parser = argparse.ArgumentParser()
parser.add_argument(&amp;quot;--verbosity&amp;quot;, help=&amp;quot;increase output verbosity&amp;quot;)
args = parser.parse_args()
if args.verbosity:
    print &amp;quot;verbosity turned on&amp;quot;


$ python prog.py --verbosity 1
verbosity turned on
$ python prog.py
$ python prog.py --help
usage: prog.py [-h] [--verbosity VERBOSITY]

optional arguments:
  -h, --help            show this help message and exit
  --verbosity VERBOSITY
                        increase output verbosity
$ python prog.py --verbosity
usage: prog.py [-h] [--verbosity VERBOSITY]
prog.py: error: argument --verbosity: expected one argument
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
  </channel>
</rss>