<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Sung Yung</title>
    <link>/</link>
    <description>Recent content on Sung Yung</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 03 Mar 2017 19:10:15 +0800</lastBuildDate>
    
	<atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Python Week 0001 --- property</title>
      <link>/post/python-property/</link>
      <pubDate>Fri, 03 Mar 2017 19:10:15 +0800</pubDate>
      
      <guid>/post/python-property/</guid>
      <description>&lt;p&gt;博客搭了有好久了，都是断断续续的写，甚至大半年没有新的内容。已经掌握的或者是新学习的，没有记录一旦长时间不用就会忘掉，毕竟还没有形成本能。所以还是想记录一些东西吧。哈哈，其实还有个原因就是写了没人看哈，然后就没动力了。&lt;/p&gt;

&lt;p&gt;这个系列打算一周更新一篇。定位就是内容不一定多，尽量把东西讲清楚吧。&lt;/p&gt;

&lt;p&gt;那我们就开始吧，这篇主要是关于property。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Openstack Swift tempurl 和 largeobject 支持</title>
      <link>/post/swift-tempurl/</link>
      <pubDate>Mon, 04 Jan 2016 19:07:44 +0800</pubDate>
      
      <guid>/post/swift-tempurl/</guid>
      <description>&lt;h2 id=&#34;tempurl&#34;&gt;Tempurl&lt;/h2&gt;

&lt;p&gt;在使用网盘时，我们有时会把文件共享给没有账户权限的人，这时候就需要tempurl中间件的支持。tempurl中间件可以生成一个有时限的GET链接，其他人只需要这个链接就可以进行下载。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Pythons HOWTO之属性描述符</title>
      <link>/post/python-howto-descriptor/</link>
      <pubDate>Sat, 08 Aug 2015 22:27:41 +0800</pubDate>
      
      <guid>/post/python-howto-descriptor/</guid>
      <description>&lt;p&gt;今天开个新坑，Pythons HOWTOS系列，主要是对官方文档的翻译。由于英语水平有限，基本上都是意译。这里附上&lt;a href=&#34;https://docs.python.org/2.7/howto/index.html&#34;&gt;链接&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;本篇是第一篇，主要说的是&lt;a href=&#34;https://docs.python.org/2.7/howto/descriptor.html#id2&#34;&gt;属性描述符&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Python装饰器的几种类型</title>
      <link>/post/python-decorate/</link>
      <pubDate>Mon, 27 Jul 2015 22:25:34 +0800</pubDate>
      
      <guid>/post/python-decorate/</guid>
      <description>&lt;p&gt;装饰器的原理就是闭包，这在&lt;a href=&#34;/post/python-bibao/&#34;&gt;前面&lt;/a&gt;已经提到过了。本篇主要记录一下装饰器的几种类型。&lt;/p&gt;

&lt;h2 id=&#34;无参数装饰器&#34;&gt;无参数装饰器&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def deco(func):
    def _deco(*args, **kwargs):
        print &#39;call deco&#39;
        func(*args, **kwargs)
    return _deco

@deco
def test():
    print &#39;call test&#39;

# 等同于
def test():
    print &#39;call test&#39;
test = deco(func)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Python闭包的作用域理解</title>
      <link>/post/python-bibao/</link>
      <pubDate>Wed, 22 Jul 2015 22:23:31 +0800</pubDate>
      
      <guid>/post/python-bibao/</guid>
      <description>&lt;h2 id=&#34;什么是闭包&#34;&gt;什么是闭包&lt;/h2&gt;

&lt;p&gt;在维基中，闭包的解释是这样的：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;在计算机科学中，闭包（Closure）是词法闭包（Lexical Closure）的简称，是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。所以，有另一种说法认为闭包是由函数和与其相关的引用环境组合而成的实体。闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Twisted源码分析系列01-reactor</title>
      <link>/post/python-twisted01/</link>
      <pubDate>Tue, 14 Jul 2015 22:22:03 +0800</pubDate>
      
      <guid>/post/python-twisted01/</guid>
      <description>&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;

&lt;p&gt;Twisted是用Python实现的事件驱动的网络框架。&lt;/p&gt;

&lt;p&gt;如果想看教程的话，我觉得写得最好的就是&lt;a href=&#34;http://krondo.com/?page_id=1327&#34;&gt;Twisted Introduction&lt;/a&gt;了，这是&lt;a href=&#34;https://github.com/syfun/twisted-intro-cn&#34;&gt;翻译&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>浅谈Python的with语句(转载)</title>
      <link>/post/python-with/</link>
      <pubDate>Tue, 07 Jul 2015 22:20:10 +0800</pubDate>
      
      <guid>/post/python-with/</guid>
      <description>&lt;p&gt;本文转自&lt;a href=&#34;http://www.ibm.com/developerworks/cn/opensource/os-cn-pythonwith/&#34;&gt;浅谈Python的with语句&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;引言&#34;&gt;引言&lt;/h2&gt;

&lt;p&gt;with 语句是从 Python 2.5 开始引入的一种与异常处理相关的功能（2.5 版本中要通过 from __future__ import with_statement 导入后才可以使用），从 2.6 版本开始缺省可用（参考 &lt;a href=&#34;https://docs.python.org/release/2.6/whatsnew/2.6.html#pep-343-the-with-statement&#34;&gt;What&amp;rsquo;s new in Python 2.6?&lt;/a&gt; 中 with 语句相关部分介绍）。with 语句适用于对资源进行访问的场合，确保不管使用过程中是否发生异常都会执行必要的“清理”操作，释放资源，比如文件使用后自动关闭、线程中锁的自动获取和释放等。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Python __future__ 模块</title>
      <link>/post/python-future/</link>
      <pubDate>Fri, 03 Jul 2015 22:18:29 +0800</pubDate>
      
      <guid>/post/python-future/</guid>
      <description>&lt;p&gt;在Python2.7代码中经常能看到使用__future__模块。那么__future__到底是做什么的呢？&lt;/p&gt;

&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;

&lt;p&gt;从单词含义上猜应该是“未来”的模块。它有下面几个&lt;a href=&#34;https://docs.python.org/2.7/library/__future__.html&#34;&gt;目的&lt;/a&gt;：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;避免和现有分析import工具混淆，并得到你期望的模块&lt;/li&gt;
&lt;li&gt;确保2.1之前的版本导入__future__产生运行时异常，因为2.1之前没有这个模块&lt;/li&gt;
&lt;li&gt;文档化不兼容的改变，通常这些改变会在新版中强制执行。这类文档以可执行的形式组织，通过导入__future__进行可编程式的检查。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;以上是对官方解释的粗略翻译，翻译起来感觉有些拗口。我是这么理解的，某个版本中出现了某个新的功能特性，而且这个特性和当前版本中使用的不兼容，也就是它在该版本中不是语言标准，那么我如果想要使用的话就需要从__future__模块导入。在2.1版本之前并没有__future__，所以使用它会引发异常。当然，在以后的某个版本中，比如说3中，某个特性已经成为标准的一部分，那么使用该特性就不用从__future__导入了。&lt;/p&gt;

&lt;p&gt;下面说一下__future__是如何实现新特性的。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>PaaS以及开源PaaS平台</title>
      <link>/post/pass/</link>
      <pubDate>Fri, 26 Jun 2015 22:12:41 +0800</pubDate>
      
      <guid>/post/pass/</guid>
      <description>&lt;h2 id=&#34;一-什么是iaas-paas和saas及其区别&#34;&gt;一、什么是IaaS, PaaS和SaaS及其区别&lt;/h2&gt;

&lt;p&gt;任何一个在互联网上提供其服务的公司都可以叫做云计算公司。其实云计算分几层的，
 分别是Infrastructure（基础设施）-as-a- Service，Platform（平台）-as-a-Service，
 Software（软件）-as-a-Service。基础设施在最下端，平台在 中间，软件在顶端。
 别的一些“软”的层可以在这些层上面添加。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>深入CloudFoundry一周年（转载）</title>
      <link>/post/cloudfoundry/</link>
      <pubDate>Wed, 24 Jun 2015 22:05:33 +0800</pubDate>
      
      <guid>/post/cloudfoundry/</guid>
      <description>&lt;p&gt;本文转自&lt;a href=&#34;http://ju.outofmemory.cn/entry/22259&#34;&gt;深入CloudFoundry一周年（原版）&lt;/a&gt;，有些地方稍微做些修改，毕竟是几年前的文章了。&lt;/p&gt;

&lt;h2 id=&#34;篇前语&#34;&gt;篇前语&lt;/h2&gt;

&lt;p&gt;本文在《程序员》杂志2013年1月刊刊登过，但由于篇幅排版等原因，部份内容被删除。研究院博客这次发表的版本是原稿版。可能文笔措辞有些许粗糙，但希望能给大家带来更详尽的信息。&lt;/p&gt;

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;2012年4月份，VMware突然发布了业内第一个开源的PaaS，Cloud Foundry；紧接着5月，Redhat发布了另外一个开源的PaaS，OpenShift。从此PaaS不再神秘，开始成为技术圈内的热议话题。我们研究院在CloudFoundry发布时就开始投入研究，在实验室内部署了基于Cloud Foundry私有的PaaS。到了10月份，我们总结部份研究成果，整理成博客发表在研究院的轻微博上。&lt;/p&gt;

&lt;p&gt;Cloud Foundry经过一年多的发展，文章内很多内容都已经不合时宜，这篇一周年特别版的结构重新整理，文章内容部份借鉴我的同事颜开所写的《新版CloudFoundry揭秘》以及一些同行的文章、演讲进行改写；加入部份笔者在OpenStack APAC会议上所作报告《ElasticArchitecture in Cloud Foundry and Deploy with OpenStack》内容，而CloudFoundry的安装配置、扩展运行时、自定义服务等内容，本专栏会有后续专文介绍，这里就不再重复。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C语言可变参数</title>
      <link>/post/c-args/</link>
      <pubDate>Wed, 17 Jun 2015 22:01:25 +0800</pubDate>
      
      <guid>/post/c-args/</guid>
      <description>&lt;p&gt;在python中写一个有可变参数的函数或者方法是很容易的，比如下面这个例子:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def print_args(*args, **kwargs):
	print type(args), args
	print type(kwargs), kwargs
	for arg in args:
		print arg
	for arg, value in kwargs.items():
		print &#39;%s = %s&#39; % (arg, value)

&amp;gt;&amp;gt;&amp;gt; print_args(1, 2, 3, x=4, y=5)
&amp;lt;type &#39;tuple&#39;&amp;gt; (1, 2, 3)
&amp;lt;type &#39;dict&#39;&amp;gt; {&#39;y&#39;: 5, &#39;x&#39;: 4}
1
2
3
y = 5
x = 4

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>使用pgpool&#43;流复制搭建Postgresql高可用环境</title>
      <link>/post/pgpool/</link>
      <pubDate>Sun, 10 May 2015 19:18:40 +0800</pubDate>
      
      <guid>/post/pgpool/</guid>
      <description>&lt;p&gt;研究了2周的pgpool搭建终于有点了成果，在这里总结下整个过程。&lt;/p&gt;

&lt;h2 id=&#34;一-环境&#34;&gt;一.环境&lt;/h2&gt;

&lt;p&gt;db1 10.0.0.2  ubuntu 14.04 server&lt;/p&gt;

&lt;p&gt;db2 10.0.0.3  ubuntu 14.04 server&lt;/p&gt;

&lt;p&gt;watchdog VIP： 10.0.0.4&lt;/p&gt;

&lt;p&gt;pg版本：    9.4.0&lt;/p&gt;

&lt;p&gt;pgpool版本：3.4.1&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Python routes</title>
      <link>/post/python-routes/</link>
      <pubDate>Wed, 08 Apr 2015 19:21:51 +0800</pubDate>
      
      <guid>/post/python-routes/</guid>
      <description>&lt;h2 id=&#34;ruotes简介&#34;&gt;Ruotes简介&lt;/h2&gt;

&lt;p&gt;Routes解决了一个Web开发中经常遇到的问题，那就是怎么将url请求map到app，也就是，你怎么能说&amp;rsquo;/blog/2008/01/08&amp;rsquo;做这件事，而&amp;rsquo;/login&amp;rsquo;却做另外一个。许多Web框架都有一个内置的调度系统。比如，&amp;rsquo;/A/B/C&amp;rsquo;表示在目录B中读文件C，或者在&amp;rsquo;A.B&amp;rsquo;模块中调用B类的C方法。这样看，毫无问题。但是，当你要重新组织urls的时候，改动就会很大。&lt;/p&gt;

&lt;p&gt;Routes却另辟蹊径。它将url层次和action分离，你可以按照你想要的方式去连接它们。如果你要改变一个特定的url，只要改变route map的一行代码，而不用改变action的逻辑。甚至你可以将多个url指向相同的action。Routes最早起源于Ruby on Rails，到现在已经有很大的不同了。&lt;/p&gt;

&lt;p&gt;Ruotes是Pylons框架最初的调度系统，也是CherrPy的一种调度。所有的Web框架都能用它来处理整个url架构或者是url的subtree。它也可以将subtree指向其他的调度，TurboGear 2在Pylons就是这么实现的。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Postgresql子进程启动</title>
      <link>/post/pg-subprocess/</link>
      <pubDate>Sun, 05 Apr 2015 19:19:35 +0800</pubDate>
      
      <guid>/post/pg-subprocess/</guid>
      <description>&lt;p&gt;PG是多进程的运行模式，除了Postmaster主进程外，还有以下子进程：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;SysLogger process&lt;/li&gt;
&lt;li&gt;Startup process&lt;/li&gt;
&lt;li&gt;Bgwriter process&lt;/li&gt;
&lt;li&gt;Checkpointer process&lt;/li&gt;
&lt;li&gt;Walwriter process&lt;/li&gt;
&lt;li&gt;Walreceiver process&lt;/li&gt;
&lt;li&gt;Pgstat process&lt;/li&gt;
&lt;li&gt;Pgarchive process&lt;/li&gt;
&lt;li&gt;Auto Vacuum process&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;那么子进程到底是在何时启动的？&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Python argparse</title>
      <link>/post/python-argparse/</link>
      <pubDate>Thu, 02 Apr 2015 19:21:04 +0800</pubDate>
      
      <guid>/post/python-argparse/</guid>
      <description>&lt;p&gt;最近在看openstack cinderclient代码，就顺带着看了下argparse。argparse是Python官方推荐的命令行解析工具库。&lt;/p&gt;

&lt;p&gt;学习Python库首先要去看&lt;a href=&#34;https://docs.python.org/2.7/library/argparse.html&#34;&gt;官方文档&lt;/a&gt;，这里有个简单的&lt;a href=&#34;https://docs.python.org/2.7/howto/argparse.html#id1&#34;&gt;Tutorial&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>使用VS2013编译安装postgresql</title>
      <link>/post/vs-build-pg/</link>
      <pubDate>Tue, 10 Mar 2015 19:24:26 +0800</pubDate>
      
      <guid>/post/vs-build-pg/</guid>
      <description>&lt;p&gt;整理一下在windows平台下使用vs2013编译安装postgresql的步骤，postgresql版本是9.4.0。&lt;/p&gt;

&lt;p&gt;我的pg源码目录是E:\Workspace\postgresql-9.4.0。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Paste deployment(转)</title>
      <link>/post/paste-deploy/</link>
      <pubDate>Sat, 09 Aug 2014 19:16:16 +0800</pubDate>
      
      <guid>/post/paste-deploy/</guid>
      <description>&lt;p&gt;转载自&lt;a href=&#34;http://blog.csdn.net/ztejiagn/article/details/8722765&#34;&gt;Python.Paste指南之Deploy&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Paste.Deploy主要是用来载入WSGI中的Web App应用，其核心函数是loadapp(),下文中PD就指代Paste.Deploy。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Openstack oslo.config介绍(转)</title>
      <link>/post/oslo-config/</link>
      <pubDate>Fri, 11 Jul 2014 19:15:05 +0800</pubDate>
      
      <guid>/post/oslo-config/</guid>
      <description>&lt;p&gt;&lt;strong&gt;本文转自&lt;a href=&#34;http://blog.csdn.net/networm3/article/details/8946556&#34;&gt;OpenStack源码探秘（二）——Oslo.config&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;oslo.config, OpenStack中负责CLI和CONF配置项解析的组件。E版本前，这个功能是放在cfg模块中的，
后来社区中考虑将OpenStack中共性的组件都剥离出来，统一放在oslo模块中。今后开发新的OpenStack组件，估计都要用到Oslo模块。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>url短网址算法python实现</title>
      <link>/post/swift-short-url/</link>
      <pubDate>Tue, 10 Jun 2014 19:22:40 +0800</pubDate>
      
      <guid>/post/swift-short-url/</guid>
      <description>&lt;p&gt;最近在做swift对象存储的共享功能，由于共享url过长，就想到有没有一种缩短的算法。网上查了下，便找到这种url短网址算法。&lt;/p&gt;

&lt;p&gt;算法的基本思路如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;短网址一般有6位，假如每一位是由[a-z0-9A-Z]共62个字符组成，一共有62^6~=568亿种组合。&lt;/li&gt;
&lt;li&gt;将长url存入数据库，用返回的ID转换成6位短url，再将该短url存入数据库，这样就有长短url的映射关系了。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Opensatck swift-ring-builder源码分析</title>
      <link>/post/swift-ring-builder/</link>
      <pubDate>Sun, 11 May 2014 19:23:24 +0800</pubDate>
      
      <guid>/post/swift-ring-builder/</guid>
      <description>&lt;p&gt;swift中关键的部分便是ring，那ring是如何创建的呢？&lt;/p&gt;

&lt;p&gt;我们来看bin目录下的swift-ring-builder:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import sys

from swift.cli.ringbuilder import main


if __name__ == &amp;quot;__main__&amp;quot;:
    sys.exit(main())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>